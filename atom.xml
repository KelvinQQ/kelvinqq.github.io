<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bug开发者</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bugdeveloper.gitee.io/blog/"/>
  <updated>2018-05-14T15:07:05.000Z</updated>
  <id>http://bugdeveloper.gitee.io/blog/</id>
  
  <author>
    <name>Bug开发者</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小程序利用Canvas绘制图片和竖排文字</title>
    <link href="http://bugdeveloper.gitee.io/blog/2018/05/14/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%A9%E7%94%A8Canvas%E7%BB%98%E5%88%B6%E5%9B%BE%E7%89%87%E5%92%8C%E7%AB%96%E6%8E%92%E6%96%87%E5%AD%97/"/>
    <id>http://bugdeveloper.gitee.io/blog/2018/05/14/小程序利用Canvas绘制图片和竖排文字/</id>
    <published>2018-05-14T13:53:44.000Z</published>
    <updated>2018-05-14T15:07:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>闲暇时间抽个空写了个三国杀武将手册的小程序，中间有个需求设计的是合成武将皮肤图、竖排的武将姓名、以及小程序码，然后提供保存图片到相册，最终让用户可以分享到朋友圈或其他平台。合成图片应该按照<code>Canvas</code>的文档来做都没什么问题，主要是有个竖排文字的需求，这里和大家分享一下。</p><a id="more"></a><h1 id="广告"><a href="#广告" class="headerlink" title="广告"></a>广告</h1><p>宣传一下自己的小程序，有喜欢三国杀的可以关注一下，有什么问题也可以加我微信一起讨论。</p><p><code>扫码体验小程序</code></p><p><img src="https://user-gold-cdn.xitu.io/2018/5/14/1635f1e3b5c1ccc4?w=258&amp;h=258&amp;f=jpeg&amp;s=52521" alt=""></p><p><code>扫码添加好友，请备注：三国杀</code></p><p><img src="https://user-gold-cdn.xitu.io/2018/5/14/1635f1ee2a33cc4e?w=564&amp;h=786&amp;f=jpeg&amp;s=59275" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>首先放一张最终保存到相册的图片吧~</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/14/1635f1f27875f56d?w=640&amp;h=640&amp;f=jpeg&amp;s=69607" alt=""></p><blockquote><p>自我感觉良好，至少达到了我自己的预期吧~~~</p></blockquote><p>下面让我们一步一步来看看如何实现的吧。</p><p>整个图片分为三个部分：</p><ol><li>武将图片</li><li>小程序码</li><li>武将文字信息</li></ol><p>先来看一下<code>wxml</code>里面的代码，主要是放了一个<code>canvas</code>标签，控制了一下高度和宽度属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;canvas class=&apos;share-canvas&apos; style=&quot;width:100%;height:&#123;&#123;canvasHeight&#125;&#125;px&quot; canvas-id=&quot;share_canvas&quot;&gt;&lt;/canvas&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><h3 id="武将图片"><a href="#武将图片" class="headerlink" title="武将图片"></a>武将图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">drawHeroImage: function (path) &#123;</span><br><span class="line">    var that = this;</span><br><span class="line">    // 拿到canvas context</span><br><span class="line">    let ctx = wx.createCanvasContext(&apos;share_canvas&apos;);</span><br><span class="line">    // 为了保证图片比例以及绘制的位置，先要拿到图片的大小</span><br><span class="line">    wx.getImageInfo(&#123;</span><br><span class="line">      src: path,</span><br><span class="line">      success: function (res) &#123;</span><br><span class="line"></span><br><span class="line">  // 计算图片占比信息</span><br><span class="line">        let maxWidth = Math.min(res.width, that.data.canvasWidth * 0.65);</span><br><span class="line">        let radio = maxWidth / res.width;</span><br><span class="line"></span><br><span class="line">        let offsetY = (that.data.canvasHeight - res.height * radio) / 2;</span><br><span class="line">        console.log(&apos;offsetY=&apos; + offsetY);</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">          imageWidth: res.width * radio,</span><br><span class="line">          imageHeight: res.height * radio,</span><br><span class="line">          offsetY: offsetY,</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        // 绘制canvas背景，不属于绘制图片部分</span><br><span class="line">        ctx.setFillStyle(&apos;white&apos;)</span><br><span class="line">        ctx.fillRect(0, 0, that.data.canvasWidth, that.data.canvasHeight);</span><br><span class="line">        // 绘制武将图片，path是本地路径，不可以传网络url，如果是网络图片需要先下载</span><br><span class="line">        ctx.drawImage(path, 10, offsetY, res.width * radio, res.height * radio)</span><br><span class="line">        // 绘制小程序码</span><br><span class="line">        that.drawQrCodeImage(ctx);</span><br><span class="line">        // 绘制势力汉字：吴</span><br><span class="line">        that.drawInfluence(ctx, that.data.hero.HERO.INFLUENCE);</span><br><span class="line">        // 绘制武将姓名：陆逊</span><br><span class="line">        that.drawName(ctx, that.data.hero.HERO.NAME);</span><br><span class="line">        // 绘制武将称号：江陵侯</span><br><span class="line">        that.drawHorner(ctx, that.data.hero.HERO.HORNER);</span><br><span class="line">        // 最终调用draw函数，生成预览图</span><br><span class="line">        // 一个坑点：只能调用一次，否则后面的会覆盖前面的</span><br><span class="line">        ctx.draw();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="小程序码"><a href="#小程序码" class="headerlink" title="小程序码"></a>小程序码</h3><p>小程序码和武将图片是一个类型，无非就是需要计算绘制的位置，这里就不再展示相关代码了。</p><h3 id="武将文字信息"><a href="#武将文字信息" class="headerlink" title="武将文字信息"></a>武将文字信息</h3><p>从刚刚的代码可以看出，我分了3个部分来绘制，其实<code>吴</code>和<code>陆逊</code>应该是可以放到一起的，但是我在绘制的时候发现，空格在绘制的时候会引起异常，导致空格后面的文字无法绘制出来，所以我这里<code>吴</code>和<code>陆逊</code>中间的空白是靠位置偏移来做的。</p><p>这里就展示一下如何绘制武将称号的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 绘制武将称号：江陵侯</span><br><span class="line">drawHorner: function (ctx, text) &#123;</span><br><span class="line">// 设置字号</span><br><span class="line">    ctx.setFontSize(26);</span><br><span class="line">    // 设置字体颜色</span><br><span class="line">    ctx.setFillStyle(&quot;#000000&quot;);</span><br><span class="line">    // 计算绘制起点</span><br><span class="line">    let x = this.data.offsetX + 35;</span><br><span class="line">    let y = this.data.offsetY + 10;</span><br><span class="line">    console.log(&apos;drawHorner&apos; + text);</span><br><span class="line">    console.log(x);</span><br><span class="line">    console.log(y);</span><br><span class="line">    // 绘制竖排文字，这里是个Util函数，具体实现请继续看</span><br><span class="line">    Canvas.drawTextVertical(ctx, text, x, y);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>绘制竖排文字从网上找了个开源的代码，需要看原理的请看<a href="http://www.zhangxinxu.com/wordpress/?p=7362" target="_blank" rel="noopener">这里</a></p><p>当然我这里为了适用小程序做了些改动，函数原型是这样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CanvasRenderingContext2D.prototype.letterSpacingText = function (text, x, y, letterSpacing)</span><br></pre></td></tr></table></figure><p>原谅我不是很会<code>js</code>，完全不懂这是个什么语法，看了一会没弄懂，感觉像是给类添加新的属性，不管他。</p><blockquote><p>不管白猫黑猫，能抓到耗子就是好猫</p></blockquote><p>改造后的函数像下面的样子：</p><p><code>canvas.js</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @author zhangxinxu(.com)</span><br><span class="line">* @licence MIT</span><br><span class="line">* @description http://www.zhangxinxu.com/wordpress/?p=7362</span><br><span class="line">*/</span><br><span class="line">function drawTextVertical(context, text, x, y) &#123;</span><br><span class="line">  var arrText = text.split(&apos;&apos;);</span><br><span class="line">  var arrWidth = arrText.map(function (letter) &#123;</span><br><span class="line">    return 26;</span><br><span class="line">    // 这里为了找到那个空格的 bug 做了许多努力，不过似乎是白费力了</span><br><span class="line">    // const metrics = context.measureText(letter);</span><br><span class="line">    // console.log(metrics);</span><br><span class="line">    // const width = metrics.width;</span><br><span class="line">    // return width;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  var align = context.textAlign;</span><br><span class="line">  var baseline = context.textBaseline;</span><br><span class="line"></span><br><span class="line">  if (align == &apos;left&apos;) &#123;</span><br><span class="line">    x = x + Math.max.apply(null, arrWidth) / 2;</span><br><span class="line">  &#125; else if (align == &apos;right&apos;) &#123;</span><br><span class="line">    x = x - Math.max.apply(null, arrWidth) / 2;</span><br><span class="line">  &#125;</span><br><span class="line">  if (baseline == &apos;bottom&apos; || baseline == &apos;alphabetic&apos; || baseline == &apos;ideographic&apos;) &#123;</span><br><span class="line">    y = y - arrWidth[0] / 2;</span><br><span class="line">  &#125; else if (baseline == &apos;top&apos; || baseline == &apos;hanging&apos;) &#123;</span><br><span class="line">    y = y + arrWidth[0] / 2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  context.textAlign = &apos;center&apos;;</span><br><span class="line">  context.textBaseline = &apos;middle&apos;;</span><br><span class="line"></span><br><span class="line">  // 开始逐字绘制</span><br><span class="line">  arrText.forEach(function (letter, index) &#123;</span><br><span class="line">    // 确定下一个字符的纵坐标位置</span><br><span class="line">    var letterWidth = arrWidth[index];</span><br><span class="line">    // 是否需要旋转判断</span><br><span class="line">    var code = letter.charCodeAt(0);</span><br><span class="line">    if (code &lt;= 256) &#123;</span><br><span class="line">      context.translate(x, y);</span><br><span class="line">      // 英文字符，旋转90°</span><br><span class="line">      context.rotate(90 * Math.PI / 180);</span><br><span class="line">      context.translate(-x, -y);</span><br><span class="line">    &#125; else if (index &gt; 0 &amp;&amp; text.charCodeAt(index - 1) &lt; 256) &#123;</span><br><span class="line">      // y修正</span><br><span class="line">      y = y + arrWidth[index - 1] / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    context.fillText(letter, x, y);</span><br><span class="line">    // 旋转坐标系还原成初始态</span><br><span class="line">    context.setTransform(1, 0, 0, 1, 0, 0);</span><br><span class="line">    // 确定下一个字符的纵坐标位置</span><br><span class="line">    var letterWidth = arrWidth[index];</span><br><span class="line">    y = y + letterWidth;</span><br><span class="line">  &#125;);</span><br><span class="line">  // 水平垂直对齐方式还原</span><br><span class="line">  context.textAlign = align;</span><br><span class="line">  context.textBaseline = baseline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  drawTextVertical: drawTextVertical</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制网络图片"><a href="#绘制网络图片" class="headerlink" title="绘制网络图片"></a>绘制网络图片</h3><p>由于网络图片无法直接绘制，所以需要先下载到本地，然后再按住本地图片绘制的流程走一遍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">downloadHeroImage: function () &#123;</span><br><span class="line">    // 微信不支持非https的图片下载，这里了个替换</span><br><span class="line">    let url = this.data.hero.HERO.ICON.replace(/http/, &quot;https&quot;);</span><br><span class="line">    var that = this;</span><br><span class="line">    wx.downloadFile(&#123;</span><br><span class="line">      url: url,</span><br><span class="line">      success: function (res) &#123;</span><br><span class="line">        // 下载成功后拿到图片的路径，然后开始绘制</span><br><span class="line">        var path = res.tempFilePath;</span><br><span class="line">        that.drawHeroImage(path);</span><br><span class="line">      &#125;, fail: function (res) &#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h3><p>说了这么多，自然少不了最终的一步，将绘制到<code>canvas</code>的图片保存到手机相册，这里需要用户授权，你需要自己处理。</p><p>用的是微信给我们提供的接口<code>wx.canvasToTempFilePath</code>。需要我们传入起点坐标<code>(x, y)</code>和画布大小<code>(width, height)</code>以及<code>canvasId</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">saveShareImage: function () &#123;</span><br><span class="line">    wx.showLoading(&#123;</span><br><span class="line">      title: &apos;正在保存图片..&apos;,</span><br><span class="line">    &#125;);</span><br><span class="line">    let that = this;</span><br><span class="line">    wx.canvasToTempFilePath(&#123;</span><br><span class="line">      x: 0,</span><br><span class="line">      y: 0,</span><br><span class="line">      width: that.data.canvasWidth,</span><br><span class="line">      height: that.data.canvasHeight,</span><br><span class="line">      canvasId: &apos;share_canvas&apos;,</span><br><span class="line">      success: function (res) &#123;</span><br><span class="line">        wx.saveImageToPhotosAlbum(&#123;</span><br><span class="line">          filePath: res.tempFilePath,</span><br><span class="line">          success(res) &#123;</span><br><span class="line">            console.log(res);</span><br><span class="line">            wx.showToast(&#123;</span><br><span class="line">              title: &apos;保存到相册成功&apos;,</span><br><span class="line">              duration: 1500,</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;,</span><br><span class="line">          fail(res) &#123;</span><br><span class="line">            console.log(res)</span><br><span class="line">            wx.showToast(&#123;</span><br><span class="line">              title: &apos;保存到相册失败&apos;,</span><br><span class="line">              icon: &apos;fail&apos;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;,</span><br><span class="line">          complete(res) &#123;</span><br><span class="line">            console.log(res)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h1><p>本着开源的精神，源码已经放在<code>Github</code>上，大家可以去上面查看具体代码。</p><p><a href="https://github.com/HistoryZhang/SgsNoteBook" target="_blank" rel="noopener">https://github.com/HistoryZhang/SgsNoteBook</a></p><p>如果对你有帮助的话，麻烦给个<code>Star</code>吧~</p><p>点击阅读原文可以查看更好的代码格式~</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;闲暇时间抽个空写了个三国杀武将手册的小程序，中间有个需求设计的是合成武将皮肤图、竖排的武将姓名、以及小程序码，然后提供保存图片到相册，最终让用户可以分享到朋友圈或其他平台。合成图片应该按照&lt;code&gt;Canvas&lt;/code&gt;的文档来做都没什么问题，主要是有个竖排文字的需求，这里和大家分享一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="小程序, Canvas" scheme="http://bugdeveloper.gitee.io/blog/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F-Canvas/"/>
    
  </entry>
  
  <entry>
    <title>公众号推荐</title>
    <link href="http://bugdeveloper.gitee.io/blog/2018/02/07/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E8%8D%90/"/>
    <id>http://bugdeveloper.gitee.io/blog/2018/02/07/公众号推荐/</id>
    <published>2018-02-07T13:44:35.000Z</published>
    <updated>2018-02-07T13:51:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里技术"><a href="#阿里技术" class="headerlink" title="阿里技术"></a>阿里技术</h1><h4 id="公众号介绍"><a href="#公众号介绍" class="headerlink" title="公众号介绍"></a>公众号介绍</h4><blockquote><p>阿里巴巴官方技术号，关于阿里的技术创新均呈现于此。</p></blockquote><p>如官方介绍所说，会推送一些阿里用到的技术。也整理出一系列的 <code>pdf</code> 出来给大家。<br><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616ea1bbbd8bdc2?w=430&amp;h=430&amp;f=jpeg&amp;s=39741" alt=""></p><a id="more"></a><h1 id="美团点评技术团队"><a href="#美团点评技术团队" class="headerlink" title="美团点评技术团队"></a>美团点评技术团队</h1><h4 id="公众号介绍-1"><a href="#公众号介绍-1" class="headerlink" title="公众号介绍"></a>公众号介绍</h4><blockquote><p>这里是美团点评强大技术团队的对外窗口，每周腿送一线实践技术文章、技术活动、技术招聘信息。</p></blockquote><p>会覆盖前端、后端、算法等等，也会推送一些技术沙龙活动。该技术团队除了这个公众号另外还维护一个技术博客，<a href="https://tech.meituan.com/" target="_blank" rel="noopener">https://tech.meituan.com/</a>。<br><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616ea1cafd9a5c7?w=430&amp;h=430&amp;f=jpeg&amp;s=39760" alt=""></p><h1 id="淘宝技术"><a href="#淘宝技术" class="headerlink" title="淘宝技术"></a>淘宝技术</h1><h4 id="公众号介绍-2"><a href="#公众号介绍-2" class="headerlink" title="公众号介绍"></a>公众号介绍</h4><blockquote><p>淘宝技术官方账号。</p></blockquote><p>后端、前端、机器学习，总之淘宝用到的技术，都有机会在这里领略到。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616ea1d52f5ebf6?w=430&amp;h=430&amp;f=jpeg&amp;s=41296" alt=""></p><h1 id="WeMobileDev"><a href="#WeMobileDev" class="headerlink" title="WeMobileDev"></a>WeMobileDev</h1><h4 id="公众号介绍-3"><a href="#公众号介绍-3" class="headerlink" title="公众号介绍"></a>公众号介绍</h4><blockquote><p>微信移动客户端开发团队官号，分享微信在<code>Android</code>、<code>iOS</code>、<code>Mac</code>、<code>Winphone</code>、<code>Windows</code>等平台的开发经验、前沿技术，以及一些鲜为人知的小故事。</p></blockquote><p>因为<code>WCDB</code>关注的该公众号，介绍的皆是微信在开发过程中遇到的问题解决方案，还有开源框架介绍。<br><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616ea1dbf38cf88?w=430&amp;h=430&amp;f=jpeg&amp;s=39414" alt=""></p><h1 id="移动开发前线"><a href="#移动开发前线" class="headerlink" title="移动开发前线"></a>移动开发前线</h1><h4 id="公众号介绍-4"><a href="#公众号介绍-4" class="headerlink" title="公众号介绍"></a>公众号介绍</h4><blockquote><p>专注于分享移动开发前沿和一线技术。</p></blockquote><p>主要推送一些关于移动端和前端的一些精选文章，两端技术、RN等等。也会推送一些关于移动端的热点文章，<code>Kotlin</code>、<code>Swift</code>、小程序等等。<br><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616ea1e27c3f0a8?w=430&amp;h=430&amp;f=jpeg&amp;s=38830" alt=""></p><h1 id="聊聊架构"><a href="#聊聊架构" class="headerlink" title="聊聊架构"></a>聊聊架构</h1><h4 id="公众号介绍-5"><a href="#公众号介绍-5" class="headerlink" title="公众号介绍"></a>公众号介绍</h4><blockquote><p>以架构之“道”为基础，呈现更多务实落地的架构内容。</p></blockquote><p>主要推送一些关于架构设计的文章，包括前端后端，文章质量还是蛮高的。<br><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616ea133efd1e23?w=430&amp;h=430&amp;f=jpeg&amp;s=39973" alt=""></p><h1 id="云栖社区"><a href="#云栖社区" class="headerlink" title="云栖社区"></a>云栖社区</h1><h4 id="公众号介绍-6"><a href="#公众号介绍-6" class="headerlink" title="公众号介绍"></a>公众号介绍</h4><blockquote><p>云栖社区是由阿里云负责运营、阿里巴巴技术协会和阿里巴巴集团各技术团队提供内容支持的开放式技术社区。</p></blockquote><p>有时候会和几个阿里系的公众号发同样的文章，主要还是会发一些热点知识，人工智能、区块链、服务端架构等待。<br><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616ea1e9c536e8d?w=430&amp;h=430&amp;f=jpeg&amp;s=40049" alt=""></p><h1 id="InfoQ"><a href="#InfoQ" class="headerlink" title="InfoQ"></a>InfoQ</h1><h4 id="公众号介绍-7"><a href="#公众号介绍-7" class="headerlink" title="公众号介绍"></a>公众号介绍</h4><blockquote><p>有内容的技术社区媒体。</p></blockquote><p>在这里除了技术干货，还能学到如何定位自身。作为一个技术，你不仅需要掌握技术，还需要扩充横向知识面，为你的人生铺路。<br><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616ea1f4de4a960?w=430&amp;h=430&amp;f=jpeg&amp;s=39418" alt=""></p><h1 id="stromzhang"><a href="#stromzhang" class="headerlink" title="stromzhang"></a>stromzhang</h1><h4 id="公众号介绍-8"><a href="#公众号介绍-8" class="headerlink" title="公众号介绍"></a>公众号介绍</h4><blockquote><p>一名不羁的码农，我的世界不只有 <code>Coding</code>！</p></blockquote><p>最后推荐的是一个个人运营的公众号，刚开始是以为 <code>Android</code> 开发者，写一下关于 <code>Android</code> 开发的文章，后来会涉及一些管理的文章。现在已经没有限制了，包括广告，总的来说质量还可以吧。</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/7/1616ea1f9e6e7e17?w=430&amp;h=430&amp;f=jpeg&amp;s=39479" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阿里技术&quot;&gt;&lt;a href=&quot;#阿里技术&quot; class=&quot;headerlink&quot; title=&quot;阿里技术&quot;&gt;&lt;/a&gt;阿里技术&lt;/h1&gt;&lt;h4 id=&quot;公众号介绍&quot;&gt;&lt;a href=&quot;#公众号介绍&quot; class=&quot;headerlink&quot; title=&quot;公众号介绍&quot;&gt;&lt;/a&gt;公众号介绍&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;阿里巴巴官方技术号，关于阿里的技术创新均呈现于此。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如官方介绍所说，会推送一些阿里用到的技术。也整理出一系列的 &lt;code&gt;pdf&lt;/code&gt; 出来给大家。&lt;br&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/2/7/1616ea1bbbd8bdc2?w=430&amp;amp;h=430&amp;amp;f=jpeg&amp;amp;s=39741&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://bugdeveloper.gitee.io/blog/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="公众号" scheme="http://bugdeveloper.gitee.io/blog/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Swift关于!和?的Tip</title>
    <link href="http://bugdeveloper.gitee.io/blog/2018/02/06/Swift%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%8C%85%E7%9A%84Tip/"/>
    <id>http://bugdeveloper.gitee.io/blog/2018/02/06/Swift关于解包的Tip/</id>
    <published>2018-02-06T13:45:07.000Z</published>
    <updated>2018-02-06T14:00:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Q: 为什么我现在还在写这些入门级别的语法 <code>Tip</code> 呢？</p><p>A: 因为我现在才开始学习 <code>Swift</code> 呗~</p><p>Q: 为什么我现在才开始学习 <code>Swift</code> 呢？</p><p>A: 因为懒呗~</p></blockquote><a id="more"></a><p>哈哈~分享一些自己看到的小 <code>Tip</code> 给大家，让那些也才入门 <code>Swift</code> 的童鞋也能多了解一些~</p><h2 id="关于-和"><a href="#关于-和" class="headerlink" title="关于 ! 和 ?"></a>关于 <code>!</code> 和 <code>?</code></h2><p>今天这里不打算介绍为什么 <code>Swift</code> 里面会有 <code>!</code> 和 <code>?</code>，有什么不明白的可以看看这里：<a href="https://www.jianshu.com/p/89a2afb82488" target="_blank" rel="noopener">Swift中 ！和 ？的区别及使用</a></p><p>现在我们看一个平时用到的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let width: Int? = 3</span><br><span class="line">var area: Int?</span><br><span class="line">    </span><br><span class="line">area = width! * width!</span><br></pre></td></tr></table></figure><p>为什么这里 <code>let area = width! * width!</code> 会有这么多的 <code>!</code> 呢？因为机（愚）智（蠢）的 <code>Xcode</code> 建议我们这样写。最关键的是如果 <code>width</code> 真的就是 <code>nil</code> 会这么样呢？机智如你，会 <code>Crash</code>。</p><p>那保险一点的写法应该是这样子的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let width: Int? = 3</span><br><span class="line">var area: Int?</span><br><span class="line"></span><br><span class="line">if let tmp = width &#123;</span><br><span class="line">    area = tmp * tmp</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    area = nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完全不符合 <code>Swift</code> 作为一门<code>优雅</code>的语言的称号。</p><h2 id="Optional-Map"><a href="#Optional-Map" class="headerlink" title="Optional Map"></a>Optional Map</h2><p>面对上面的问题，有个很优雅的写法，那就是 <code>Optional Map</code>。让我们先看一下 <code>Optional</code> 中关于 <code>map</code> 的声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral &#123;</span><br><span class="line">    public func map&lt;U&gt;(_ transform: (Wrapped) throws -&gt; U) rethrows -&gt; U?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的作用是，如果输入有值，则进入 <code>transform</code> 的闭包进行变化，并返回一个 <code>U?</code> ;如果输入就是 <code>nil</code> 的话，则直接返回 <code>nil</code> 的 <code>U?</code>。</p><p>那么我们就有如下优雅的写法了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let width: Int? = 3</span><br><span class="line">let area = width.map &#123;</span><br><span class="line">    $0 * $0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>我们还能在 <code>Collection</code> 中看到 <code>map</code> 的身影。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">extension Collection &#123;</span><br><span class="line"></span><br><span class="line">    /// Returns an array containing the results of mapping the given closure</span><br><span class="line">    /// over the sequence&apos;s elements.</span><br><span class="line">    ///</span><br><span class="line">    /// In this example, `map` is used first to convert the names in the array</span><br><span class="line">    /// to lowercase strings and then to count their characters.</span><br><span class="line">    ///</span><br><span class="line">    ///     let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;]</span><br><span class="line">    ///     let lowercaseNames = cast.map &#123; $0.lowercaseString &#125;</span><br><span class="line">    ///     // &apos;lowercaseNames&apos; == [&quot;vivien&quot;, &quot;marlon&quot;, &quot;kim&quot;, &quot;karl&quot;]</span><br><span class="line">    ///     let letterCounts = cast.map &#123; $0.count &#125;</span><br><span class="line">    ///     // &apos;letterCounts&apos; == [6, 6, 3, 4]</span><br><span class="line">    ///</span><br><span class="line">    /// - Parameter transform: A mapping closure. `transform` accepts an</span><br><span class="line">    ///   element of this sequence as its parameter and returns a transformed</span><br><span class="line">    ///   value of the same or of a different type.</span><br><span class="line">    /// - Returns: An array containing the transformed elements of this</span><br><span class="line">    ///   sequence.</span><br><span class="line">    public func map&lt;T&gt;(_ transform: (Self.Element) throws -&gt; T) rethrows -&gt; [T]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释的很清楚了，就不多介绍了。值得注意的是 <code>Collection</code> 本身是一个 <code>protocol</code>，所以所有实现了 <code>Collection</code> 协议的都有这个方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Q: 为什么我现在还在写这些入门级别的语法 &lt;code&gt;Tip&lt;/code&gt; 呢？&lt;/p&gt;
&lt;p&gt;A: 因为我现在才开始学习 &lt;code&gt;Swift&lt;/code&gt; 呗~&lt;/p&gt;
&lt;p&gt;Q: 为什么我现在才开始学习 &lt;code&gt;Swift&lt;/code&gt; 呢？&lt;/p&gt;
&lt;p&gt;A: 因为懒呗~&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://bugdeveloper.gitee.io/blog/categories/iOS/"/>
    
    
      <category term="Swift" scheme="http://bugdeveloper.gitee.io/blog/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Github源码索引</title>
    <link href="http://bugdeveloper.gitee.io/blog/2018/01/27/Github%E6%BA%90%E7%A0%81%E7%B4%A2%E5%BC%95/"/>
    <id>http://bugdeveloper.gitee.io/blog/2018/01/27/Github源码索引/</id>
    <published>2018-01-27T06:12:05.000Z</published>
    <updated>2018-02-03T07:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、UI相关"><a href="#一、UI相关" class="headerlink" title="一、UI相关"></a>一、<code>UI</code>相关</h2><ul><li><a href="https://github.com/Daltron/NotificationBanner" target="_blank" rel="noopener">NotificationBanner</a> <code>通知栏提醒</code></li><li><a href="https://github.com/zhangao0086/DKImagePickerController" target="_blank" rel="noopener"><code>DKImagePickerController</code></a> <a id="more"></a>系统相册</li><li><a href="https://github.com/SwipeCellKit/SwipeCellKit" target="_blank" rel="noopener">SwipeCellKit</a> <code>系统邮箱手势的Cell</code></li><li><a href="https://github.com/jonathantribouharet/JTCalendar" target="_blank" rel="noopener">JTCalendar</a> <code>日历</code></li><li><a href="https://github.com/CVCalendar/CVCalendar" target="_blank" rel="noopener">CVCalendar</a> <code>日历</code></li><li><a href="https://github.com/xmartlabs/XLForm" target="_blank" rel="noopener">XLForm</a> <code>表单系统</code></li><li><a href="https://github.com/xmartlabs/Eureka" target="_blank" rel="noopener">Eureka</a> <code>表单系统</code><h2 id="二、Extension"><a href="#二、Extension" class="headerlink" title="二、Extension"></a>二、<code>Extension</code></h2></li><li><a href="https://github.com/SwifterSwift/SwifterSwift" target="_blank" rel="noopener">SwifterSwift</a><h2 id="三、工具"><a href="#三、工具" class="headerlink" title="三、工具"></a>三、工具</h2></li><li><a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="noopener">SwiftyJSON</a> <code>JSON转Model</code><h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2></li><li><a href="https://github.com/byoungd/English-level-up-tips-for-Chinese" target="_blank" rel="noopener">英语进阶指南</a></li><li><a href="https://github.com/fancymax/12306ForMac" target="_blank" rel="noopener">12306ForMac</a> <code>12306 订票/捡票 助手</code></li><li><a href="https://github.com/wangshub/wechat_jump_game" target="_blank" rel="noopener"><code>跳一跳</code>辅助</a></li><li><a href="https://github.com/rrdssfgcs/wenda-helper" target="_blank" rel="noopener"><code>答题App辅助</code></a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、UI相关&quot;&gt;&lt;a href=&quot;#一、UI相关&quot; class=&quot;headerlink&quot; title=&quot;一、UI相关&quot;&gt;&lt;/a&gt;一、&lt;code&gt;UI&lt;/code&gt;相关&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Daltron/NotificationBanner&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NotificationBanner&lt;/a&gt; &lt;code&gt;通知栏提醒&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zhangao0086/DKImagePickerController&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;DKImagePickerController&lt;/code&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="源码" scheme="http://bugdeveloper.gitee.io/blog/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Github" scheme="http://bugdeveloper.gitee.io/blog/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Github源码推荐(1.22~1.28)</title>
    <link href="http://bugdeveloper.gitee.io/blog/2018/01/27/Github%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90(1.22-1.28)/"/>
    <id>http://bugdeveloper.gitee.io/blog/2018/01/27/Github源码推荐(1.22-1.28)/</id>
    <published>2018-01-27T04:39:11.000Z</published>
    <updated>2018-02-03T07:50:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>除了推荐一些源码，如果遇到其他相关我也会推荐给大家，排名来自于心情。</p><h2 id="一、英语进阶指南"><a href="#一、英语进阶指南" class="headerlink" title="一、英语进阶指南"></a>一、英语进阶指南</h2><p>夫人最近也在学习英语，不知道这个对她是否有用呢？</p><blockquote><p>英语作为一门语言，学习起来应该是一件比较自然而然的事情，就像我们自然而然地学会汉语那样。</p></blockquote><a id="more"></a><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><img src="/images/blog/Feature.png"><img src="/images/blog/How.png"><h3 id="热度"><a href="#热度" class="headerlink" title="热度"></a>热度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Star: 7800+</span><br></pre></td></tr></table></figure><h3 id="Github主页"><a href="#Github主页" class="headerlink" title="Github主页"></a><code>Github</code>主页</h3><p><a href="https://github.com/byoungd/English-level-up-tips-for-Chinese" target="_blank" rel="noopener">https://github.com/byoungd/English-level-up-tips-for-Chinese</a></p><h2 id="二、春节即将来临，是否有小伙伴再开始抢票了呢？如果你使用的是Mac系统，那就试试这个吧，专为Mac-OS打造的12306-订票-捡票-助手。"><a href="#二、春节即将来临，是否有小伙伴再开始抢票了呢？如果你使用的是Mac系统，那就试试这个吧，专为Mac-OS打造的12306-订票-捡票-助手。" class="headerlink" title="二、春节即将来临，是否有小伙伴再开始抢票了呢？如果你使用的是Mac系统，那就试试这个吧，专为Mac OS打造的12306 订票/捡票 助手。"></a>二、春节即将来临，是否有小伙伴再开始抢票了呢？如果你使用的是<code>Mac</code>系统，那就试试这个吧，专为<code>Mac OS</code>打造的<code>12306 订票/捡票 助手</code>。</h2><h3 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h3><img src="/images/blog/12306ForMac.jpg"><h3 id="热度-1"><a href="#热度-1" class="headerlink" title="热度"></a>热度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Star: 2000+</span><br></pre></td></tr></table></figure><h3 id="Github主页-1"><a href="#Github主页-1" class="headerlink" title="Github主页"></a><code>Github</code>主页</h3><p><a href="https://github.com/fancymax/12306ForMac" target="_blank" rel="noopener">https://github.com/fancymax/12306ForMac</a></p><h2 id="三、习惯了OC下的YYModel等Dictionary转Model工具，在Swift下是否不适应呢？试试SwiftyJSON吧，一定会为你带来更好的体验。"><a href="#三、习惯了OC下的YYModel等Dictionary转Model工具，在Swift下是否不适应呢？试试SwiftyJSON吧，一定会为你带来更好的体验。" class="headerlink" title="三、习惯了OC下的YYModel等Dictionary转Model工具，在Swift下是否不适应呢？试试SwiftyJSON吧，一定会为你带来更好的体验。"></a>三、习惯了<code>OC</code>下的<code>YYModel</code>等<code>Dictionary</code>转<code>Model</code>工具，在<code>Swift</code>下是否不适应呢？试试<code>SwiftyJSON</code>吧，一定会为你带来更好的体验。</h2><h3 id="热度-2"><a href="#热度-2" class="headerlink" title="热度"></a>热度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Star: 16000+</span><br></pre></td></tr></table></figure><h3 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;SwiftyJSON&apos;</span><br></pre></td></tr></table></figure><h3 id="Carthage"><a href="#Carthage" class="headerlink" title="Carthage"></a>Carthage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github &quot;SwiftyJSON/SwiftyJSON&quot;</span><br></pre></td></tr></table></figure><h3 id="Github主页-2"><a href="#Github主页-2" class="headerlink" title="Github主页"></a><code>Github</code>主页</h3><p><a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="noopener">https://github.com/SwiftyJSON/SwiftyJSON</a></p><h2 id="四、是否厌倦了Toast一成不变的样式呢？你可以试试NotificationBanner，漂亮的动画样式，新颖的交互体验。"><a href="#四、是否厌倦了Toast一成不变的样式呢？你可以试试NotificationBanner，漂亮的动画样式，新颖的交互体验。" class="headerlink" title="四、是否厌倦了Toast一成不变的样式呢？你可以试试NotificationBanner，漂亮的动画样式，新颖的交互体验。"></a>四、是否厌倦了<code>Toast</code>一成不变的样式呢？你可以试试<code>NotificationBanner</code>，漂亮的动画样式，新颖的交互体验。</h2><h3 id="效果图-2"><a href="#效果图-2" class="headerlink" title="效果图"></a>效果图</h3><img src="/images/blog/NotificationBanner-1.gif"><img src="/images/blog/NotificationBanner-2.gif"><img src="/images/blog/NotificationBanner-3.gif"><h3 id="热度-3"><a href="#热度-3" class="headerlink" title="热度"></a>热度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Star: 1700+</span><br></pre></td></tr></table></figure><h3 id="CocoaPods-1"><a href="#CocoaPods-1" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;NotificationBannerSwift&apos;</span><br></pre></td></tr></table></figure><h3 id="Carthage-1"><a href="#Carthage-1" class="headerlink" title="Carthage"></a>Carthage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github &quot;Daltron/NotificationBanner&quot; &quot;master&quot;</span><br></pre></td></tr></table></figure><h3 id="Github主页-3"><a href="#Github主页-3" class="headerlink" title="Github主页"></a><code>Github</code>主页</h3><p><a href="https://github.com/Daltron/NotificationBanner" target="_blank" rel="noopener">https://github.com/Daltron/NotificationBanner</a></p><p>好了，暂时就推荐这么多给大家，下周我们再见。</p><p>PS：本文中图片部分皆来自于作者<code>Github</code>主页，如有侵权，请告知。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;除了推荐一些源码，如果遇到其他相关我也会推荐给大家，排名来自于心情。&lt;/p&gt;
&lt;h2 id=&quot;一、英语进阶指南&quot;&gt;&lt;a href=&quot;#一、英语进阶指南&quot; class=&quot;headerlink&quot; title=&quot;一、英语进阶指南&quot;&gt;&lt;/a&gt;一、英语进阶指南&lt;/h2&gt;&lt;p&gt;夫人最近也在学习英语，不知道这个对她是否有用呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;英语作为一门语言，学习起来应该是一件比较自然而然的事情，就像我们自然而然地学会汉语那样。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="源码" scheme="http://bugdeveloper.gitee.io/blog/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Github" scheme="http://bugdeveloper.gitee.io/blog/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Github源码推荐(1.15~1.21)</title>
    <link href="http://bugdeveloper.gitee.io/blog/2018/01/21/Github%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90(1.15~1.21)/"/>
    <id>http://bugdeveloper.gitee.io/blog/2018/01/21/Github源码推荐(1.15~1.21)/</id>
    <published>2018-01-21T03:21:06.000Z</published>
    <updated>2018-02-03T07:50:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，一周时间过得真快，本次主题依旧，推荐一些<code>Github</code>上的源码，排名不分先后。</p><h2 id="一、答题App莫名的火了起来，随之而来的则是一系列的辅助软件，例如搜狗、百度，先后推出辅助答题助手。这档子事自然少不了广大程序员Show一把的场面，下面推荐的就是使用OCR做的辅助答题助手。"><a href="#一、答题App莫名的火了起来，随之而来的则是一系列的辅助软件，例如搜狗、百度，先后推出辅助答题助手。这档子事自然少不了广大程序员Show一把的场面，下面推荐的就是使用OCR做的辅助答题助手。" class="headerlink" title="一、答题App莫名的火了起来，随之而来的则是一系列的辅助软件，例如搜狗、百度，先后推出辅助答题助手。这档子事自然少不了广大程序员Show一把的场面，下面推荐的就是使用OCR做的辅助答题助手。"></a>一、答题<code>App</code>莫名的火了起来，随之而来的则是一系列的辅助软件，例如搜狗、百度，先后推出辅助答题助手。这档子事自然少不了广大程序员<code>Show</code>一把的场面，下面推荐的就是使用<code>OCR</code>做的辅助答题助手。</h2><blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>使用手机模拟器，快速识别~</li><li>浏览器自动搜索显示结果，搜索引擎可配置，结果一目了然~</li><li>模拟器还能多开哦~全部答对奖金翻倍，遇到不会的可以多选乱蒙</li><li>万英雄/知识超人/冲顶大会都支持哦~</li></ul></blockquote><a id="more"></a><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><img src="/images/blog/wenda-helper.gif"><h3 id="热度"><a href="#热度" class="headerlink" title="热度"></a>热度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Star: 800+</span><br></pre></td></tr></table></figure><h3 id="Github主页"><a href="#Github主页" class="headerlink" title="Github主页"></a><code>Github</code>主页</h3><p><a href="https://github.com/rrdssfgcs/wenda-helper" target="_blank" rel="noopener">https://github.com/rrdssfgcs/wenda-helper</a></p><h2 id="二、上一周给大家推荐了一个Objective-C的日历，这次给大家推荐一个Swift4的日历控件，作者写的非常好棒，支持Storyboard。"><a href="#二、上一周给大家推荐了一个Objective-C的日历，这次给大家推荐一个Swift4的日历控件，作者写的非常好棒，支持Storyboard。" class="headerlink" title="二、上一周给大家推荐了一个Objective-C的日历，这次给大家推荐一个Swift4的日历控件，作者写的非常好棒，支持Storyboard。"></a>二、上一周给大家推荐了一个<code>Objective-C</code>的日历，这次给大家推荐一个<code>Swift4</code>的日历控件，作者写的非常好棒，支持<code>Storyboard</code>。</h2><h3 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h3><img src="/images/blog/CVCalendar.gif"><h3 id="热度-1"><a href="#热度-1" class="headerlink" title="热度"></a>热度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Star: 2800+</span><br></pre></td></tr></table></figure><h3 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;CVCalendar&apos;, &apos;~&gt; 1.6.0&apos;</span><br></pre></td></tr></table></figure><h3 id="Github主页-1"><a href="#Github主页-1" class="headerlink" title="Github主页"></a><code>Github</code>主页</h3><p><a href="https://github.com/CVCalendar/CVCalendar" target="_blank" rel="noopener">https://github.com/CVCalendar/CVCalendar</a></p><h2 id="三、使用Swift的时候是不是需要写好多的Extension呢？使用这个开源库后就再也不用劳心劳力的写很多的Extension了。"><a href="#三、使用Swift的时候是不是需要写好多的Extension呢？使用这个开源库后就再也不用劳心劳力的写很多的Extension了。" class="headerlink" title="三、使用Swift的时候是不是需要写好多的Extension呢？使用这个开源库后就再也不用劳心劳力的写很多的Extension了。"></a>三、使用<code>Swift</code>的时候是不是需要写好多的<code>Extension</code>呢？使用这个开源库后就再也不用劳心劳力的写很多的<code>Extension</code>了。</h2><blockquote><p>SwifterSwift is a collection of over 500 native Swift extensions, with handy methods, syntactic sugar, and performance improvements for wide range of primitive data types, UIKit and Cocoa classes –over 500 in 1– for iOS, macOS, tvOS and watchOS.</p></blockquote><p>简直不要太强大，而且支持<code>Swift4</code>。</p><h3 id="热度-2"><a href="#热度-2" class="headerlink" title="热度"></a>热度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Star: 4200+</span><br></pre></td></tr></table></figure><h3 id="CocoaPods-1"><a href="#CocoaPods-1" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;SwifterSwift&apos;</span><br></pre></td></tr></table></figure><p>你也可以只集成部分<code>Extension</code>，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;SwifterSwift/Foundation&apos;</span><br></pre></td></tr></table></figure></p><p>具体还是去作者主页看吧。</p><h3 id="Carthage"><a href="#Carthage" class="headerlink" title="Carthage"></a>Carthage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github &quot;SwifterSwift/SwifterSwift&quot; ~&gt; 4.0</span><br></pre></td></tr></table></figure><h3 id="Github主页-2"><a href="#Github主页-2" class="headerlink" title="Github主页"></a><code>Github</code>主页</h3><p><a href="https://github.com/SwifterSwift/SwifterSwift" target="_blank" rel="noopener">https://github.com/SwifterSwift/SwifterSwift</a></p><h2 id="四、基本上所有的App都逃脱不了表单，设置、用户界面等待，都是一些枯燥无味的代码，却又要花费时间、精力去自定义每个Cell达到各式各样的效果，此次为大家推荐一个强大的表单开源库，最重要的是OC和Swift都有，各取所需。"><a href="#四、基本上所有的App都逃脱不了表单，设置、用户界面等待，都是一些枯燥无味的代码，却又要花费时间、精力去自定义每个Cell达到各式各样的效果，此次为大家推荐一个强大的表单开源库，最重要的是OC和Swift都有，各取所需。" class="headerlink" title="四、基本上所有的App都逃脱不了表单，设置、用户界面等待，都是一些枯燥无味的代码，却又要花费时间、精力去自定义每个Cell达到各式各样的效果，此次为大家推荐一个强大的表单开源库，最重要的是OC和Swift都有，各取所需。"></a>四、基本上所有的<code>App</code>都逃脱不了表单，设置、用户界面等待，都是一些枯燥无味的代码，却又要花费时间、精力去自定义每个<code>Cell</code>达到各式各样的效果，此次为大家推荐一个强大的表单开源库，最重要的是<code>OC</code>和<code>Swift</code>都有，各取所需。</h2><ul><li><code>OC</code>版</li></ul><h3 id="效果图-2"><a href="#效果图-2" class="headerlink" title="效果图"></a>效果图</h3><img src="/images/blog/XLForm.gif"><h3 id="热度-3"><a href="#热度-3" class="headerlink" title="热度"></a>热度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Star: 4800+</span><br></pre></td></tr></table></figure><h3 id="CocoaPods-2"><a href="#CocoaPods-2" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;XLForm&apos;, &apos;~&gt; 4.0&apos;</span><br></pre></td></tr></table></figure><h3 id="Carthage-1"><a href="#Carthage-1" class="headerlink" title="Carthage"></a>Carthage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github &quot;xmartlabs/XLForm&quot; ~&gt; 4.0</span><br></pre></td></tr></table></figure><h3 id="Github主页-3"><a href="#Github主页-3" class="headerlink" title="Github主页"></a><code>Github</code>主页</h3><p><a href="https://github.com/xmartlabs/XLForm" target="_blank" rel="noopener">https://github.com/xmartlabs/XLForm</a></p><ul><li><code>Swift</code>版</li></ul><h3 id="效果图-3"><a href="#效果图-3" class="headerlink" title="效果图"></a>效果图</h3><img src="/images/blog/Eureka-1.gif"><h3 id="热度-4"><a href="#热度-4" class="headerlink" title="热度"></a>热度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Star: 7500+</span><br></pre></td></tr></table></figure><h3 id="CocoaPods-3"><a href="#CocoaPods-3" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;Eureka&apos;</span><br></pre></td></tr></table></figure><h3 id="Carthage-2"><a href="#Carthage-2" class="headerlink" title="Carthage"></a>Carthage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github &quot;xmartlabs/Eureka&quot; ~&gt; 4.0</span><br></pre></td></tr></table></figure><h3 id="Github主页-4"><a href="#Github主页-4" class="headerlink" title="Github主页"></a><code>Github</code>主页</h3><p><a href="https://github.com/xmartlabs/Eureka" target="_blank" rel="noopener">https://github.com/xmartlabs/Eureka</a></p><p>关于使用方法这里就不再介绍了，项目主页上介绍的非常清楚，有需求的小伙伴就自己去查看吧~</p><p>好了，暂时就推荐这么多给大家，下周我们再见。</p><p>PS：本文中图片部分皆来自于作者<code>Github</code>主页，如有侵权，请告知。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家好，一周时间过得真快，本次主题依旧，推荐一些&lt;code&gt;Github&lt;/code&gt;上的源码，排名不分先后。&lt;/p&gt;
&lt;h2 id=&quot;一、答题App莫名的火了起来，随之而来的则是一系列的辅助软件，例如搜狗、百度，先后推出辅助答题助手。这档子事自然少不了广大程序员Show一把的场面，下面推荐的就是使用OCR做的辅助答题助手。&quot;&gt;&lt;a href=&quot;#一、答题App莫名的火了起来，随之而来的则是一系列的辅助软件，例如搜狗、百度，先后推出辅助答题助手。这档子事自然少不了广大程序员Show一把的场面，下面推荐的就是使用OCR做的辅助答题助手。&quot; class=&quot;headerlink&quot; title=&quot;一、答题App莫名的火了起来，随之而来的则是一系列的辅助软件，例如搜狗、百度，先后推出辅助答题助手。这档子事自然少不了广大程序员Show一把的场面，下面推荐的就是使用OCR做的辅助答题助手。&quot;&gt;&lt;/a&gt;一、答题&lt;code&gt;App&lt;/code&gt;莫名的火了起来，随之而来的则是一系列的辅助软件，例如搜狗、百度，先后推出辅助答题助手。这档子事自然少不了广大程序员&lt;code&gt;Show&lt;/code&gt;一把的场面，下面推荐的就是使用&lt;code&gt;OCR&lt;/code&gt;做的辅助答题助手。&lt;/h2&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用手机模拟器，快速识别~&lt;/li&gt;
&lt;li&gt;浏览器自动搜索显示结果，搜索引擎可配置，结果一目了然~&lt;/li&gt;
&lt;li&gt;模拟器还能多开哦~全部答对奖金翻倍，遇到不会的可以多选乱蒙&lt;/li&gt;
&lt;li&gt;万英雄/知识超人/冲顶大会都支持哦~&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="源码" scheme="http://bugdeveloper.gitee.io/blog/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Github" scheme="http://bugdeveloper.gitee.io/blog/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Github源码推荐(1.8~1.14)</title>
    <link href="http://bugdeveloper.gitee.io/blog/2018/01/14/Github%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90(1.8~1.14)/"/>
    <id>http://bugdeveloper.gitee.io/blog/2018/01/14/Github源码推荐(1.8~1.14)/</id>
    <published>2018-01-14T14:22:30.000Z</published>
    <updated>2018-02-03T07:50:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>本次给大家推荐一些<code>Github</code>上的源码，排名不分先后。</p><h2 id="一、微信小游戏的推出，自然而然是火爆了一把。但是一切都阻止不了程序员，自然是要破解一番的，本次首推的就是利用Python开发的跳一跳辅助。"><a href="#一、微信小游戏的推出，自然而然是火爆了一把。但是一切都阻止不了程序员，自然是要破解一番的，本次首推的就是利用Python开发的跳一跳辅助。" class="headerlink" title="一、微信小游戏的推出，自然而然是火爆了一把。但是一切都阻止不了程序员，自然是要破解一番的，本次首推的就是利用Python开发的跳一跳辅助。"></a>一、微信小游戏的推出，自然而然是火爆了一把。但是一切都阻止不了程序员，自然是要破解一番的，本次首推的就是利用<code>Python</code>开发的<code>跳一跳</code>辅助。</h2><h3 id="原理说明-摘自作者原文"><a href="#原理说明-摘自作者原文" class="headerlink" title="原理说明(摘自作者原文)"></a>原理说明(摘自作者原文)</h3><ol><li><p>将手机点击到《跳一跳》小程序界面</p></li><li><p>用 ADB 工具获取当前手机截图，并用 ADB 将截图 pull 上来</p></li><li><p>计算按压时间</p><ul><li>手动版：用 Matplotlib 显示截图，用鼠标先点击起始点位置，然后点击目标位置，计算像素距离；</li><li>自动版：靠棋子的颜色来识别棋子，靠底色和方块的色差来识别棋盘；</li></ul></li><li><p>用 ADB 工具点击屏幕蓄力一跳</p></li></ol><a id="more"></a><h3 id="热度"><a href="#热度" class="headerlink" title="热度"></a>热度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Star: 11800+</span><br></pre></td></tr></table></figure><h3 id="Github主页"><a href="#Github主页" class="headerlink" title="Github主页"></a><code>Github</code>主页</h3><p><a href="https://github.com/wangshub/wechat_jump_game" target="_blank" rel="noopener">https://github.com/wangshub/wechat_jump_game</a> </p><h2 id="二、是否觉得系统的相册太不方便，而自定义又太耗费时间，那就试试DKImagePickerController吧，作者完全使用Swift编写，支持CocoaPods。"><a href="#二、是否觉得系统的相册太不方便，而自定义又太耗费时间，那就试试DKImagePickerController吧，作者完全使用Swift编写，支持CocoaPods。" class="headerlink" title="二、是否觉得系统的相册太不方便，而自定义又太耗费时间，那就试试DKImagePickerController吧，作者完全使用Swift编写，支持CocoaPods。"></a>二、是否觉得系统的相册太不方便，而自定义又太耗费时间，那就试试<code>DKImagePickerController</code>吧，作者完全使用<code>Swift</code>编写，支持<code>CocoaPods</code>。</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><img src="/images/blog/DKImagePickerController-1.png"><img src="/images/blog/DKImagePickerController-2.png"><h3 id="热度-1"><a href="#热度-1" class="headerlink" title="热度"></a>热度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Star: 890+</span><br></pre></td></tr></table></figure><h3 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;DKImagePickerController&apos;</span><br></pre></td></tr></table></figure><h3 id="Github主页-1"><a href="#Github主页-1" class="headerlink" title="Github主页"></a><code>Github</code>主页</h3><p><a href="https://github.com/zhangao0086/DKImagePickerController" target="_blank" rel="noopener">https://github.com/zhangao0086/DKImagePickerController</a> </p><h2 id="三、系统邮箱中的交互让很多人大爱，尤其是列表的左右滑动手势，Github上有很多人都开源了自己的模仿源码，本次推荐的也是一个使用纯Swift编写的源码。"><a href="#三、系统邮箱中的交互让很多人大爱，尤其是列表的左右滑动手势，Github上有很多人都开源了自己的模仿源码，本次推荐的也是一个使用纯Swift编写的源码。" class="headerlink" title="三、系统邮箱中的交互让很多人大爱，尤其是列表的左右滑动手势，Github上有很多人都开源了自己的模仿源码，本次推荐的也是一个使用纯Swift编写的源码。"></a>三、系统邮箱中的交互让很多人大爱，尤其是列表的左右滑动手势，<code>Github</code>上有很多人都开源了自己的模仿源码，本次推荐的也是一个使用纯<code>Swift</code>编写的源码。</h2><h3 id="效果图-1"><a href="#效果图-1" class="headerlink" title="效果图"></a>效果图</h3><img src="/images/blog/SwipeCellKit.gif"><h3 id="热度-2"><a href="#热度-2" class="headerlink" title="热度"></a>热度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Star: 2700+</span><br></pre></td></tr></table></figure><h3 id="CocoaPods-1"><a href="#CocoaPods-1" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;SwipeCellKit&apos;</span><br></pre></td></tr></table></figure><h3 id="Carthage"><a href="#Carthage" class="headerlink" title="Carthage"></a>Carthage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github &quot;SwipeCellKit/SwipeCellKit&quot;</span><br></pre></td></tr></table></figure><h3 id="Github主页-2"><a href="#Github主页-2" class="headerlink" title="Github主页"></a><code>Github</code>主页</h3><p><a href="https://github.com/SwipeCellKit/SwipeCellKit" target="_blank" rel="noopener">https://github.com/SwipeCellKit/SwipeCellKit</a></p><h2 id="四、相信很多人都有编写日历的需求，在Todo，万年历等中，都需要日历，本次为大家推荐一个Objective-C编写的日历，支持横向和纵向滚动，支持切换月视图和周视图，支持Localization。"><a href="#四、相信很多人都有编写日历的需求，在Todo，万年历等中，都需要日历，本次为大家推荐一个Objective-C编写的日历，支持横向和纵向滚动，支持切换月视图和周视图，支持Localization。" class="headerlink" title="四、相信很多人都有编写日历的需求，在Todo，万年历等中，都需要日历，本次为大家推荐一个Objective-C编写的日历，支持横向和纵向滚动，支持切换月视图和周视图，支持Localization。"></a>四、相信很多人都有编写日历的需求，在<code>Todo</code>，万年历等中，都需要日历，本次为大家推荐一个<code>Objective-C</code>编写的日历，支持横向和纵向滚动，支持切换月视图和周视图，支持<code>Localization</code>。</h2><h3 id="效果图-2"><a href="#效果图-2" class="headerlink" title="效果图"></a>效果图</h3><img src="/images/blog/JTCalendar.gif"><img src="/images/blog/JTCalendar-2.png"><h3 id="热度-3"><a href="#热度-3" class="headerlink" title="热度"></a>热度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Star: 2400+</span><br></pre></td></tr></table></figure><h3 id="CocoaPods-2"><a href="#CocoaPods-2" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;JTCalendar&apos;, &apos;~&gt; 2.0&apos;</span><br></pre></td></tr></table></figure><h3 id="Carthage-1"><a href="#Carthage-1" class="headerlink" title="Carthage"></a>Carthage</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">github &quot;jonathantribouharet/JTCalendar&quot; ~&gt; 2.2</span><br></pre></td></tr></table></figure><h3 id="Github主页-3"><a href="#Github主页-3" class="headerlink" title="Github主页"></a><code>Github</code>主页</h3><p><a href="https://github.com/jonathantribouharet/JTCalendar" target="_blank" rel="noopener">https://github.com/jonathantribouharet/JTCalendar</a></p><p>好了，暂时就推荐这么多给大家，下周我们再见。</p><p>PS：本文中图片部分皆来自于作者<code>Github</code>主页，如有侵权，请告知。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本次给大家推荐一些&lt;code&gt;Github&lt;/code&gt;上的源码，排名不分先后。&lt;/p&gt;
&lt;h2 id=&quot;一、微信小游戏的推出，自然而然是火爆了一把。但是一切都阻止不了程序员，自然是要破解一番的，本次首推的就是利用Python开发的跳一跳辅助。&quot;&gt;&lt;a href=&quot;#一、微信小游戏的推出，自然而然是火爆了一把。但是一切都阻止不了程序员，自然是要破解一番的，本次首推的就是利用Python开发的跳一跳辅助。&quot; class=&quot;headerlink&quot; title=&quot;一、微信小游戏的推出，自然而然是火爆了一把。但是一切都阻止不了程序员，自然是要破解一番的，本次首推的就是利用Python开发的跳一跳辅助。&quot;&gt;&lt;/a&gt;一、微信小游戏的推出，自然而然是火爆了一把。但是一切都阻止不了程序员，自然是要破解一番的，本次首推的就是利用&lt;code&gt;Python&lt;/code&gt;开发的&lt;code&gt;跳一跳&lt;/code&gt;辅助。&lt;/h2&gt;&lt;h3 id=&quot;原理说明-摘自作者原文&quot;&gt;&lt;a href=&quot;#原理说明-摘自作者原文&quot; class=&quot;headerlink&quot; title=&quot;原理说明(摘自作者原文)&quot;&gt;&lt;/a&gt;原理说明(摘自作者原文)&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将手机点击到《跳一跳》小程序界面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用 ADB 工具获取当前手机截图，并用 ADB 将截图 pull 上来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算按压时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;手动版：用 Matplotlib 显示截图，用鼠标先点击起始点位置，然后点击目标位置，计算像素距离；&lt;/li&gt;
&lt;li&gt;自动版：靠棋子的颜色来识别棋子，靠底色和方块的色差来识别棋盘；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用 ADB 工具点击屏幕蓄力一跳&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="源码" scheme="http://bugdeveloper.gitee.io/blog/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Github" scheme="http://bugdeveloper.gitee.io/blog/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods设置target支持的swift版本 </title>
    <link href="http://bugdeveloper.gitee.io/blog/2017/11/24/CocoaPods%E8%AE%BE%E7%BD%AEtarget%E6%94%AF%E6%8C%81%E7%9A%84swift%E7%89%88%E6%9C%AC/"/>
    <id>http://bugdeveloper.gitee.io/blog/2017/11/24/CocoaPods设置target支持的swift版本/</id>
    <published>2017-11-24T00:50:33.000Z</published>
    <updated>2018-02-03T07:46:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章说道在<code>Swift4.0</code>中如何引用<code>3.0</code>版本的第三方库，详见<a href="https://historyzhang.github.io/2017/10/21/Swift4.0%E5%BC%95%E7%94%A83.0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/" target="_blank" rel="noopener">这篇文章</a>。但是如果<code>Pods</code>中有很多第三方库都只支持<code>3.0</code>，一个一个修改恐怕是要累死。而且每次执行<code>pod update</code>之后之前设置的都会被重置，恐怕是想死的心都有了。<br><a id="more"></a><br>有一句是说：”懒惰”推动了人类的进步。所以程序猿总是有办法的。</p><blockquote><p>Talk is cheap, Show me the code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &apos;10.0&apos;</span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target &apos;YourTarget&apos; do</span><br><span class="line">    pod &apos;SnapKit&apos;, &apos;~&gt; 4.0.0&apos;</span><br><span class="line">    pod &apos;Toast-Swift&apos;, &apos;~&gt; 2.0.0&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">post_install do |installer|</span><br><span class="line">    installer.pods_project.targets.each do |target|</span><br><span class="line">        if target.name == &apos;Toast-Swift&apos;</span><br><span class="line">            target.build_configurations.each do |config|</span><br><span class="line">                config.build_settings[&apos;SWIFT_VERSION&apos;] = &apos;3.2&apos;</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章说道在&lt;code&gt;Swift4.0&lt;/code&gt;中如何引用&lt;code&gt;3.0&lt;/code&gt;版本的第三方库，详见&lt;a href=&quot;https://historyzhang.github.io/2017/10/21/Swift4.0%E5%BC%95%E7%94%A83.0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;。但是如果&lt;code&gt;Pods&lt;/code&gt;中有很多第三方库都只支持&lt;code&gt;3.0&lt;/code&gt;，一个一个修改恐怕是要累死。而且每次执行&lt;code&gt;pod update&lt;/code&gt;之后之前设置的都会被重置，恐怕是想死的心都有了。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://bugdeveloper.gitee.io/blog/categories/iOS/"/>
    
    
      <category term="Swift4" scheme="http://bugdeveloper.gitee.io/blog/tags/Swift4/"/>
    
      <category term="CocoaPods" scheme="http://bugdeveloper.gitee.io/blog/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>Xcode9下自动化编译错误</title>
    <link href="http://bugdeveloper.gitee.io/blog/2017/11/09/Xcode9%E4%B8%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF/"/>
    <id>http://bugdeveloper.gitee.io/blog/2017/11/09/Xcode9下自动化编译错误/</id>
    <published>2017-11-09T14:03:20.000Z</published>
    <updated>2018-02-03T07:48:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在使用<code>CI</code>平台打包时突然失败了，查看日志后发现是在<code>exportArchive</code>时失败了。之前一直都是好好地，升级了<code>Xcode</code>之后突然就不行了，提示如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: exportArchive: &quot;AppName.app&quot; requires a provisioning profile with the Push Notifications and App Groups features.</span><br><span class="line">Error Domain=IDEProvisioningErrorDomain Code=9</span><br><span class="line">&quot;AppName.app&quot; requires a provisioning profile with the Push Notifications and App Groups features.&quot; UserInfo=&#123;NSLocalizedDescription=&quot;AppName.app&quot; requires a provisioning profile with the Push Notifications and App Groups features., NSLocalizedRecoverySuggestion=Add a profile to the &quot;provisioningProfiles&quot; dictionary in your Export Options property list.&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>查阅资料后发现，在<code>Xcode9</code>下，<code>xcodebuild</code>需要配置更多的信息才能导出<code>ipa</code>，最主要的一个就是<code>provisioningProfiles</code>。<br>具体的操作步骤如下。</p><ol><li><p>使用<code>Xcode</code> <code>Archive</code>一个新的版本<br><img src="http://upload-images.jianshu.io/upload_images/606479-78a2269f27ebb3ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p></li><li><p>在<code>Organizer</code>中找到刚刚<code>Archive</code>出来的版本，选择<code>Export</code>。<br><img src="http://upload-images.jianshu.io/upload_images/606479-7d463a8e3b69181a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p></li><li><p>选择你要导出的<code>ipa</code>类型，如果你需要不同版本，可以重复该流程，就可以得到其他类型所需要的信息了。<br><img src="http://upload-images.jianshu.io/upload_images/606479-ac0a0a0c788747a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p></li><li><p>导出<code>ipa</code>到目录<br><img src="http://upload-images.jianshu.io/upload_images/606479-7c81d9a2d4c0f347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p></li><li><p>最终导出的目录下会有<code>4</code>个文件，除了<code>ipa</code>文件还有一个<code>ExportOptions.plist</code>文件，这个文件就是我们使用<code>xcodebuild -exportArchive</code>命令时，<code>-exportOptionsPlist</code>参数需要指定的<code>plist</code>文件。<br><img src="http://upload-images.jianshu.io/upload_images/606479-da5c33fac97fc3ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"></p></li></ol><p>我们用这个新的<code>plist</code>文件就可以了。如果你需要打其他类型的<code>ipa</code>，可以重复上述步骤，在<code>第三步</code>重新选择即可。你也可以按照刚才导出的<code>plist</code>自己修改。</p><p>新的<code>plist</code>中有如下一些选项，你也可以参照修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;compileBitcode&lt;/key&gt;</span><br><span class="line">    &lt;false/&gt;</span><br><span class="line">    &lt;key&gt;method&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;ad-hoc&lt;/string&gt;</span><br><span class="line">    &lt;key&gt;provisioningProfiles&lt;/key&gt;</span><br><span class="line">    &lt;dict&gt;</span><br><span class="line">        &lt;key&gt;com.tsing.calculate&lt;/key&gt;</span><br><span class="line">        &lt;string&gt;calculate_adhoc&lt;/string&gt;</span><br><span class="line">    &lt;/dict&gt;</span><br><span class="line">    &lt;key&gt;signingCertificate&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;iPhone Distribution&lt;/string&gt;</span><br><span class="line">    &lt;key&gt;signingStyle&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;manual&lt;/string&gt;</span><br><span class="line">    &lt;key&gt;stripSwiftSymbols&lt;/key&gt;</span><br><span class="line">    &lt;true/&gt;</span><br><span class="line">    &lt;key&gt;teamID&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;CL32FD34&lt;/string&gt;</span><br><span class="line">    &lt;key&gt;thinning&lt;/key&gt;</span><br><span class="line">    &lt;string&gt;&amp;lt;none&amp;gt;&lt;/string&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在使用&lt;code&gt;CI&lt;/code&gt;平台打包时突然失败了，查看日志后发现是在&lt;code&gt;exportArchive&lt;/code&gt;时失败了。之前一直都是好好地，升级了&lt;code&gt;Xcode&lt;/code&gt;之后突然就不行了，提示如下信息：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;error: exportArchive: &amp;quot;AppName.app&amp;quot; requires a provisioning profile with the Push Notifications and App Groups features.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Error Domain=IDEProvisioningErrorDomain Code=9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;AppName.app&amp;quot; requires a provisioning profile with the Push Notifications and App Groups features.&amp;quot; UserInfo=&amp;#123;NSLocalizedDescription=&amp;quot;AppName.app&amp;quot; requires a provisioning profile with the Push Notifications and App Groups features., NSLocalizedRecoverySuggestion=Add a profile to the &amp;quot;provisioningProfiles&amp;quot; dictionary in your Export Options property list.&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://bugdeveloper.gitee.io/blog/categories/iOS/"/>
    
    
      <category term="自动打包" scheme="http://bugdeveloper.gitee.io/blog/tags/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/"/>
    
      <category term="xcodebuild" scheme="http://bugdeveloper.gitee.io/blog/tags/xcodebuild/"/>
    
      <category term="Jenkins" scheme="http://bugdeveloper.gitee.io/blog/tags/Jenkins/"/>
    
      <category term="Xcode9" scheme="http://bugdeveloper.gitee.io/blog/tags/Xcode9/"/>
    
  </entry>
  
  <entry>
    <title>Swift4.0引用3.0第三方库</title>
    <link href="http://bugdeveloper.gitee.io/blog/2017/10/21/Swift4.0%E5%BC%95%E7%94%A83.0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    <id>http://bugdeveloper.gitee.io/blog/2017/10/21/Swift4.0引用3.0第三方库/</id>
    <published>2017-10-21T15:56:21.000Z</published>
    <updated>2018-02-03T07:47:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Swift</code>已经发布了<code>4.0</code>版本，在<code>Xcode9</code>中新建项目后，默认是使用<code>4.0</code>语法的。项目中的引用的第三方库，虽然有很多已经发不了<code>4.0</code>版本，但是还是有一些未及时更新的，那在作者未更新之前我们是否有更好的办法来使用这些第三方库呢？答案当然是<strong>肯定</strong>的，<code>Xcode9</code>中是同时支持<code>3.2</code>和<code>4.0</code>语法的。具体的设置可以看下图。</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/606479-6a28ff6e929e5fc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置Swift语法版本"></p><p>那么下面就说说如何设置同时支持<code>3.2</code>和<code>4.0</code>。</p><ol><li><p>项目中如果使用<code>Cocoapods</code>来管理第三方库时，可以找到不支持<code>4.0</code>语法的库所在<code>target</code>，然后找到<code>Swift Language Version</code>选项，改为<code>3.2</code>，然后就可以顺利编译通过了。<br><img src="http://upload-images.jianshu.io/upload_images/606479-6d08d94bf9c81df0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Cocoapods库设置"></p></li><li><p>如果还有以源码集成进项目的，那就选择<code>Edit &gt; Convert &gt; To Current Swift Syntax..</code>吧</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Swift&lt;/code&gt;已经发布了&lt;code&gt;4.0&lt;/code&gt;版本，在&lt;code&gt;Xcode9&lt;/code&gt;中新建项目后，默认是使用&lt;code&gt;4.0&lt;/code&gt;语法的。项目中的引用的第三方库，虽然有很多已经发不了&lt;code&gt;4.0&lt;/code&gt;版本，但是还是有一些未及时更新的，那在作者未更新之前我们是否有更好的办法来使用这些第三方库呢？答案当然是&lt;strong&gt;肯定&lt;/strong&gt;的，&lt;code&gt;Xcode9&lt;/code&gt;中是同时支持&lt;code&gt;3.2&lt;/code&gt;和&lt;code&gt;4.0&lt;/code&gt;语法的。具体的设置可以看下图。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://bugdeveloper.gitee.io/blog/categories/iOS/"/>
    
    
      <category term="Swift4" scheme="http://bugdeveloper.gitee.io/blog/tags/Swift4/"/>
    
      <category term="iOS" scheme="http://bugdeveloper.gitee.io/blog/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS下更改系统音量</title>
    <link href="http://bugdeveloper.gitee.io/blog/2017/09/30/iOS%E4%B8%8B%E6%9B%B4%E6%94%B9%E7%B3%BB%E7%BB%9F%E9%9F%B3%E9%87%8F/"/>
    <id>http://bugdeveloper.gitee.io/blog/2017/09/30/iOS下更改系统音量/</id>
    <published>2017-09-30T13:29:38.000Z</published>
    <updated>2018-02-03T07:48:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>iOS</code>中，如果想更改系统音量，只有2个方法，一是使用私有方法；二是使用<code>MPVolumeView</code>。</p><p>私有方法不在我们的讨论范围之列，我们来讨论一下如何使用<code>MPVolumeView</code>。</p><p>用过一系列的音乐播放器都知道，添加一个<code>MPVolumeView</code>在<code>View</code>上，然后设置<code>showsVolumeSlider = YES</code>，就会有一个<code>SliderView</code>，用户滑动时，就能更改系统音量。</p><p>这样带来的问题就是，<br><a id="more"></a></p><ol><li><p>会显示一个<code>MPVolumeView</code>;</p></li><li><p>需要手动触发滑动事件;</p></li></ol><p>对于第一个问题很简单，<code>MPVolumeView</code>的<code>hidden</code>属性设置为<code>YES</code>即可；所以主要解决如何模拟用户手动滑动事件即可。</p><p>不多说，有了思路后就变得很简单了，下面奉上实现代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 设置音量</span><br><span class="line"> */</span><br><span class="line">- (void)setVolume:(float)value &#123;</span><br><span class="line"></span><br><span class="line">    UISlider *volumeSlider = [self volumeSlider];</span><br><span class="line">    self.volumeView.showsVolumeSlider = YES; // 需要设置 showsVolumeSlider 为 YES</span><br><span class="line">    // 下面两句代码是关键</span><br><span class="line">    [volumeSlider setValue:value animated:NO];</span><br><span class="line">    [volumeSlider sendActionsForControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.volumeView sizeToFit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MPVolumeView *)volumeView &#123;</span><br><span class="line">    if (!_volumeView) &#123;</span><br><span class="line">        _volumeView = [[MPVolumeView alloc] init];</span><br><span class="line">        _volumeView.hidden = YES;</span><br><span class="line">        [self.window addSubview:_volumeView];</span><br><span class="line">    &#125;</span><br><span class="line">    return _volumeView;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> * 遍历控件，拿到UISlider</span><br><span class="line"> */</span><br><span class="line">- (UISlider *)volumeSlider &#123;</span><br><span class="line">    UISlider* volumeSlider = nil;</span><br><span class="line">    for (UIView *view in [self.volumeView subviews]) &#123;</span><br><span class="line">        if ([view.class.description isEqualToString:@&quot;MPVolumeSlider&quot;])&#123;</span><br><span class="line">            volumeSlider = (UISlider *)view;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return volumeSlider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;iOS&lt;/code&gt;中，如果想更改系统音量，只有2个方法，一是使用私有方法；二是使用&lt;code&gt;MPVolumeView&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;私有方法不在我们的讨论范围之列，我们来讨论一下如何使用&lt;code&gt;MPVolumeView&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;用过一系列的音乐播放器都知道，添加一个&lt;code&gt;MPVolumeView&lt;/code&gt;在&lt;code&gt;View&lt;/code&gt;上，然后设置&lt;code&gt;showsVolumeSlider = YES&lt;/code&gt;，就会有一个&lt;code&gt;SliderView&lt;/code&gt;，用户滑动时，就能更改系统音量。&lt;/p&gt;
&lt;p&gt;这样带来的问题就是，&lt;br&gt;
    
    </summary>
    
      <category term="小飞鱼" scheme="http://bugdeveloper.gitee.io/blog/categories/%E5%B0%8F%E9%A3%9E%E9%B1%BC/"/>
    
    
      <category term="音量" scheme="http://bugdeveloper.gitee.io/blog/tags/%E9%9F%B3%E9%87%8F/"/>
    
      <category term="MPVolumeView" scheme="http://bugdeveloper.gitee.io/blog/tags/MPVolumeView/"/>
    
  </entry>
  
  <entry>
    <title>iOS拨打电话对话框问题解决</title>
    <link href="http://bugdeveloper.gitee.io/blog/2017/09/28/iOS%E6%8B%A8%E6%89%93%E7%94%B5%E8%AF%9D%E5%AF%B9%E8%AF%9D%E6%A1%86%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>http://bugdeveloper.gitee.io/blog/2017/09/28/iOS拨打电话对话框问题解决/</id>
    <published>2017-09-28T14:14:20.000Z</published>
    <updated>2018-02-03T07:47:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>iOS</code>中拨打电话大家应该都很清楚了，如果还有什么疑问的话可以参考<a href="https://historyzhang.github.io/2014/09/05/iOS%E6%8B%A8%E6%89%93%E7%94%B5%E8%AF%9D/" target="_blank" rel="noopener">这篇文章</a>。但是<code>iOS10</code>的系统会先有个对话框确认，这与并不符合小飞鱼的需求。小飞鱼是由语音控制拨打电话，当用户查找到号码后，只需语音确认一次即可拨打电话，如果有系统的确认对话框，不仅多了一个步骤，而且还需要模拟点击对话框按钮事件，比较繁琐。<br><a id="more"></a><br>由于小飞鱼中，<code>App</code>和设备之间是通过<code>BLE</code>和传统蓝牙来连接的，而用过蓝牙耳机的都应该知道，可以之间通过蓝牙耳机拨打电话。所以方案就有了：<br><img src="http://upload-images.jianshu.io/upload_images/606479-40f070fe687c0735.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="小飞鱼打电话方案"><br>如上图，<code>App</code>端先通过<code>BLE</code>把号码发送给设备，然后设备通过传统蓝牙协议(<code>PBAP</code>中<code>AT Command</code>)，直接拨号即可，不会弹出确认框。</p><p>具体的指令如下：<code>AT#CW13012341234\r\n</code>；<br>整个<code>PBAP</code>协议参见<a href="http://file.yizimg.com/440517/2015090120595853.pdf" target="_blank" rel="noopener">这篇文章</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;iOS&lt;/code&gt;中拨打电话大家应该都很清楚了，如果还有什么疑问的话可以参考&lt;a href=&quot;https://historyzhang.github.io/2014/09/05/iOS%E6%8B%A8%E6%89%93%E7%94%B5%E8%AF%9D/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;。但是&lt;code&gt;iOS10&lt;/code&gt;的系统会先有个对话框确认，这与并不符合小飞鱼的需求。小飞鱼是由语音控制拨打电话，当用户查找到号码后，只需语音确认一次即可拨打电话，如果有系统的确认对话框，不仅多了一个步骤，而且还需要模拟点击对话框按钮事件，比较繁琐。&lt;br&gt;
    
    </summary>
    
      <category term="小飞鱼" scheme="http://bugdeveloper.gitee.io/blog/categories/%E5%B0%8F%E9%A3%9E%E9%B1%BC/"/>
    
    
      <category term="打电话" scheme="http://bugdeveloper.gitee.io/blog/tags/%E6%89%93%E7%94%B5%E8%AF%9D/"/>
    
      <category term="蓝牙" scheme="http://bugdeveloper.gitee.io/blog/tags/%E8%93%9D%E7%89%99/"/>
    
      <category term="PBAP" scheme="http://bugdeveloper.gitee.io/blog/tags/PBAP/"/>
    
  </entry>
  
  <entry>
    <title>小飞鱼项目有感</title>
    <link href="http://bugdeveloper.gitee.io/blog/2017/09/27/%E5%B0%8F%E9%A3%9E%E9%B1%BC%E9%A1%B9%E7%9B%AE%E6%9C%89%E6%84%9F/"/>
    <id>http://bugdeveloper.gitee.io/blog/2017/09/27/小飞鱼项目有感/</id>
    <published>2017-09-27T15:36:00.000Z</published>
    <updated>2018-02-03T07:45:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>小飞鱼是科大讯飞车载开发的一款智能行车助手，通过语音操作，让你在开车过程中解放双手，使你在开车过程中更加安全，体验更优。<br>小飞鱼目前支持使用语音导航，打电话，听音乐、节目、电台，查询天气、股票，还支持对话闲聊，让你的旅途不再寂寞。</p></blockquote><p>整个项目涉及蓝牙、BLE、电话、高德导航以及媒体播放，在项目过程中遇到很多坑，后续会逐步介绍项目中遇到的问题。<br><a id="more"></a><br>这里先在这里打个广告吧（微信文章直接长按识别二维码，或者可以点击底部阅读原文）。<br><a href="https://itunes.apple.com/us/app/%E5%B0%8F%E9%A3%9E%E9%B1%BC/id1207190161?mt=8" target="_blank" rel="noopener">iOS App下载地址</a><br><img src="http://upload-images.jianshu.io/upload_images/606479-de8292a52cc9a2c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS App下载地址"></p><p><a href="https://item.jd.com/16895582778.html" target="_blank" rel="noopener">设备购买地址</a><br><img src="http://upload-images.jianshu.io/upload_images/606479-c26d5a8a702fb914.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设备购买地址"></p><h2 id="1-iOS拨打电话对话框问题解决"><a href="#1-iOS拨打电话对话框问题解决" class="headerlink" title="1. iOS拨打电话对话框问题解决"></a><a href="https://historyzhang.github.io/2017/09/28/iOS拨打电话对话框问题解决" target="_blank" rel="noopener">1. iOS拨打电话对话框问题解决</a></h2>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;小飞鱼是科大讯飞车载开发的一款智能行车助手，通过语音操作，让你在开车过程中解放双手，使你在开车过程中更加安全，体验更优。&lt;br&gt;小飞鱼目前支持使用语音导航，打电话，听音乐、节目、电台，查询天气、股票，还支持对话闲聊，让你的旅途不再寂寞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整个项目涉及蓝牙、BLE、电话、高德导航以及媒体播放，在项目过程中遇到很多坑，后续会逐步介绍项目中遇到的问题。&lt;br&gt;
    
    </summary>
    
      <category term="小飞鱼" scheme="http://bugdeveloper.gitee.io/blog/categories/%E5%B0%8F%E9%A3%9E%E9%B1%BC/"/>
    
    
      <category term="电话" scheme="http://bugdeveloper.gitee.io/blog/tags/%E7%94%B5%E8%AF%9D/"/>
    
      <category term="小飞鱼" scheme="http://bugdeveloper.gitee.io/blog/tags/%E5%B0%8F%E9%A3%9E%E9%B1%BC/"/>
    
  </entry>
  
  <entry>
    <title>iOS下日志记录</title>
    <link href="http://bugdeveloper.gitee.io/blog/2017/09/24/iOS%E4%B8%8B%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"/>
    <id>http://bugdeveloper.gitee.io/blog/2017/09/24/iOS下日志记录/</id>
    <published>2017-09-24T00:22:30.000Z</published>
    <updated>2018-01-12T13:37:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>iOS</code>开发中，一般大家都会自定义一个<code>DLog</code>的宏来代替<code>NSLog</code>，用来控制<code>Release</code>下的<code>Log</code>输出。<br>但是有以下几个弊端：</p><ul><li>没有日志分级。做过<code>Android</code>的都知道，<code>Android</code>可以分为5级，<code>Error</code>、<code>Warning</code>、<code>Info</code>、<code>Debug</code>、<code>Verbose</code>。</li><li>日志没法记录到文件，<code>Release</code>版本无法通过<code>Log</code>日志定位问题。<a id="more"></a>所以今天就推荐一个第三方库，<a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="noopener">CocoaLumberjack</a>，完全满足以上需求，不但如此，还支持以下需求：</li><li>自定义Log文件的文件数、有效期、缓存大小<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fileLogger.logFileManager.maximumNumberOfLogFiles = 20;</span><br><span class="line">fileLogger.maximumFileSize = 1024 * 1024 * 5;</span><br><span class="line">fileLogger.rollingFrequency = 60 * 60 * 24;</span><br></pre></td></tr></table></figure></li></ul><p>具体使用大家还是看看<code>GitHub</code>上的介绍。<br>现在说一下集成中遇到的问题：<br>1 . 可以自定义输出<code>Log</code>的格式，需要实现<code>DDLogFormatter</code>协议，下面提供一个示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (NSString *)formatLogMessage:(DDLogMessage *)logMessage &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *logLevel = nil;</span><br><span class="line">    switch (logMessage.flag) &#123;</span><br><span class="line">        case DDLogFlagError:</span><br><span class="line">            logLevel = @&quot;[E]&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case DDLogFlagWarning:</span><br><span class="line">            logLevel = @&quot;[W]&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case DDLogFlagInfo:</span><br><span class="line">            logLevel = @&quot;[I]&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case DDLogFlagDebug:</span><br><span class="line">            logLevel = @&quot;[D]&quot;;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            logLevel = @&quot;[V]&quot;;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *formatString = [NSString stringWithFormat:@&quot;%@ %@ [@%zd] %@ %@&quot;, [logMessage.timestamp descriptionWithLocale:[NSLocale currentLocale]], logLevel, logMessage.line, logMessage.function, logMessage.message];</span><br><span class="line">    return formatString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2 . 在单步调试时会发现，很多级别的日志不会立即显示到控制台中。在<code>DDLogMacros.h</code>中，我们可以看到以下几个宏定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define DDLogError(frmt, ...)   LOG_MAYBE(NO,                LOG_LEVEL_DEF, DDLogFlagError,   0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)</span><br><span class="line">#define DDLogWarn(frmt, ...)    LOG_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagWarning, 0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)</span><br><span class="line">#define DDLogInfo(frmt, ...)    LOG_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagInfo,    0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)</span><br><span class="line">#define DDLogDebug(frmt, ...)   LOG_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagDebug,   0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)</span><br><span class="line">#define DDLogVerbose(frmt, ...) LOG_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagVerbose, 0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)</span><br></pre></td></tr></table></figure></p><p>你会发现<code>DDLogError</code>和其他的宏定义的第一个参数不是很一样，然后找到<code>LOG_ASYNC_ENABLED</code>的定义，这样就很明白了，如果你需要立即显示，把<code>LOG_ASYNC_ENABLED</code>的定义改为如下即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifndef LOG_ASYNC_ENABLED</span><br><span class="line">    #define LOG_ASYNC_ENABLED NO</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>3 . 说一下<code>rollingFrequency</code>这个属性，看了源码后发现，作者是根据文件的创建时间来处理的，所以就会导致这样的问题，<code>1号15:00</code>创建的文件，然后用到<code>2号15:00</code>就会重新创建一个文件，所以会导致<code>2号的Log在15:00</code>被分为2个文件。</p><p>如果需要更高度的自定义，可以去<a href="https://github.com/CocoaLumberjack/CocoaLumberjack" target="_blank" rel="noopener">CocoaLumberjack</a>主页上看一下<code>README</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;iOS&lt;/code&gt;开发中，一般大家都会自定义一个&lt;code&gt;DLog&lt;/code&gt;的宏来代替&lt;code&gt;NSLog&lt;/code&gt;，用来控制&lt;code&gt;Release&lt;/code&gt;下的&lt;code&gt;Log&lt;/code&gt;输出。&lt;br&gt;但是有以下几个弊端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有日志分级。做过&lt;code&gt;Android&lt;/code&gt;的都知道，&lt;code&gt;Android&lt;/code&gt;可以分为5级，&lt;code&gt;Error&lt;/code&gt;、&lt;code&gt;Warning&lt;/code&gt;、&lt;code&gt;Info&lt;/code&gt;、&lt;code&gt;Debug&lt;/code&gt;、&lt;code&gt;Verbose&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;日志没法记录到文件，&lt;code&gt;Release&lt;/code&gt;版本无法通过&lt;code&gt;Log&lt;/code&gt;日志定位问题。
    
    </summary>
    
      <category term="iOS" scheme="http://bugdeveloper.gitee.io/blog/categories/iOS/"/>
    
    
      <category term="Log" scheme="http://bugdeveloper.gitee.io/blog/tags/Log/"/>
    
  </entry>
  
  <entry>
    <title>开源协议知多少</title>
    <link href="http://bugdeveloper.gitee.io/blog/2016/12/30/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9F%A5%E5%A4%9A%E5%B0%91/"/>
    <id>http://bugdeveloper.gitee.io/blog/2016/12/30/开源协议知多少/</id>
    <published>2016-12-30T15:20:28.000Z</published>
    <updated>2018-02-03T07:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>越来越多的公司和个人在<code>GitHub</code>上开源他的代码，这是一种精神。为那些开源的公司和个人致敬、点赞。<br>当你在<code>GitHub</code>上创建一个项目的时候，就会让你选择一个<code>License</code>，像<code>MIT</code>，<code>BSD</code>，<code>GPL v2</code>等等。<br>但是这么多开源协议，你真的知道怎么选择吗？当你用到一个开源库的时候，你真的看清他的开源协议吗？<br>或许，目前来说，你并没有注意到这些。但是，随着国内对知识产权的越来越重视（从音乐就可窥见一斑），说不定哪一天你就会收到一封邮件。<br>好吧，说了这么多，我们还是用一张图来读懂那些开源协议吧。<br><a id="more"></a><br>乌克兰程序员 Paul Bagwell 画了一张分析图（下图为阮一峰汉化版）。</p><p>图片来自文章<a href="http://mp.weixin.qq.com/s?__biz=MjM5NzM0MjcyMQ==&amp;mid=2650069260&amp;idx=2&amp;sn=8822fbfddda7f81b979e41ca42ab4fdd&amp;chksm=bedb026289ac8b7454449bc8caf6f2439df2c99603e5a916b8277c1205af32987535d269079e&amp;mpshare=1&amp;scene=23&amp;srcid=1230XrysavNVmGdVJreRrs1H#rd" target="_blank" rel="noopener">别以为把你的代码上传到开源中国就算是开源了！先选择一个合适的 License 吧</a>。</p><p><img src="http://upload-images.jianshu.io/upload_images/606479-974f8447a1b8e05a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开源协议选择"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;越来越多的公司和个人在&lt;code&gt;GitHub&lt;/code&gt;上开源他的代码，这是一种精神。为那些开源的公司和个人致敬、点赞。&lt;br&gt;当你在&lt;code&gt;GitHub&lt;/code&gt;上创建一个项目的时候，就会让你选择一个&lt;code&gt;License&lt;/code&gt;，像&lt;code&gt;MIT&lt;/code&gt;，&lt;code&gt;BSD&lt;/code&gt;，&lt;code&gt;GPL v2&lt;/code&gt;等等。&lt;br&gt;但是这么多开源协议，你真的知道怎么选择吗？当你用到一个开源库的时候，你真的看清他的开源协议吗？&lt;br&gt;或许，目前来说，你并没有注意到这些。但是，随着国内对知识产权的越来越重视（从音乐就可窥见一斑），说不定哪一天你就会收到一封邮件。&lt;br&gt;好吧，说了这么多，我们还是用一张图来读懂那些开源协议吧。&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://bugdeveloper.gitee.io/blog/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="开源协议" scheme="http://bugdeveloper.gitee.io/blog/tags/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>iOS 高性能异构滚动视图-LazyScrollView实现</title>
    <link href="http://bugdeveloper.gitee.io/blog/2016/12/08/iOS-%E9%AB%98%E6%80%A7%E8%83%BD%E5%BC%82%E6%9E%84%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE-LazyScrollView%E5%AE%9E%E7%8E%B0/"/>
    <id>http://bugdeveloper.gitee.io/blog/2016/12/08/iOS-高性能异构滚动视图-LazyScrollView实现/</id>
    <published>2016-12-08T12:08:14.000Z</published>
    <updated>2018-01-12T13:37:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LazyScrollView简介"><a href="#LazyScrollView简介" class="headerlink" title="LazyScrollView简介"></a><code>LazyScrollView</code>简介</h2><blockquote><p>LazyScrollView 继承自ScrollView，目标是解决异构（与TableView的同构对比）滚动视图的复用回收问题。它可以支持跨View层的复用，用易用方式来生成一个高性能的滚动视图。此方案最先在天猫iOS客户端的首页落地。</p></blockquote><blockquote><p>—-<a href="http://pingguohe.net/2016/01/31/lazyscroll.html" target="_blank" rel="noopener">苹果核 - iOS 高性能异构滚动视图构建方案 —— LazyScrollView</a></p></blockquote><p>在<a href="http://pingguohe.net/2016/01/31/lazyscroll.html" target="_blank" rel="noopener">这篇文章</a>中，博主详细介绍了LazyScrollView的使用和实现方案，但是并没有给出具体DEMO，这里只是站在巨人的肩膀上，给一个DEMO，同时也希望可以抛砖引玉。</p><a id="more"></a><h2 id="LazyScrollView使用"><a href="#LazyScrollView使用" class="headerlink" title="LazyScrollView使用"></a><code>LazyScrollView</code>使用</h2><p>暂时的实现比较简陋，目前只有一个<code>id&lt;LazyScrollViewDataSource&gt; dataSource;</code>，需要实现下面三个接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@protocol LazyScrollViewDataSource &lt;NSObject&gt;</span><br><span class="line">@required</span><br><span class="line">// ScrollView一共展示多少个item</span><br><span class="line">- (NSUInteger)numberOfItemInScrollView:(LazyScrollView *)scrollView;</span><br><span class="line">// 要求根据index直接返回RectModel</span><br><span class="line">- (LSVRectModel *)scrollView:(LazyScrollView *)scrollView rectModelAtIndex:(NSUInteger)index;</span><br><span class="line">// 返回下标所对应的view</span><br><span class="line">- (UIView *)scrollView:(LazyScrollView *)scrollView itemByLsvId:(NSString *)lsvId;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>其中<code>LSVRectModel</code>就是原文中的<code>TMMuiRectModel</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface LSVRectModel : NSObject</span><br><span class="line">// 转换后的绝对值rect</span><br><span class="line">@property (nonatomic, assign) CGRect absRect;</span><br><span class="line">// 业务下标</span><br><span class="line">@property (nonatomic, copy) NSString *lsvId;</span><br><span class="line">+ (instancetype)modelWithRect:(CGRect)rect lsvId:(NSString *)lsvId;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><p>三个接口都很简单，和<code>UITableView</code>很类似，如果有不清楚，可以在底部查看DEMO或者原文。</p><p>另外，<code>LazyScrollView</code>提供了三个接口，也都是仿照<code>UITableView</code>来的，所以整个<code>LazyScrollView</code>的使用应该是很容易上手的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)reloadData;</span><br><span class="line">- (UIView *)dequeueReusableItemWithIdentifier:(NSString *)identifier;</span><br><span class="line">- (void)registerClass:(Class)viewClass forViewReuseIdentifier:(NSString *)identifier;</span><br></pre></td></tr></table></figure></p><h2 id="LazyScrollView实现"><a href="#LazyScrollView实现" class="headerlink" title="LazyScrollView实现"></a><code>LazyScrollView</code>实现</h2><p>最主要的思路就是复用，所以有两个<code>View</code>池：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, NSMutableSet *&gt; *reuseViews;</span><br><span class="line">@property (nonatomic, strong) NSMutableSet&lt;__kindof UIView *&gt; *visibleViews;</span><br></pre></td></tr></table></figure></p><p>由于每个<code>View</code>可能对应不同的identifier，所以<code>reuseViews</code>是一个<code>NSMutableDictionary</code>。<br>当一个<code>View</code>滑出可见区域之后，会将它先从<code>visibleViews</code>中移除，然后添加到<code>reuseViews</code>中，并从<code>LazyScrollView</code>中 <em>remove</em>，即调用<code>removeFromSuperview</code>。这个地方在原文中作者的表述可能让大家误会了。</p><blockquote><p>LazyScrollView中有一个Dictionary，key是reuseIdentifier,Value是对应reuseIdentifier被回收的View，当LazyScrollView得知这个View不该再出现了，会把View放在这里，并且把这个View hidden掉。</p></blockquote><p>这里作者用的是<code>hidden掉</code>，但是我们知道，<code>hidden</code>只是控制显隐，<code>View</code>本身还是在那里，也无法去复用。</p><p>而当一个View滑到可见区域内时，需要先从<code>reuseViews</code>中复用，如果<code>reuseViews</code>没有，则重新创建一个。相关实现请看<code>- (UIView *)dequeueReusableItemWithIdentifier:(NSString *)identifier;</code>。</p><p>最后一个问题就是如何判断一个<code>View</code>是在可见区域内的。这里原文中说的很清晰，还有图片配合。建议大家还是移步原文。这里我简单说一下，找到顶边大于<code>contentOffset.y - BUFFER_HEIGHT</code>，底边小于<code>contentOffset.y+CGRectGetHeight(self.bounds) + BUFFER_HEIGHT</code>，然后两个集合取交集就是需要显示的<code>View</code>集合了。<br>当然，这里有一些处理算法：</p><ul><li>对 <strong>顶边</strong> 做升序处理得到一个集合，对 <strong>底边</strong> 降序处理得到一个集合。</li><li>采用二分法查找合适的位置，然后再对上一步得到的集合取子集即可。</li></ul><p>好了，说了这么多，先放出DEMO地址吧，希望大家可以帮助完善，也希望可以给个Star。<br><a href="https://github.com/HistoryZhang/LazyScrollView" target="_blank" rel="noopener">https://github.com/HistoryZhang/LazyScrollView</a>。<br>原文地址：<a href="http://pingguohe.net/2016/01/31/lazyscroll.html" target="_blank" rel="noopener">苹果核 - iOS 高性能异构滚动视图构建方案 —— LazyScrollView</a>（里面还有很多干货）。</p><p>最后说一下目前写的几个问题，希望大家可以一起来优化：</p><ol><li>没有处理<code>View</code>点击事件，即没有写<code>delegate</code>回调。</li><li>二分法查找合适位置的时候算法待优化。</li><li>从旧的<code>visibleViews</code>中移除被滑出的<code>View</code>算法待优化。</li></ol><p>贴一段第二个问题的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableSet *)findSetWithMinEdge:(CGFloat)minEdge &#123;</span><br><span class="line">    NSArray *ascendingEdgeArray =</span><br><span class="line">    [self.allRects sortedArrayUsingComparator:^NSComparisonResult(LSVRectModel *obj1, LSVRectModel *obj2) &#123;</span><br><span class="line">        return CGRectGetMinY(obj1.absRect) &gt; CGRectGetMinY(obj2.absRect) ? NSOrderedDescending : NSOrderedAscending;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // TOOD: 此处待优化</span><br><span class="line">    // 二分法</span><br><span class="line">    NSInteger minIndex = 0;</span><br><span class="line">    NSInteger maxIndex = ascendingEdgeArray.count - 1;</span><br><span class="line">    NSInteger midIndex = (minIndex + maxIndex) / 2;</span><br><span class="line">    LSVRectModel *model = ascendingEdgeArray[midIndex];</span><br><span class="line">    while (minIndex &lt; maxIndex - 1) &#123;</span><br><span class="line">        if (CGRectGetMinY(model.absRect) &gt; minEdge) &#123;</span><br><span class="line">            maxIndex = midIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            minIndex = midIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        midIndex = (minIndex + maxIndex) / 2;</span><br><span class="line">        model = ascendingEdgeArray[midIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    midIndex = MAX(midIndex - 1, 0);</span><br><span class="line">    NSArray *array = [ascendingEdgeArray subarrayWithRange:NSMakeRange(midIndex, ascendingEdgeArray.count - midIndex)];</span><br><span class="line">    return [NSMutableSet setWithArray:array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再贴一段第三个问题的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    NSMutableArray *newVisibleViews = [self visiableViewModels].mutableCopy;</span><br><span class="line">    NSMutableArray *newVisibleLsvIds = [newVisibleViews valueForKey:@&quot;lsvId&quot;];</span><br><span class="line">    NSMutableArray *removeViews = [NSMutableArray array];</span><br><span class="line">    for (UIView *view in self.visibleViews) &#123;</span><br><span class="line">        if (![newVisibleLsvIds containsObject:view.lsvId]) &#123;</span><br><span class="line">            [removeViews addObject:view];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (UIView *view in removeViews) &#123;</span><br><span class="line">        [self.visibleViews removeObject:view];</span><br><span class="line">        [self enqueueReusableView:view];</span><br><span class="line">        [view removeFromSuperview];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LazyScrollView简介&quot;&gt;&lt;a href=&quot;#LazyScrollView简介&quot; class=&quot;headerlink&quot; title=&quot;LazyScrollView简介&quot;&gt;&lt;/a&gt;&lt;code&gt;LazyScrollView&lt;/code&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;LazyScrollView 继承自ScrollView，目标是解决异构（与TableView的同构对比）滚动视图的复用回收问题。它可以支持跨View层的复用，用易用方式来生成一个高性能的滚动视图。此方案最先在天猫iOS客户端的首页落地。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;—-&lt;a href=&quot;http://pingguohe.net/2016/01/31/lazyscroll.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;苹果核 - iOS 高性能异构滚动视图构建方案 —— LazyScrollView&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;http://pingguohe.net/2016/01/31/lazyscroll.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;中，博主详细介绍了LazyScrollView的使用和实现方案，但是并没有给出具体DEMO，这里只是站在巨人的肩膀上，给一个DEMO，同时也希望可以抛砖引玉。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://bugdeveloper.gitee.io/blog/categories/iOS/"/>
    
    
      <category term="LazyScrollView" scheme="http://bugdeveloper.gitee.io/blog/tags/LazyScrollView/"/>
    
      <category term="高性能" scheme="http://bugdeveloper.gitee.io/blog/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>iOS创建单例</title>
    <link href="http://bugdeveloper.gitee.io/blog/2016/11/01/iOS%E5%88%9B%E5%BB%BA%E5%8D%95%E4%BE%8B/"/>
    <id>http://bugdeveloper.gitee.io/blog/2016/11/01/iOS创建单例/</id>
    <published>2016-11-01T12:01:31.000Z</published>
    <updated>2018-02-03T07:48:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中经常会遇到需要单例的时候，然后很多时候大家写的单例其实并不符合要求。下面介绍一个标准的单例。</p><p>一般来说，我还是喜欢用<code>GCD</code>来创建单例，使用<code>dispatch_once</code>很方便。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static id _instance;   </span><br><span class="line"> </span><br><span class="line">+ (instancetype)sharedInstance  </span><br><span class="line">&#123;   </span><br><span class="line">    static dispatch_once_t onceToken;   </span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;   </span><br><span class="line">        _instance = [[self alloc] init];   </span><br><span class="line">    &#125;);   </span><br><span class="line">    return _instance;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面说的并不符合要求就是这样创建出来的单例。很多人以为这样就可以了，<code>dispatch_once</code>保证了只运行一次。然而，如果一个不知情的人调用了你写的类，你无法保证他不去调用<code>alloc</code>，<code>copy</code>来生成实例。<br>所以我们还要做一些其他的处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone  </span><br><span class="line">&#123;   </span><br><span class="line">    static dispatch_once_t onceToken;   </span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;   </span><br><span class="line">        _instance = [super allocWithZone:zone];   </span><br><span class="line">    &#125;);   </span><br><span class="line">    return _instance;   </span><br><span class="line">&#125;   </span><br><span class="line"> </span><br><span class="line">- (id)copyWithZone:(NSZone *)zone   </span><br><span class="line">&#123;   </span><br><span class="line">    return _instance;   </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line">- (id)mutableCopyWithZone:(NSZone *)zone &#123;   </span><br><span class="line">    return _instance;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发过程中经常会遇到需要单例的时候，然后很多时候大家写的单例其实并不符合要求。下面介绍一个标准的单例。&lt;/p&gt;
&lt;p&gt;一般来说，我还是喜欢用&lt;code&gt;GCD&lt;/code&gt;来创建单例，使用&lt;code&gt;dispatch_once&lt;/code&gt;很方便。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://bugdeveloper.gitee.io/blog/categories/iOS/"/>
    
    
      <category term="单例" scheme="http://bugdeveloper.gitee.io/blog/tags/%E5%8D%95%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>iOS10下使用AutoLayout动画失效解决</title>
    <link href="http://bugdeveloper.gitee.io/blog/2016/11/01/iOS10%E4%B8%8B%E4%BD%BF%E7%94%A8AutoLayout%E5%8A%A8%E7%94%BB%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3/"/>
    <id>http://bugdeveloper.gitee.io/blog/2016/11/01/iOS10下使用AutoLayout动画失效解决/</id>
    <published>2016-11-01T11:57:31.000Z</published>
    <updated>2018-02-03T07:47:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>更新到 <code>iOS10</code> 后，原来使用 <code>AutoLayout</code> 自定义的控件做了一些简单的动画失效了，但是在 <code>iOS10</code> 以下还是正常的。于是 <code>Google</code> 了一番，终于又是在 <a href="http://stackoverflow.com" target="_blank" rel="noopener">http://stackoverflow.com</a> 找到了解决办法。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[UIView animateWithDuration:0.3</span><br><span class="line">                          delay:0</span><br><span class="line">                          options:UIViewAnimationOptionCurveEaseOut</span><br><span class="line">                       animations:^&#123;</span><br><span class="line">         [self mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">                                                          </span><br><span class="line">         &#125;];</span><br><span class="line">         [self layoutIfNeeded];</span><br><span class="line">     &#125;</span><br><span class="line">                      completion:^(BOOL finished) &#123;</span><br><span class="line">                                              </span><br><span class="line">     &#125;];</span><br></pre></td></tr></table></figure><p>原来我们的代码应该是类似这样的，使用 <code>layoutIfNeeded</code> 强制刷新然后执行动画。<code>iOS10</code> 以后需要使用 <code>[self.superview layoutIfNeeded];</code> 。这样消失的动画就又出来了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;更新到 &lt;code&gt;iOS10&lt;/code&gt; 后，原来使用 &lt;code&gt;AutoLayout&lt;/code&gt; 自定义的控件做了一些简单的动画失效了，但是在 &lt;code&gt;iOS10&lt;/code&gt; 以下还是正常的。于是 &lt;code&gt;Google&lt;/code&gt; 了一番，终于又是在 &lt;a href=&quot;http://stackoverflow.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://stackoverflow.com&lt;/a&gt; 找到了解决办法。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://bugdeveloper.gitee.io/blog/categories/iOS/"/>
    
    
      <category term="AutoLayout" scheme="http://bugdeveloper.gitee.io/blog/tags/AutoLayout/"/>
    
      <category term="iOS10" scheme="http://bugdeveloper.gitee.io/blog/tags/iOS10/"/>
    
  </entry>
  
  <entry>
    <title>Xcode多Target设置</title>
    <link href="http://bugdeveloper.gitee.io/blog/2016/10/01/Xcode%E5%A4%9ATarget%E8%AE%BE%E7%BD%AE/"/>
    <id>http://bugdeveloper.gitee.io/blog/2016/10/01/Xcode多Target设置/</id>
    <published>2016-10-01T14:32:11.000Z</published>
    <updated>2018-01-12T13:37:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时候一个项目会分为多个版本，比如免费版、收费版，或者对于不同的客户定制不同版本。但是大体上功能都是差不多，只是部分页面稍有区别。如果每个版本都建一个工程又显得麻烦了，都放在一个 <code>Target</code> 又得写一堆的代码去区分甄别，而且在打包的时候很可能因为参数配置错误需要一而再、再而三的打包。</p><p>这个时候我们就可以用多 <code>Target</code> 来操作了。具体方法且听我一一道来。</p><a id="more"></a><hr><h3 id="首先我们得有一个工程，这里我就新建一个基本的模板工程。"><a href="#首先我们得有一个工程，这里我就新建一个基本的模板工程。" class="headerlink" title="* 首先我们得有一个工程，这里我就新建一个基本的模板工程。"></a>* 首先我们得有一个工程，这里我就新建一个基本的模板工程。</h3><p>工程的样子应该是这样。（我已经升级到 <code>Xcode8</code> 了，有什么不同之处请不要在意。）</p><p><img src="http://upload-images.jianshu.io/upload_images/606479-c9844bad20dccae2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161001-0.png"></p><h3 id="然后我们进入工程设置，右击中间的-TARGETS-，会有个选择让你-Duplicate-还是-Delete-，这里我们选择-Duplicate。"><a href="#然后我们进入工程设置，右击中间的-TARGETS-，会有个选择让你-Duplicate-还是-Delete-，这里我们选择-Duplicate。" class="headerlink" title="*  然后我们进入工程设置，右击中间的 TARGETS ，会有个选择让你 Duplicate 还是 Delete ，这里我们选择 Duplicate。"></a>*  然后我们进入工程设置，右击中间的 <code>TARGETS</code> ，会有个选择让你 <code>Duplicate</code> 还是 <code>Delete</code> ，这里我们选择 <code>Duplicate</code>。</h3><p><img src="http://upload-images.jianshu.io/upload_images/606479-2225d4c608db3235.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161001-1.png"></p><p>结果就是下面这个样子了，多个一个 <code>Target</code> 叫 <code>MultiTarget copy</code> ，还多了一个 <code>plist</code> 文件叫 <code>MultiTarget copy-Info.plist</code>。<br><img src="http://upload-images.jianshu.io/upload_images/606479-a2f374ee5f20b7e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161001-2.png"></p><h4 id="接下来首先想到的应该是改名字，毕竟-XXX-copy-不怎么友好。"><a href="#接下来首先想到的应该是改名字，毕竟-XXX-copy-不怎么友好。" class="headerlink" title="* 接下来首先想到的应该是改名字，毕竟 XXX copy 不怎么友好。"></a>* 接下来首先想到的应该是改名字，毕竟 <code>XXX copy</code> 不怎么友好。</h4><p>目前我所知道的方法只有一个一个的改。</p><p>囧。</p><p>如果你有好的方法，可以留言给我。</p><p>改完 <code>plist</code> 的名字后，需要在工程设置里面重新选择一下 <code>Info.plist</code> 。改完之后就像下图一样。我列了一下我改的几个地方。但是我记得早期版本的 <code>Xcode</code> 好像还需要修改 <code>Build Settings</code> 里面的一些东西。不过我的 <code>Xcode8</code> 好像不需要了。大家在做的时候注意一下。<br><img src="http://upload-images.jianshu.io/upload_images/606479-0f87e7da284493a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161001-3.png"></p><p><code>PS：忘了修改Bundle Identifier了，大家记得改一下</code></p><h3 id="最后一步就是做版本区分了。"><a href="#最后一步就是做版本区分了。" class="headerlink" title="* 最后一步就是做版本区分了。"></a>* 最后一步就是做版本区分了。</h3><p>首先我们在 <code>PRO</code> 版本中定义一个宏 <code>PRO_VERSION</code>，写在 <code>Build Settings</code> 里面。一定记得先选择 <code>PRO</code> <code>Target</code>。这个作用就是告诉编译器，我们在编译该 <code>Target</code> 时会有个全局的宏叫做 <code>PRO_VERSION</code>。这个时候我们就可以利用这个宏来做一些代码区分了。</p><p><img src="http://upload-images.jianshu.io/upload_images/606479-95d137145edbd4e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161001-4.png"></p><h3 id="最后我们测试一下。"><a href="#最后我们测试一下。" class="headerlink" title="* 最后我们测试一下。"></a>* 最后我们测试一下。</h3><p>我们在 <code>ViewController</code> 里面增加一个 <code>UILabel</code> ，方便起见，我就直接写 <code>frame</code> 了，在两个不同版本显示不同的文本。代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 50, CGRectGetWidth([UIScreen mainScreen].bounds), 80)];</span><br><span class="line">    label.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">    [self.view addSubview:label];</span><br><span class="line">    </span><br><span class="line">#ifdef PRO_VERSION</span><br><span class="line">    label.text = @&quot;这是PRO版本&quot;;</span><br><span class="line">#else</span><br><span class="line">    label.text = @&quot;这是NORMAL版本&quot;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>当然，编译哪个版本需要选择对应的 <code>Scheme</code>。下面放两张截图。</p><p><img src="http://upload-images.jianshu.io/upload_images/606479-7f3317bd714c2300.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PRO版本"></p><p><img src="http://upload-images.jianshu.io/upload_images/606479-b368c5be845363d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NORMAL版本![Uploading QQ20161001-9_892356.png . . .]"></p><h3 id="还有个事情就是图标，其实也可以设置的。"><a href="#还有个事情就是图标，其实也可以设置的。" class="headerlink" title="* 还有个事情就是图标，其实也可以设置的。"></a>* 还有个事情就是图标，其实也可以设置的。</h3><p>打开 <code>Assets.xcassets</code>，会发现已经有一个 <code>AppIcon</code> 了，我们再<code>copy</code>一份出来，然后改个名字，换一下图标，就是这样的效果。</p><p><img src="http://upload-images.jianshu.io/upload_images/606479-edcc35f26db7e23c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161001-5.png"></p><p>当然并没有结束，因为我们只是添加了资源，并没有用到。还是在工程设置里面，有个 <code>App Icons Source</code> ，选择一下就可以了。当然，我们还可以配置启动画面等等，这里就不演示了。</p><p><img src="http://upload-images.jianshu.io/upload_images/606479-4245677ed7eec517.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161001-6.png"></p><p>最后放一张两个 <code>App</code> 的图标，注意修改 <code>Bundle Identifier</code>，不然你不会运行出两个 <code>App</code> 的。</p><p><img src="http://upload-images.jianshu.io/upload_images/606479-08ca83fc44225585.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ20161001-9.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候一个项目会分为多个版本，比如免费版、收费版，或者对于不同的客户定制不同版本。但是大体上功能都是差不多，只是部分页面稍有区别。如果每个版本都建一个工程又显得麻烦了，都放在一个 &lt;code&gt;Target&lt;/code&gt; 又得写一堆的代码去区分甄别，而且在打包的时候很可能因为参数配置错误需要一而再、再而三的打包。&lt;/p&gt;
&lt;p&gt;这个时候我们就可以用多 &lt;code&gt;Target&lt;/code&gt; 来操作了。具体方法且听我一一道来。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://bugdeveloper.gitee.io/blog/categories/iOS/"/>
    
    
      <category term="多Target" scheme="http://bugdeveloper.gitee.io/blog/tags/%E5%A4%9ATarget/"/>
    
      <category term="多版本" scheme="http://bugdeveloper.gitee.io/blog/tags/%E5%A4%9A%E7%89%88%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg解码流程</title>
    <link href="http://bugdeveloper.gitee.io/blog/2016/09/30/FFmpeg%E8%A7%A3%E7%A0%81%E6%B5%81%E7%A8%8B/"/>
    <id>http://bugdeveloper.gitee.io/blog/2016/09/30/FFmpeg解码流程/</id>
    <published>2016-09-30T12:11:56.000Z</published>
    <updated>2018-01-12T13:37:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="以下系列文章基于FFmpeg-3-1-1和Xcode8。"><a href="#以下系列文章基于FFmpeg-3-1-1和Xcode8。" class="headerlink" title="以下系列文章基于FFmpeg 3.1.1和Xcode8。"></a>以下系列文章基于FFmpeg 3.1.1和Xcode8。</h2><h4 id="FFmpeg-iOS库编译与集成"><a href="#FFmpeg-iOS库编译与集成" class="headerlink" title="FFmpeg iOS库编译与集成"></a><a href="http://historyzhang.github.io/2016/09/26/FFmpeg%20iOS%E5%BA%93%E7%BC%96%E8%AF%91%E4%B8%8E%E9%9B%86%E6%88%90/" target="_blank" rel="noopener">FFmpeg iOS库编译与集成</a></h4><h4 id="FFmpeg解码流程"><a href="#FFmpeg解码流程" class="headerlink" title="FFmpeg解码流程"></a><a href="http://historyzhang.github.io/2016/09/30/FFmpeg%E8%A7%A3%E7%A0%81%E6%B5%81%E7%A8%8B/" target="_blank" rel="noopener">FFmpeg解码流程</a></h4><hr><p>学习 <code>FFmpeg</code> ，就不得不提到一位大神，就是 <a href="http://my.csdn.net/leixiaohua1020" target="_blank" rel="noopener">雷霄骅</a>，可惜天妒英才，在这里也先缅怀一下，同时也感谢他在视音频领域以及 <code>FFmpeg</code> 解析上做出的贡献。</p><hr><p>我们先了解一下视频播放的流程，这里主要参考的是雷神的文章，<a href="http://blog.csdn.net/leixiaohua1020/article/details/18893769" target="_blank" rel="noopener">[总结]视音频编解码技术零基础学习方法</a> 。过程见下图（图片同样来自雷神的文章，红色框框是我注解的）。</p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/606479-78a134f68de545b8.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="20140201120523046.jpeg"></p><blockquote><p>播放一个互联网上的视频文件，需要经过以下几个步骤：解协议，解封装，解码视音频，视音频同步。<br>如果播放本地文件则不需要解协议，为以下几个步骤：解封装，解码视音频，视音频同步。</p></blockquote><p>关于每个步骤的含义还是去雷神的文章去看，这里就不啰嗦了。</p><p>本文重点讨论的是解封装、解码视频。对于音频的处理先不管。</p><blockquote><p><strong>解码</strong>的作用，就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。</p></blockquote><p>好了，说了这么多理论，说点实在的。 <code>FFmpeg</code> 解码流程所需要调用的 <code>API</code> 依次为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">开始—-&gt;</span><br><span class="line">av_register_all();</span><br><span class="line">avformat_open_input()；</span><br><span class="line">av_find_stream_info();</span><br><span class="line">av_find_best_stream();</span><br><span class="line">avcodec_find_decoder();</span><br><span class="line">while(av_read_frame()) &#123;</span><br><span class="line">    获取到packet—-&gt;</span><br><span class="line">    avcodec_send_packet();</span><br><span class="line">    avcodec_receive_frame();</span><br><span class="line">    获取到frame</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的流程参考 <a href="http://depthlove.github.io/2015/04/27/talk-about-FFmpeg-part1/" target="_blank" rel="noopener">笔谈FFmpeg（一）</a>，其中有几个函数弃用了，所以我更新了一下。</p><p>简单的说一下更新的几个函数，其他的网上介绍的很多了，后面我也会推荐几篇文章。</p><ul><li><code>av_find_best_stream()</code>：</li></ul><p>之前用的都是这样的方法：  <code>穷举所有的流，查找其中种类为CODEC_TYPE_VIDEO</code> 。所以看别人的文章会有个 <code>while</code> 的循环。</p><ul><li><code>avcodec_send_packet();avcodec_receive_frame();</code>：</li></ul><p>之前用的是 <code>avcodec_decode_video2()</code> 。后来 <code>FFmpeg</code> 把函数拆分了。</p><ul><li>还有个需要注意的，<code>avcodec_find_decoder();</code> 步骤中所用到的也有所变动。下面是以前的用法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pCodecCtx = pFormatCtx-&gt;streams[videoindex]-&gt;codec;  </span><br><span class="line">pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br></pre></td></tr></table></figure><p>下面是变动之后的用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pCodecCtx = avcodec_alloc_context3(NULL);</span><br><span class="line">avcodec_parameters_to_context(pCodecCtx, pFormatCtx-&gt;streams[videoStream]-&gt;codecpar);</span><br><span class="line">pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br></pre></td></tr></table></figure><p>通过以上的步骤，获取到 <code>frame</code> 数据就是解码后的原始视频数据。后面我们的存储或者播放也都是基于这个数据的。</p><hr><h4 id="参考文章列表："><a href="#参考文章列表：" class="headerlink" title="参考文章列表："></a>参考文章列表：</h4><ul><li><p><a href="http://blog.csdn.net/leixiaohua1020/article/details/8652605" target="_blank" rel="noopener">100行代码实现最简单的基于FFMPEG+SDL的视频播放器（SDL1.x）</a>  作者：<a href="http://my.csdn.net/leixiaohua1020" target="_blank" rel="noopener">雷霄骅</a></p></li><li><p><a href="http://depthlove.github.io/2015/04/27/talk-about-FFmpeg-part1/" target="_blank" rel="noopener">笔谈FFmpeg（一）</a> 作者：<a href="http://depthlove.github.io/" target="_blank" rel="noopener">Minmin.Sun</a></p></li><li><p><a href="http://blog.csdn.net/ownwell/article/details/8113980" target="_blank" rel="noopener">ffmpeg解码流程</a> 作者：<a href="http://my.csdn.net/ownWell" target="_blank" rel="noopener">cyning4星运</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;以下系列文章基于FFmpeg-3-1-1和Xcode8。&quot;&gt;&lt;a href=&quot;#以下系列文章基于FFmpeg-3-1-1和Xcode8。&quot; class=&quot;headerlink&quot; title=&quot;以下系列文章基于FFmpeg 3.1.1和Xcode8。&quot;&gt;&lt;/a&gt;以下系列文章基于FFmpeg 3.1.1和Xcode8。&lt;/h2&gt;&lt;h4 id=&quot;FFmpeg-iOS库编译与集成&quot;&gt;&lt;a href=&quot;#FFmpeg-iOS库编译与集成&quot; class=&quot;headerlink&quot; title=&quot;FFmpeg iOS库编译与集成&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://historyzhang.github.io/2016/09/26/FFmpeg%20iOS%E5%BA%93%E7%BC%96%E8%AF%91%E4%B8%8E%E9%9B%86%E6%88%90/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FFmpeg iOS库编译与集成&lt;/a&gt;&lt;/h4&gt;&lt;h4 id=&quot;FFmpeg解码流程&quot;&gt;&lt;a href=&quot;#FFmpeg解码流程&quot; class=&quot;headerlink&quot; title=&quot;FFmpeg解码流程&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://historyzhang.github.io/2016/09/30/FFmpeg%E8%A7%A3%E7%A0%81%E6%B5%81%E7%A8%8B/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FFmpeg解码流程&lt;/a&gt;&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;学习 &lt;code&gt;FFmpeg&lt;/code&gt; ，就不得不提到一位大神，就是 &lt;a href=&quot;http://my.csdn.net/leixiaohua1020&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;雷霄骅&lt;/a&gt;，可惜天妒英才，在这里也先缅怀一下，同时也感谢他在视音频领域以及 &lt;code&gt;FFmpeg&lt;/code&gt; 解析上做出的贡献。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我们先了解一下视频播放的流程，这里主要参考的是雷神的文章，&lt;a href=&quot;http://blog.csdn.net/leixiaohua1020/article/details/18893769&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[总结]视音频编解码技术零基础学习方法&lt;/a&gt; 。过程见下图（图片同样来自雷神的文章，红色框框是我注解的）。&lt;/p&gt;
    
    </summary>
    
      <category term="FFmpeg" scheme="http://bugdeveloper.gitee.io/blog/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://bugdeveloper.gitee.io/blog/tags/FFmpeg/"/>
    
  </entry>
  
</feed>
