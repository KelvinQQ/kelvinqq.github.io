{"meta":{"title":"半亩方塘","subtitle":null,"description":null,"author":"Kelvin","url":"https://kelvinqq.github.io","root":"/"},"pages":[{"title":"分类","date":"2017-09-24T14:32:22.000Z","updated":"2021-08-27T13:34:42.829Z","comments":true,"path":"categories/index.html","permalink":"https://kelvinqq.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-09-25T16:04:47.000Z","updated":"2021-08-27T13:34:42.828Z","comments":true,"path":"about/index.html","permalink":"https://kelvinqq.github.io/about/index.html","excerpt":"","text":"蜘蛛纸牌 for macOS仿 Windows 经典单机游戏 蜘蛛纸牌 点此直达项目 版权说明本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！ 联系方式E-Mail : history_zq@163.com"},{"title":"标签","date":"2017-09-24T14:28:22.000Z","updated":"2021-08-27T13:34:42.990Z","comments":false,"path":"tags/index.html","permalink":"https://kelvinqq.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"聊个最近体检的事情（二）","slug":"聊个最近体检的事情（二）","date":"2021-09-11T14:38:00.000Z","updated":"2021-09-11T14:39:56.838Z","comments":true,"path":"2021/09/11/聊个最近体检的事情（二）/","link":"","permalink":"https://kelvinqq.github.io/2021/09/11/%E8%81%8A%E4%B8%AA%E6%9C%80%E8%BF%91%E4%BD%93%E6%A3%80%E7%9A%84%E4%BA%8B%E6%83%85%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"体检后续来了，到现在这个状况，我是万万没想到的。 如果不知道前文，还请看上一篇文章，《聊个最近体检的事情（一）》。 一大早去省立排队看医生，这次很快，第二个号，还是个专家。第一位患者进去后没几分钟，人还在里面治疗，过来一个家属带着患者，直接就进去了，心里一万只草泥马奔腾。","text":"体检后续来了，到现在这个状况，我是万万没想到的。 如果不知道前文，还请看上一篇文章，《聊个最近体检的事情（一）》。 一大早去省立排队看医生，这次很快，第二个号，还是个专家。第一位患者进去后没几分钟，人还在里面治疗，过来一个家属带着患者，直接就进去了，心里一万只草泥马奔腾。 等第一位患者走了后，里面就凑上去了。我也不管他，直接就进去了，就想听听他们准备聊啥。果然那个男的把手上拎着的一盒茶叶递给了医生，嘿嘿嘿~说一句，“都是老朋友了！” 寒暄了几句后，说什么没挂上号，医生说了句，出去找导医可以了，我刚刚已经把号放开了。后面又说了什么去做检查巴拉巴拉，然后就走了。 好吧，等到我了。简单说了些情况，肾囊肿和脾肿大。“肾囊肿我不看的。”理解理解，毕竟术业有专攻。 “两周前安医二附院体检脾肿大，但是一周前一附院复查B超正常。” “那你听一附院的嘛。” “因为不一致，所以想看看到底是什么情况。” 按压了一下肚子，“那要不做个CT吧，CT看的清楚，量的更准一些。”然后在病历写下了“体检脾大，按压无疼痛感”。开了个CT的号，走出房门后，定睛一看，竟然是下周一的号。 所以现在就很尴尬了，莫不是我下周一再去做CT？来来回回，烦死了。 下午去补了个牙，3个龋齿，20分钟600块。 现在好多人都有牙齿问题 矛盾的心让我无所适从 一医一患好难啊","categories":[{"name":"日记","slug":"日记","permalink":"https://kelvinqq.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"体检","slug":"体检","permalink":"https://kelvinqq.github.io/tags/%E4%BD%93%E6%A3%80/"}]},{"title":"纯Flutter工程的分层架构设计以及工程化实践（一）","slug":"纯Flutter工程的分层架构设计以及工程化实践（一）","date":"2021-09-09T13:01:11.000Z","updated":"2021-09-09T13:08:04.324Z","comments":true,"path":"2021/09/09/纯Flutter工程的分层架构设计以及工程化实践（一）/","link":"","permalink":"https://kelvinqq.github.io/2021/09/09/%E7%BA%AFFlutter%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%BB%A5%E5%8F%8A%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"一家之言，勿喷。若有更好方案，欢迎共享。 前言关于 Flutter 的教程已经有很多了，也有很多优秀的开源项目，这在一定程度上也增加了社区的活跃度。同时也有很多商业项目在实践，不过多数是将Flutter工程作为一个module来嵌入原生工程。官方有对应的教程来指导相关的工程化，网上的教程也很多。 但是一个纯 Flutter 工程的分层架构设计以及工程化的教程并不是很多。恰巧最近有个项目需要基于 Flutter 工程来搭建，对分层设计以及相应的工程化做了一些思考和调研，此仓库的目的即在于记录方案，与大家分享。","text":"一家之言，勿喷。若有更好方案，欢迎共享。 前言关于 Flutter 的教程已经有很多了，也有很多优秀的开源项目，这在一定程度上也增加了社区的活跃度。同时也有很多商业项目在实践，不过多数是将Flutter工程作为一个module来嵌入原生工程。官方有对应的教程来指导相关的工程化，网上的教程也很多。 但是一个纯 Flutter 工程的分层架构设计以及工程化的教程并不是很多。恰巧最近有个项目需要基于 Flutter 工程来搭建，对分层设计以及相应的工程化做了一些思考和调研，此仓库的目的即在于记录方案，与大家分享。 分层设计分层设计和目前成熟的移动端的分层设计差不多，都是根据基础能力和业务模块对 App 进行分层以及组件划分，从而达到组件化的目的。例如下图是一个很常见的移动端分层设计。 将与业务无关的基础能力剥离出来，沉淀到最底层，上层的业务都会基于这些能力去构建；中间划出一个业务能力层，多数是一些弱业务逻辑的模块，像分享、支付这样的能力；然后是业务模块，这些基本上就是用户可感知的界面以及业务逻辑了；最后是宿主App。基于这样的分层设计，宿主App一般都是个壳工程。 针对这样的设计，相应的组件间通信方案、工程化方案都已经很成熟，而且可选方案也很多。这里不再赘述，感兴趣的可以自行Google。 所以我们的Flutter应该也是可以按照这样的分层去设计，但是由于Flutter开发中可能会遇到需要原生提供能力的场景，这样就会有一部分能力是基于原生能力封装的插件，但总的分层设计还是类似的。例如下图的分层设计： 工程化实践目前网络上关于这一块的讨论比较少，如果你有看到相关的文章，欢迎共享。鉴于组内iOS的小伙伴是使用VSCode来开发的，所以工程化实践也是基于VSCode来操作的，不过这个应该影响不大。 模板工程介绍我们先了解一下Flutter为我们提供的4中模板工程：App、Module、Plugin、Package。 App 我们一般都是创建一个App工程，这个模板工程会有android、ios目录，对应存放的是两个平台的工程。 Module 使用这个模板创建出来的工程，会有.android、.ios目录，从模板的名称可以猜到应该是作为Module来使用的，官方对于这个模板的应用场景是将Flutter作为原生的一个子Module。这个模板创建的时候也会有main.dart文件，可以单独运行在你的设备上。 Plugin 如果你需要封装基于原生能力的插件，就需要用到这个模板。 Package 这是一个纯Flutter模块，没有android、ios目录。 pubspec.yaml 配置介绍看过Flutter教程的应该都了解，如果我们需要引用一些第三方库，就可以在这里配置，一般我们配置的都是发布在 pub.dev 上的开源项目。但其实，除了可以直接依赖pub.dev，他还支持本地依赖，git 仓库依赖。你可以这样操作： 123456dependencies: plugin1: git: url: &quot;git://github.com/flutter/plugin1.git&quot; fish_redux: path: my_package/fish_redux-0.3.1 另外git依赖还支持指定branch，指定子目录等。 好了，铺垫了这么多，是时候介绍我们的工程化方案了。 具体方案鉴于目前还处于初步实践阶段，所以并没有将各个组件上传到git仓库，而是采用基于本地依赖的方式。因为各个组件可能会频繁变动，就会不停的切换工程等。等后期稳定后，可以采用git依赖的方式，达到供多个App使用的目的。 先来看一下整个工程的目录结构，如果你有一定的分层设计经验，应该很容易理解这个目录结构的设计。 HostApp ：壳工程目录BusinessModule ：业务模块目录BusinessLib：业务能力目录，里面还有个二级的UI目录，存放一些和业务相关的公共UI组件CommonLib ：基础能力目录 按照上面的思路，我们首先需要一个壳工程，我们使用VSCode新建一个App工程，这里放在HostApp目录下。 接着我们在BusinessModule中新建四个业务模块工程，这次我们不再新建App工程，而是新建Module工程。我这边新建了module_home、module_user、module_task、module_setting四个工程。 同样，我们在BusinessLib中也新建几个工程，供测试使用，这里新建了lib_account、lib_push、lib_share，然后在UI目录中新建了lib_alert、lib_banner、lib_loading。在CommonLib新建lib_database、lib_log、lib_network。其中lib_account、lib_database、lib_network是Package工程，lib_push、lib_share、lib_alert、lib_banner、lib_loading是Module工程，lib_log是Plugin工程。大家根据自己的实际场景去新建对应的模板工程。 这样所有的工程都放在对应的目录，为了方便管理，我们新建一个workspace来管理所有的工程。具体可以这样操作： 在VSCode中New Window Add Folder to Workspace...，选择我们的根目录 Save Workspace As...，保存到我们的根目录 下次可以直接打开我们的workspace文件。 现在打开host_app工程的pubspec.yaml做如下配置，将BusinessModule中的组件引入进来。 123456789dependencies: module_home: path: ../../BusinessModule/module_home module_user: path: ../../BusinessModule/module_user module_setting: path: ../../BusinessModule/module_setting module_task: path: ../../BusinessModule/module_task 保存后运行flutter pub get。 这里有个小问题，就是使用workspace后，在host_app里面去引用module_home内定义的页面，没有代码提示，但是手动import后，编译都正常。不知道是Bug还是我使用的有问题。 我们在module_home、module_user、module_setting、module_task中各新建一个页面，HomePage、UserPage、SettingPage、TaskPage。 我们在host_app的入口构建一个Tab页面，将我们的HomePage、UserPage作为两个Tab加载进来。试着运行一下，感觉良好。 哇哦，基本的框架已经搭建出来了，虽然后续需要处理的事情还有很多，例如组件间的页面如何跳转、组件间如何通信，都需要有对应的方案实现。 且等我继续调研实践。 对应的Demo工程已经上传GitHub。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://kelvinqq.github.io/categories/Flutter/"}],"tags":[{"name":"组件化","slug":"组件化","permalink":"https://kelvinqq.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"工程化","slug":"工程化","permalink":"https://kelvinqq.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"聊个最近体检的事情（一）","slug":"聊个最近体检的事情（一）","date":"2021-09-05T14:27:07.000Z","updated":"2021-09-05T14:41:31.950Z","comments":true,"path":"2021/09/05/聊个最近体检的事情（一）/","link":"","permalink":"https://kelvinqq.github.io/2021/09/05/%E8%81%8A%E4%B8%AA%E6%9C%80%E8%BF%91%E4%BD%93%E6%A3%80%E7%9A%84%E4%BA%8B%E6%83%85%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"最近公司组织了年度体检，鉴于过去几年都在安医二附院体检的，又可以携带家属，所以今年还是选择了安医二附院。 早早的过去排队，接受一年一度的大考，毕竟上了年纪，心中还是很忐忑。 其他的项目要么就是很基础的，例如血压身高，口腔眼科，一般不会有什么大问题，或者有没有自己心里应该也有数；要么就是当场出不来结果的，例如血常规，肝功能等等。 彩超可以当场知道结果，并且周围的同事体检大多数也都会在这里翻车。例如：脂肪肝。 等到自己的号，进去，开始。","text":"最近公司组织了年度体检，鉴于过去几年都在安医二附院体检的，又可以携带家属，所以今年还是选择了安医二附院。 早早的过去排队，接受一年一度的大考，毕竟上了年纪，心中还是很忐忑。 其他的项目要么就是很基础的，例如血压身高，口腔眼科，一般不会有什么大问题，或者有没有自己心里应该也有数；要么就是当场出不来结果的，例如血常规，肝功能等等。 彩超可以当场知道结果，并且周围的同事体检大多数也都会在这里翻车。例如：脂肪肝。 等到自己的号，进去，开始。 “脂肪肝”，医生随口说道，应该是见怪不怪吧。 “脾大，13mm”。一脸懵逼，因为过去几年都没有检查出这个问题，也没听过有同事讨论过这个。 “左肾囊肿”。 听到这里，心都凉了一截。好在早就买了大病医疗险，不过就是一直没配置重疾险（太贵了）。心中一直默念，别再有啥其他的了，回头我复查都得好几天。 下床排队的时候，立马掏出手机开始百度。先看看“脾大”是个什么鬼。百度虽然没能告诉我导致“脾大”的病因，却让我了解到，“脾大”最严重是切除脾。鬼鬼，幸好我接受过九年义务教育，心理素质尚可。 更恐怖的是百度的关联搜索词，我先是点了一下“脾大有什么危害”，随手翻几页，我想我还是上图吧。 难怪最近抖音总是刷到，医生最怕的几种病患。默默的关上了浏览器，换到知乎，那个内容全靠编的平台。总之一句话，病因多种多样，找到病因才能对症下药。看样子跑不了去门诊复查了。 “脂肪肝”就不用查了，大家都很熟了。我是18年体检有轻度脂肪肝，19年和20年体检都没有了。今年应该是伙食太好，又缺少运动。所以还是启动跑步计划吧。 “肾囊肿”，感觉应该是个小问题，没当一回事，简单搜了一下，似乎印证了我的猜想。一般“13mm”可以不用管，超过“40mm”就要注意了。 回家和媳妇报备了一下，准备抽空约个号去看一下“脾大”。说到“左肾囊肿”，媳妇若有所思，好像之前有同事就是这个病，后来突然很严重，还在住院治疗，心中咯噔一下，不会这么巧中招吧。翻一下聊天记录，一模一样。本来准备下周再去复查的，乖乖立马挂号，还是怕死。 鉴于二附院的一些情况，换了个离家近的安医一附院高新分院。先是去泌尿科看“左肾囊肿”，忐忐忑忑。医生说，“你这个太小了，一般小于40mm并且没有尿血、长期腰痛的情况，我们都不需要针对处理，很多人都有这个囊肿，是个良性的。一般定期复查，比如一年一查，不出现快速变大就不用管。反而你要去看看这个脾大是什么情况”。两级反转？ 我想我还是三个月半年查一次吧。 转手挂个普外科的号，漫长的等待是煎熬的，毕竟心里总是想着：“会不会要切除？脾大能活多久？” “你在哪家医院体检的？我们复查一下，有些医院体检结果可能不对。” “安医二附院。” “我们还是复查一下吧。” “你过来做彩超是什么问题？” “体检报告说：脾大。” “你这脾一点也不大啊，你在哪家医院体检的？” 我还能说什么呢。随口还是问了句：“我的脂肪肝是轻度还是中度？” “还好。” 心略微放了下来，毕竟一周没有吃肉了。 回来后暗自庆幸的同时也在想，为什么仅仅隔了一周，“脾大”的症状就消失了呢？不会是我坚持跑步一周就有这样的奇效吗？媳妇从旁指点说：“下周再挂个省立的号看一下。”我觉得是个好主意。 此次体检事件让我明白： 百度在搜索1+1=2的问题上还是很靠谱的。 跑步可能对“脾大”有一定的疗效。 九年义务教育还是很有作用的。 凡事不要慌，先发个文章。 静待我的后续文章。","categories":[{"name":"日记","slug":"日记","permalink":"https://kelvinqq.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"体检","slug":"体检","permalink":"https://kelvinqq.github.io/tags/%E4%BD%93%E6%A3%80/"}]},{"title":"一次上线翻车让我总结出以下几点血的教训","slug":"一次上线翻车让我总结出以下几点血的教训","date":"2021-08-31T01:21:07.000Z","updated":"2021-09-05T14:36:27.416Z","comments":true,"path":"2021/08/31/一次上线翻车让我总结出以下几点血的教训/","link":"","permalink":"https://kelvinqq.github.io/2021/08/31/%E4%B8%80%E6%AC%A1%E4%B8%8A%E7%BA%BF%E7%BF%BB%E8%BD%A6%E8%AE%A9%E6%88%91%E6%80%BB%E7%BB%93%E5%87%BA%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%82%B9%E8%A1%80%E7%9A%84%E6%95%99%E8%AE%AD/","excerpt":"从17点准备上线，直到1点最终上线成功，整整耗费8个小时。通过这次上线翻车，总结了以下几点血的教训。 基础设施差导致上线失败的有两点，但是真的是很基础的东西。 环境配置混乱客户端在做渠道环境配置时混乱，基础网络能力采用了一个动态域名配置项，某一个业务模块又采用了另一个动态域名配置项。在研发过程中始终使用测试环境域名，没有按照配置项来去正确引用域名。等到版本发布后才发现引用域名错误，慌慌张张修改配置，战战兢兢回想是否还存在其他配置项。 这个低级错误完全可以避免：","text":"从17点准备上线，直到1点最终上线成功，整整耗费8个小时。通过这次上线翻车，总结了以下几点血的教训。 基础设施差导致上线失败的有两点，但是真的是很基础的东西。 环境配置混乱客户端在做渠道环境配置时混乱，基础网络能力采用了一个动态域名配置项，某一个业务模块又采用了另一个动态域名配置项。在研发过程中始终使用测试环境域名，没有按照配置项来去正确引用域名。等到版本发布后才发现引用域名错误，慌慌张张修改配置，战战兢兢回想是否还存在其他配置项。 这个低级错误完全可以避免： 项目最开始就需要定义好环境配置，避免后期研发还需要自己去随意定义环境配置。 研发实现过程中不要随意留尾巴，按照项目中公共配置去新增逻辑 合理组织 code review，及时发现低级错误。 后台环境准备不足我认为的后台环境至少需要准备4个： 开发：用于后台研发开发时使用 测试：用于客户端开发时使用 准上线：用户客户端测试时使用 线上：用户线上用户使用 而项目中仅仅只有2个环境，开发和线上。在上线之前，测试仅仅在开发环境上验证过，这样很难测试充分，尤其是一些数据导致的错误。而准上线环境最重要的一点就是，尽量保证和线上环境数据一致。 测试验证验证不足刚刚提到，测试在上线前竟然只在开发环境验证，这就是严重的验证不充分。 另一点，测试之前一直使用 debug 版本测试，从未使用 release 版本测试。众所周知，debug 和 release 有着很大的区别，甚至有些测试称 debug 包为 野包（手动狗头）。翻车是迟早的事情（我竟然有点幸灾乐祸）。 上线工作准备不充分18点的时候，竟然还在重新申请一个第三方库的 appId 去临时替换，当时我就预感要翻车。果然还是没能逃过一劫，来来回回弄了个把小时，还是回退到之前测试稳定的 appId。 开始验证的时候发现，资源下载太慢，5G 的资源，下载需要个把小时，项目和产品开始疯狂吐槽，一致决定资源暂时不上线。又是一通研发修改、测试验证。 嗯，这很敏捷。 盗图自朋友圈 @Q694263030","categories":[{"name":"日记","slug":"日记","permalink":"https://kelvinqq.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"上线","slug":"上线","permalink":"https://kelvinqq.github.io/tags/%E4%B8%8A%E7%BA%BF/"}]},{"title":"支付宝里的钱要取出来吗","slug":"支付宝里的钱要取出来吗","date":"2021-08-28T14:04:13.000Z","updated":"2021-08-31T01:25:49.230Z","comments":true,"path":"2021/08/28/支付宝里的钱要取出来吗/","link":"","permalink":"https://kelvinqq.github.io/2021/08/28/%E6%94%AF%E4%BB%98%E5%AE%9D%E9%87%8C%E7%9A%84%E9%92%B1%E8%A6%81%E5%8F%96%E5%87%BA%E6%9D%A5%E5%90%97/","excerpt":"盗图自朋友圈@workcalm 理性吃瓜娱乐圈这几个月可谓是一瓜接一瓜，自从吴某某被曝出来后，就没有消停过。 央媒评吴某某：“做艺先做人，做人先做德”。艺人是有一堆的粉丝，甚至有一些心智尚未成熟的青少年，他们的一举一动都将传递给粉丝。前几天沸沸扬扬的赵丽颖王一博事件，今天双方工作室也被约谈。正确引导粉丝行为，是艺人的社会责任。日趋严重的“伪娘文化”也遭痛批，“伪娘文化”应该说是外来文化的糟粕。 国家已经开始整顿这个满是疮痍的行业以及扭曲的饭圈文化了，而不是仅仅口头说说了。","text":"盗图自朋友圈@workcalm 理性吃瓜娱乐圈这几个月可谓是一瓜接一瓜，自从吴某某被曝出来后，就没有消停过。 央媒评吴某某：“做艺先做人，做人先做德”。艺人是有一堆的粉丝，甚至有一些心智尚未成熟的青少年，他们的一举一动都将传递给粉丝。前几天沸沸扬扬的赵丽颖王一博事件，今天双方工作室也被约谈。正确引导粉丝行为，是艺人的社会责任。日趋严重的“伪娘文化”也遭痛批，“伪娘文化”应该说是外来文化的糟粕。 国家已经开始整顿这个满是疮痍的行业以及扭曲的饭圈文化了，而不是仅仅口头说说了。 广电总局发文限制已入外籍艺人在大陆发展“赚着中国人的钱，砸着中国人的锅”，这样的人不在少数。如今广总终于发文整治，也可谓是大快人心，民心所向。毕竟理性的爱国民众还是多数。 清理劣迹艺人节目及内容那个“小燕子”这下真的一去不复返了，全网除名、下架，连百科都没放过。而她只是广总说的劣迹艺人中的一员，霍某、吴某某、郑某、范某某皆在其列。 是该提高一下人民群众的精神文化需求了。 阿里系上热搜另一个有意思的是，昨天阿里系突然冲上热搜，前十中竟然有五条是关于阿里系的。热搜榜第一竟然是”支付宝里的钱要取出来吗“，吓得我赶紧去支付宝看了一下，幸好余额为零，看来我多虑了。 同阿里以及娱乐圈密不可分的高某某也没能逃过一劫。 都某某功不可没。 《我的1919》和《东京审判》剧荒的小伙伴可以去看一下这两部电影，很压抑。明明都是作为战胜国，却举步维艰。 《我的1919》讲述的是中国外交才子顾维钧作为中国代表团一员参加“巴黎和会”（分赃大会，与“和”根本不沾边）的经历。最终北洋政府外交失败，德国在山东的权益全部移交给日本。 《东京审判》介绍了以梅汝璈为首的中国法官在大国利益主导的势力挤压下，奋力突围，终于将以东条英机为首的七个战犯送上绞刑架的历程。 好在第二部的结局稍慰人心。","categories":[{"name":"日记","slug":"日记","permalink":"https://kelvinqq.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://kelvinqq.github.io/tags/%E6%97%A5%E8%AE%B0/"},{"name":"吃瓜","slug":"吃瓜","permalink":"https://kelvinqq.github.io/tags/%E5%90%83%E7%93%9C/"}]},{"title":"一次解决依赖库冲突的历程","slug":"一次解决依赖库冲突的历程","date":"2021-08-26T10:15:44.000Z","updated":"2021-09-05T14:36:47.648Z","comments":true,"path":"2021/08/26/一次解决依赖库冲突的历程/","link":"","permalink":"https://kelvinqq.github.io/2021/08/26/%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96%E5%BA%93%E5%86%B2%E7%AA%81%E7%9A%84%E5%8E%86%E7%A8%8B/","excerpt":"早起可以看到不一样的风景，很美的朝霞 盗图自朋友圈 @Sarah 最近在一次gradle同步后，突然编译报错，看一下错误原因，是引用库冲突了，截取信息如下。 12&gt; 1 exception was raised by workers: java.lang.RuntimeException: Duplicate class net.lingala.zip4j.core.HeaderReader found in modules classes.jar (com.tsing.croods.components:croods-cmpt-zip:1.3.8) and zip4j-1.3.2.jar (net.lingala.zip4j:zip4j:1.3.2) 从上面的信息可以看出来，是引用net.lingala.zip4j:zip4j冲突了。 针对这种情况我们可以在gradle中implementation时使用exclude关键词来排除net.lingala.zip4j:zip4j ，但是第一步需要知道到底是哪个库引用到这个库了。 项目中引用的库很多，不可能人工一个一个去排查，好在gradle有为我们提供了这样的指令来查看依赖库。","text":"早起可以看到不一样的风景，很美的朝霞 盗图自朋友圈 @Sarah 最近在一次gradle同步后，突然编译报错，看一下错误原因，是引用库冲突了，截取信息如下。 12&gt; 1 exception was raised by workers: java.lang.RuntimeException: Duplicate class net.lingala.zip4j.core.HeaderReader found in modules classes.jar (com.tsing.croods.components:croods-cmpt-zip:1.3.8) and zip4j-1.3.2.jar (net.lingala.zip4j:zip4j:1.3.2) 从上面的信息可以看出来，是引用net.lingala.zip4j:zip4j冲突了。 针对这种情况我们可以在gradle中implementation时使用exclude关键词来排除net.lingala.zip4j:zip4j ，但是第一步需要知道到底是哪个库引用到这个库了。 项目中引用的库很多，不可能人工一个一个去排查，好在gradle有为我们提供了这样的指令来查看依赖库。 以下指令就是来查找项目中哪些库有依赖到net.lingala.zip4j:zip4j。 1./gradlew :app:dependencyInsight --configuration debugCompileClasspath --dependency net.lingala.zip4j:zip4j 输入指令回车后就会得到以下信息： 12345678910111213141516171819net.lingala.zip4j:zip4j:1.3.2 variant &quot;compile&quot; [ org.gradle.status = release (not requested) org.gradle.usage = java-api org.gradle.category = library (not requested) Requested attributes not found in the selected variant: com.android.build.api.attributes.BuildTypeAttr = debug com.android.build.gradle.internal.dependency.AndroidTypeAttr = Aar ] Selection reasons: - By constraint : debugRuntimeClasspath uses version 1.3.2net.lingala.zip4j:zip4j:&#123;strictly 1.3.2&#125; -&gt; 1.3.2\\--- debugCompileClasspathnet.lingala.zip4j:zip4j:1.3.2\\--- com.tsing.syncdata:syncdata:1.0.1.1-SNAPSHOT:20210825.112636-153 \\--- debugCompileClasspath 从上面的信息就很直观的发现是com.tsing.syncdata:syncdata这个库有依赖net.lingala.zip4j:zip4j。那我们就可以使用exclude关键词了。具体如下： 123implementation(&#x27;com.tsing.syncdata:syncdata:1.0.1.1-SNAPSHOT&#x27;, &#123; exclude group: &#x27;net.lingala.zip4j&#x27;, module: &#x27;zip4j&#x27;&#125;) PS： 如果你想查看所有的依赖树，则需要使用dependencies指令：./gradlew :app:dependencies --configuration debugCompileClasspath 指令前的:app是你的module名 configuration 参数用于指定 variant，例如你还可以传入 releaseCompileClasspath","categories":[{"name":"Android","slug":"Android","permalink":"https://kelvinqq.github.io/categories/Android/"}],"tags":[{"name":"冲突","slug":"冲突","permalink":"https://kelvinqq.github.io/tags/%E5%86%B2%E7%AA%81/"}]},{"title":"Tinker集成踩坑指北","slug":"Tinker集成踩坑指北","date":"2021-08-24T10:06:56.000Z","updated":"2021-08-28T13:06:01.979Z","comments":true,"path":"2021/08/24/Tinker集成踩坑指北/","link":"","permalink":"https://kelvinqq.github.io/2021/08/24/Tinker%E9%9B%86%E6%88%90%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97/","excerpt":"错误一 com.tencent.tinker.android.dex.DexException: Unexpected magic: [100, 101, 120, 10, 48, 51, 56, 0] 这个错误坑了好久，查了官方各种issue，试了N种方法，都不行。如果你也一直找不到原因，试一下修改minSdkVersion&lt;=20。 以下是相关配置供参考： 1234dependencies &#123; classpath &#x27;com.android.tools.build:gradle:3.4.0&#x27; classpath &quot;com.tencent.bugly:tinker-support:1.1.5&quot; &#125;","text":"错误一 com.tencent.tinker.android.dex.DexException: Unexpected magic: [100, 101, 120, 10, 48, 51, 56, 0] 这个错误坑了好久，查了官方各种issue，试了N种方法，都不行。如果你也一直找不到原因，试一下修改minSdkVersion&lt;=20。 以下是相关配置供参考： 1234dependencies &#123; classpath &#x27;com.android.tools.build:gradle:3.4.0&#x27; classpath &quot;com.tencent.bugly:tinker-support:1.1.5&quot; &#125; 错误二 补丁文件缺失必需字段：Created-Time、Created-By、YaPatchType、VersionName、VersionCode、From、To，请检查补丁文件后重试！ 注意，需要上传的patch包是outputs-&gt;patch-&gt;release-&gt;patch_signed_7zip.apk。 如果你传的是outputs-&gt;tinkerPatch目录下的就会报这个错。 如果你没有生成patch包，检查你使用的打包脚本，应该是gradle中的tinker-support-&gt;buildTinkerPatchRelease脚本。用了tinker-&gt;buildTinkerPatchRelease就不会生成patch目录。","categories":[{"name":"Android","slug":"Android","permalink":"https://kelvinqq.github.io/categories/Android/"}],"tags":[{"name":"Tinker","slug":"Tinker","permalink":"https://kelvinqq.github.io/tags/Tinker/"}]},{"title":"杭州共同富裕新示范","slug":"杭州共同富裕新示范","date":"2021-08-22T10:09:26.000Z","updated":"2021-08-31T01:25:49.231Z","comments":true,"path":"2021/08/22/杭州共同富裕新示范/","link":"","permalink":"https://kelvinqq.github.io/2021/08/22/%E6%9D%AD%E5%B7%9E%E5%85%B1%E5%90%8C%E5%AF%8C%E8%A3%95%E6%96%B0%E7%A4%BA%E8%8C%83/","excerpt":"吃瓜杭州市委书记的事情还在发酵，微信群、抖音都在疯传各种消息。 从抖音评论看，最多的是震惊，因为前一天还在出席会议。从侧面也可以看见这次打虎之前的保密性做的很好。 第一天看到新闻的时候，阿里巴巴也从脑海里一闪而过，毕竟也在杭州。 接下来的几天互联网真的开始充斥着各种消息，就在刚刚还看到一篇公众号文章，最后提到了一句蚂蚁金服。 接着很快就收到了同花顺的推送消息，蚂蚁金服发布了声明。相信国家会证明所有人的清白。","text":"吃瓜杭州市委书记的事情还在发酵，微信群、抖音都在疯传各种消息。 从抖音评论看，最多的是震惊，因为前一天还在出席会议。从侧面也可以看见这次打虎之前的保密性做的很好。 第一天看到新闻的时候，阿里巴巴也从脑海里一闪而过，毕竟也在杭州。 接下来的几天互联网真的开始充斥着各种消息，就在刚刚还看到一篇公众号文章，最后提到了一句蚂蚁金服。 接着很快就收到了同花顺的推送消息，蚂蚁金服发布了声明。相信国家会证明所有人的清白。 然而，这一切又和我有什么关系呢？静静的吃瓜~ 蜘蛛纸牌周末抽空又将 蜘蛛纸牌 for macOS Release 了一个版本，新增了些许功能： 优化了游戏背景图 新增快捷方式开始牌局，你可以使用⌘+1/2/3分别开始新的一局初级/中级/高级 新增版本更新检测 自己在测试的时候发现，4色的好难，后来想想，很有可能原本就是无解的牌局。 所以准备收集一下解局成功的牌局上传到服务器，然后新增以可解牌局开始游戏。 点击这里可以去GitHub下载最新版本。","categories":[{"name":"日记","slug":"日记","permalink":"https://kelvinqq.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://kelvinqq.github.io/tags/%E6%97%A5%E8%AE%B0/"},{"name":"吃瓜","slug":"吃瓜","permalink":"https://kelvinqq.github.io/tags/%E5%90%83%E7%93%9C/"}]},{"title":"安利一个颜值最高的GitHub小程序","slug":"安利一个颜值最高的GitHub小程序","date":"2019-09-21T12:22:33.000Z","updated":"2021-09-11T03:33:26.397Z","comments":true,"path":"2019/09/21/安利一个颜值最高的GitHub小程序/","link":"","permalink":"https://kelvinqq.github.io/2019/09/21/%E5%AE%89%E5%88%A9%E4%B8%80%E4%B8%AA%E9%A2%9C%E5%80%BC%E6%9C%80%E9%AB%98%E7%9A%84GitHub%E5%B0%8F%E7%A8%8B%E5%BA%8F/","excerpt":"图片来自 泼辣有图","text":"图片来自 泼辣有图 作为一个码农，平时少不了要逛一逛GitHub（一个号称全球最大的同性交友网站）。 作为一个代码托管网站，他早已经超出了他的职责。 我们可以找到一些需要用到的开源库； 我们可以看到一些组织/个人的技术分享文章； 我们可以找到一些有趣的收集资料； … 但是，在这个移动设备如此受欢迎的今天，GitHub竟然没有推出App，就算是码农，也不能整天都带着电脑啊。 好在GitHub提供了Open API供大家使用，让程序猿们自己解决。今天就给大家安利一个颜值最高的GitHub小程序 ———— Gitter。 该小程序已经支持以下功能： 实时查看Trending 显示用户列表 仓库和用户的搜索 仓库：详情展示、README.md展示、Star/Unstar、Fork、Contributors展示、查看仓库文件内容 开发者：Follow/Unfollow、显示用户的followers/following Issue：查看issue列表、新增issue、新增issue评论 分享仓库、开发者 … 不过由于微信小程序的限制，无法做OAuth认证，所以想要登录自己的账户稍微有点复杂： 跳转获取Token链接：https://github.com/settings/tokens/new，并使用个人账户密码登录 填写一个标签，勾选自己想要授权的功能清单后并授权，就可以获得一个Token 复制Token并填写到小程序中，即可登录个人账户 作者本着开源的精神，将整个项目源码同时放在了GitHub中，供大家学习讨论。整个项目采用 Taro 框架 + Taro UI 进行开发，小程序内数据均来自于 GitHub Api v3。并写了一篇文章来记录该小程序的开发过程：Gitter - 高颜值GitHub小程序客户端诞生记，真的是可玩、可学。 说了这么多，赶紧放几张颜值照片上来： 是不是很清爽呢？那就长按识别一下下方的小程序码赶紧使用吧。 对了，还有作者2k+标星的repo： https://github.com/huangjianke/Gitter 啊啊啊","categories":[{"name":"源码推荐","slug":"源码推荐","permalink":"https://kelvinqq.github.io/categories/%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://kelvinqq.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"生活不止眼前的苟且还有诗和远方的田野","slug":"生活不止眼前的苟且还有诗和远方的田野","date":"2019-09-20T12:49:14.000Z","updated":"2021-09-11T03:33:26.398Z","comments":true,"path":"2019/09/20/生活不止眼前的苟且还有诗和远方的田野/","link":"","permalink":"https://kelvinqq.github.io/2019/09/20/%E7%94%9F%E6%B4%BB%E4%B8%8D%E6%AD%A2%E7%9C%BC%E5%89%8D%E7%9A%84%E8%8B%9F%E4%B8%94%E8%BF%98%E6%9C%89%E8%AF%97%E5%92%8C%E8%BF%9C%E6%96%B9%E7%9A%84%E7%94%B0%E9%87%8E/","excerpt":"图片来自 泼辣有图","text":"图片来自 泼辣有图 中华文化，源远流长。古诗词文化最早可以追溯到三千多年前的《诗经》。 蒹葭苍苍，白露为霜。所谓伊人，在水一方。 作为中华文化的瑰宝，我们应该传承下去。然而一方面，古诗词文集的庞大使之与我们有一定的距离；另一方面，在这个人人机不离手的时代，早已经将古典文集抛之脑后。 为了让古诗词文化更好地适应移动互联网时代，更好的传承下去，项目作者整理了这个repo，让更多的人可以加入到古诗词文化的传播行列中。 目前这个repo已经收录了唐宋两朝近1.4万古诗人, 接近5.5万首唐诗加26万首宋诗. 两宋时期1564位词人，21050首词，号称最全中华古诗词数据库。目前该项目已经有20k+的star，由此可见，热爱古诗词的人还是有很多的。 项目中的古诗词数据最终是通过JSON格式分发，使得任何人可以更方便的使用，衍生出古诗词相关的产品，例如：古诗词网站、移动端应用、小程序等。目前通过该项目衍生的产品已经有如下： 中文诗歌主页是一个基于浏览器的诗词网站， 包含唐诗三百首、宋词三百首等文集. animalize / QuanTangshi 离线全唐诗 Android justdark / pytorch-poetry-gen a char-RNN based on pytorch Clover27 / ancient-Chinese-poem-generator Ancient-Chinese-Poem-Generator chinese-poetry / poetry-calendar 诗词周历 chenyuntc / pytorch-book 简体唐诗生成(char-RNN), 可生成藏头诗,自定义诗歌意境,前缀等 okcy1016 / poetry-desktop 诗词桌面 huangjianke / weapp-poem 诗词墨客 小程序版 如果你也对诗词感兴趣，也可以加入到该项目中，贡献一份自己的力量。 https://github.com/chinese-poetry/chinese-poetry 如果你有一个好的产品想法，赶紧下载并使用该项目中的数据，动手实现你的产品，加入到传播诗词文化的行列中。 如果你觉得自己只想赞助，那可以直接赞助给下方的二维码，留下你的联系方式，资金会直接进入repo作者的账户。 最后，给大家展示一下作者整理的高频词分析图： 宋词高频词 唐诗高频词 宋诗高频词","categories":[{"name":"源码推荐","slug":"源码推荐","permalink":"https://kelvinqq.github.io/categories/%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90/"}],"tags":[{"name":"古诗","slug":"古诗","permalink":"https://kelvinqq.github.io/tags/%E5%8F%A4%E8%AF%97/"}]},{"title":"GitHub标星14k+，这个项目既能学Python又能抢票","slug":"GitHub标星14k+，这个项目既能学Python又能抢票","date":"2019-09-18T11:32:39.000Z","updated":"2021-09-11T03:33:26.396Z","comments":true,"path":"2019/09/18/GitHub标星14k+，这个项目既能学Python又能抢票/","link":"","permalink":"https://kelvinqq.github.io/2019/09/18/GitHub%E6%A0%87%E6%98%9F14k+%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%97%A2%E8%83%BD%E5%AD%A6Python%E5%8F%88%E8%83%BD%E6%8A%A2%E7%A5%A8/","excerpt":"图片来自 泼辣有图 By yaojinm5","text":"图片来自 泼辣有图 By yaojinm5 是不是每一次计划好的远行最终都因为一张火车票而终止？是不是每一次抢票都要发动朋友圈帮你加速？是不是每一次买票都是交给黄牛一笔服务费？这个项目告诉你，程序猿是如何抢票的。 项目地址： https://github.com/testerSunshine/12306 功能盘点目前该项目已经支持以下功能： 自动打码 自动登录 准点预售和捡漏 智能候补 邮件通知 server酱通知 项目使用项目作者在README中详细介绍了整个项目的搭建方法，按照教程一步一步来，你一定可以搭建成功。另外作者还整理了一些项目搭建和使用过程中遇到的一些常见问题，可谓是用心良苦。 项目学习作为一个合格的开源项目，除了可供大家使用，作者还提供给大家共同学习的机会。 作者把整个项目的思路画了出来，帮助大家更好的理解项目源码。 作者创建了一堆的QQ群，供大家学习交流。由于项目太过火爆，目前只有8群尚未满员: 620629239 。 看到这里，你是不是已经跃跃欲试了呢？赶紧去仓库下载学习吧~ 补充一个server酱的文档地址：http://sc.ftqq.com/3.version","categories":[{"name":"源码推荐","slug":"源码推荐","permalink":"https://kelvinqq.github.io/categories/%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://kelvinqq.github.io/tags/Github/"}]},{"title":"GitHubWeekly-20190921","slug":"GitHubWeekly-20190921","date":"2019-09-14T09:20:26.000Z","updated":"2021-09-11T03:33:26.395Z","comments":true,"path":"2019/09/14/GitHubWeekly-20190921/","link":"","permalink":"https://kelvinqq.github.io/2019/09/14/GitHubWeekly-20190921/","excerpt":"图片来自 泼辣有图 By 神奈川冲浪李","text":"图片来自 泼辣有图 By 神奈川冲浪李 next一套企业级中后台UI的解决方案，致力于解决设计师与前端在工作协同、产品体验一致性、开发效率方面的问题。 项目地址： https://github.com/alibaba-fusion/next","categories":[{"name":"源码推荐","slug":"源码推荐","permalink":"https://kelvinqq.github.io/categories/%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://kelvinqq.github.io/tags/Github/"}]},{"title":"GitHub Weekly-20190913","slug":"GitHub-Weekly-20190913","date":"2019-09-13T09:54:15.000Z","updated":"2021-09-11T03:33:26.395Z","comments":true,"path":"2019/09/13/GitHub-Weekly-20190913/","link":"","permalink":"https://kelvinqq.github.io/2019/09/13/GitHub-Weekly-20190913/","excerpt":"图片来自 泼辣有图 By 神奈川冲浪李","text":"图片来自 泼辣有图 By 神奈川冲浪李 Starscream一个使用Swift编写的WebSocket(RFC 6455)库，支持iOS 和 MacOS。支持delegate和closures。 项目地址： https://github.com/daltoniam/Starscream mallmall项目致力于打造一个完整的电商系统，采用现阶段流行技术实现，包括前台商城系统及后台管理系统，基于SpringBoot+MyBatis实现。 前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。 后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。 项目演示地址： http://39.98.190.128/index.html 项目地址： https://github.com/macrozheng/mall OpenArkCompilerOpenArkCompiler 是来自华为方舟编译器的开源项目。面向多设备、支持多语言的统一编程平台。 项目地址： https://gitee.com/harmonyos/OpenArkCompiler 项目主页： https://www.openarkcompiler.cn/home baidu-netdisk-downloaderx是否还在为百度网盘下载限速发愁？那这一款项目绝对可以尝试一下。BND 是一款图形界面的百度网盘不限速下载器，支持 Windows、Linux 和 Mac。 项目地址： https://github.com/b3log/baidu-netdisk-downloaderx HanLPHanLP(Han Language Processing)是一系列模型与算法组成的NLP工具包，由大快搜索主导并完全开源，目标是普及自然语言处理在生产环境中的应用。HanLP具备功能完善、性能高效、架构清晰、语料时新、可自定义的特点。 项目地址： https://github.com/hankcs/HanLP 1这个缩写也是很Chinglish了。 LookinLookin 是一款 macOS 软件，它可以查看与修改 iOS App 里的 UI 对象，类似于 Xcode 自带的 UI Inspector 工具，或另一款叫做 Reveal 的软件。 https://lookin.work/ 1免费的 Reveal 软件，良心之作。","categories":[{"name":"源码推荐","slug":"源码推荐","permalink":"https://kelvinqq.github.io/categories/%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://kelvinqq.github.io/tags/Github/"}]},{"title":"利用Xcode修改iPhone定位","slug":"利用Xcode修改iPhone定位","date":"2019-01-30T12:28:52.000Z","updated":"2021-08-27T13:34:42.827Z","comments":true,"path":"2019/01/30/利用Xcode修改iPhone定位/","link":"","permalink":"https://kelvinqq.github.io/2019/01/30/%E5%88%A9%E7%94%A8Xcode%E4%BF%AE%E6%94%B9iPhone%E5%AE%9A%E4%BD%8D/","excerpt":"图片来自 泼辣有图 By sleepyeyes 写这个话题，自然让人想到会利用这个技术去做一些不是很明亮的事情哈哈，这个不在我们今天的讨论之中，我只提供一些技术，如有任何后果，我不承担任何责任","text":"图片来自 泼辣有图 By sleepyeyes 写这个话题，自然让人想到会利用这个技术去做一些不是很明亮的事情哈哈，这个不在我们今天的讨论之中，我只提供一些技术，如有任何后果，我不承担任何责任 0x00 准备工具 一台装了Xcode的Mac电脑 一台iPhone(无需越狱) 一根数据线 0x01 坐标选取手机的定位是利用GPS来获取当前位置的经纬度信息的，手机App最终都是根据经纬度信息来判断当前位置是否在合理的区域内。所以我们首先需要知道，合理位置的经纬度是多少。 获取经纬度的工具有许多，高德、百度、谷歌都可以，这里我们以高德为例，打开网址后，利用关键字搜索到位置的经纬度如下： 得到经纬度信息 120.026208,30.279212 0x02 编写代码 打开Xcode，新建一个工程。 新建一个gpx文件，内容如下，并添加到工程。 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;gpx version=&quot;1.1&quot; creator=&quot;GMapToGPX 6.4j - http://www.elsewhere.org/GMapToGPX/&quot; xmlns=&quot;http://www.topografix.com/GPX/1/1&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd&quot;&gt; &lt;wpt lat=&quot;30.279212&quot; lon=&quot;120.026208&quot;&gt; &lt;/wpt&gt;&lt;/gpx&gt; 记得把经纬度替换为上一步从高德网页获取到的。 0x03 配置工程 在Xcode项目中，选择Edit Scheme...，然后选择Run-&gt;Options-&gt;Core Location。 选中Allow Location Simulation，并在下方的Defalut Location中选择刚刚新建的gps.gpx文件，如下图。 0x04 大功告成连接手机，运行你的程序。由于没有写任何iOS相关代码，所以应该是一片白屏。不要在意这个。 不要停止你的程序，直接退到后台，然后打开你的高德地图，你发现你的位置就在阿里巴巴了。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"定位","slug":"定位","permalink":"https://kelvinqq.github.io/tags/%E5%AE%9A%E4%BD%8D/"}]},{"title":"两个Bug引发的阴谋论","slug":"两个Bug引发的阴谋论","date":"2019-01-30T12:12:47.000Z","updated":"2021-09-05T14:31:40.331Z","comments":true,"path":"2019/01/30/两个Bug引发的阴谋论/","link":"","permalink":"https://kelvinqq.github.io/2019/01/30/%E4%B8%A4%E4%B8%AABug%E5%BC%95%E5%8F%91%E7%9A%84%E9%98%B4%E8%B0%8B%E8%AE%BA/","excerpt":"图片来自 泼辣有图 By Dominic 0x00先说第一个事情。1月24日上午，微信出现大面积Bug。 10:30开始，有网友表示，微信疑似出现Bug，从其他App分享内容给个人/微信群，均无法正常分享，此外发送图片、文档、登陆网页版微信也短暂出现故障。","text":"图片来自 泼辣有图 By Dominic 0x00先说第一个事情。1月24日上午，微信出现大面积Bug。 10:30开始，有网友表示，微信疑似出现Bug，从其他App分享内容给个人/微信群，均无法正常分享，此外发送图片、文档、登陆网页版微信也短暂出现故障。 微信作为第一社交软件，顿时上了热搜。就连腾讯集团公关总监张军都公开在其朋友圈表示：“微信bug正在紧急修复中，大家稍等，抱歉。” 此次宕机大约持续了大约20分钟，影响了公众号、支付、搜索、小程序等功能的正常使用，但据微信方面回应，相关账号信息无影响。在10:50的时候开始陆续恢复社交功能。 随后张军又在其朋友圈调侃了一番：“感觉像是给攻城狮敲了一记醒神棒，哪怕快过年了也别想放松。” 从这个事件可以看出三点： 在这个离不开手机的年代，大家也渐渐离不开微信。只是大约20分钟的宕机，在网上就沸沸扬扬，微信真是稳坐社交第一把交椅。 微信团队对Bug的处理速度之快令人咂舌。从问题上报、分析定位、解决、测试、上线，一套流程走下来竟然只有大约20分钟。 此次事件是微信后端服务出了问题，可能是新上线或修改了某个服务导致的，所以客户端并不需要重新更新。 0x01再说第二个事情。1月22日19时，大量抖音新用户反馈，无法使用微信授权方式登录、使用抖音。 抖音团队也是第一时间来定位分析，不过结果并不乐观。可以确定是微信屏蔽了抖音的微信授权。后来有媒体表示，据“微信内部人士”回应：因为抖音获取微信好友信息，涉及泄漏用户隐私，所以屏蔽了抖音。对于这个不想做过多的评价。 0x02头腾之战从未停歇。字节跳动靠今日头条起家，又因抖音大火了一把。而后又开始涉及社交领域，双方之争愈演愈烈。 最开始，微信封杀来自抖音分享到朋友圈的视频连接； 今年1月15日，微信屏蔽多闪的下载连接； 今年1月19日，微信又屏蔽了字节跳动域名（bytedance.com）； 1月22日，微信屏蔽抖音的微信登录授权； 腾讯和字节跳动之战已经进入白热化。在这场战争中，我不去评判到底谁对谁错。或许在这商业竞争之中，又岂有对错之分？ 0x03事情说完之后，回头再回顾一下两件事情： 1月22日，微信屏蔽抖音的微信授权； 1月24日，微信被爆出史诗级Bug，社交功能宕机。 这其中很是令人回味。 这自然只是我的一番阴谋论，毕竟张军没有公布为什么微信会宕机，只是调侃了攻城狮一番。 往期精选▼1. Flutter初体验 2. 为什么我觉得Flutter短期内不会流行但依然选择学习它 3. 说两个知识点 4. 在小程序中集成赞赏","categories":[{"name":"日记","slug":"日记","permalink":"https://kelvinqq.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"疯言疯语","slug":"疯言疯语","permalink":"https://kelvinqq.github.io/tags/%E7%96%AF%E8%A8%80%E7%96%AF%E8%AF%AD/"}]},{"title":"使用LeanCloud快速开发一款小程序","slug":"使用LeanCloud快速开发一款小程序","date":"2019-01-26T06:03:04.000Z","updated":"2021-08-27T13:34:42.826Z","comments":true,"path":"2019/01/26/使用LeanCloud快速开发一款小程序/","link":"","permalink":"https://kelvinqq.github.io/2019/01/26/%E4%BD%BF%E7%94%A8LeanCloud%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E5%B0%8F%E7%A8%8B%E5%BA%8F/","excerpt":"前言开发小程序离不开后台数据，对于独立开发者来说，既要写前端，又要写后端，工作量就会骤然增大。微信提供的云开发无疑是给独立开发者提供了很大的便利，但是由于其数据库不支持联表查询，对于某些场景就不是那么的友好了。当然，市面上有很多的BaaS服务提供商，大都类似，今天我们就用其中的一个LeanCloud来讲解一下，如何快速使用LeanCloud来开发一个小程序。由于本次重点在LeanCloud，所以小程序的开发内容就不是重点。","text":"前言开发小程序离不开后台数据，对于独立开发者来说，既要写前端，又要写后端，工作量就会骤然增大。微信提供的云开发无疑是给独立开发者提供了很大的便利，但是由于其数据库不支持联表查询，对于某些场景就不是那么的友好了。当然，市面上有很多的BaaS服务提供商，大都类似，今天我们就用其中的一个LeanCloud来讲解一下，如何快速使用LeanCloud来开发一个小程序。由于本次重点在LeanCloud，所以小程序的开发内容就不是重点。 现在开始 先去https://leancloud.cn官网注册一个账号，然后登录去控制台创建一个新应用。 在微信小程序后台中配置域名白名单，具体需要按照这里说明的来配置，你也可以先跳过这一步，等完全开发完毕后再来配置。可在开发者工具的 详情 &gt; 项目设置 中勾选不校验安全域名、TLS 版本以及 HTTPS 证书。 下载你熟悉的SDK，目前支持JS，WePY，mpvue，下载链接在这里，后面以JS来说明，其他方式的SDK导入以及使用方法参考文档中的说明。 初始化SDK，在app.js中加入以下代码即可。appId和appKey可以在控制台中的应用找到。123456const AV = require(&#x27;./utils/av-live-query-weapp-min&#x27;);AV.init(&#123; appId: &#x27;换成你自己的appId&#x27;, appKey: &#x27;换成你自己的appKey&#x27;,&#125;); 查询数据先需要在控制台中的应用下新建一个表，在网页中叫做Class。每一张表会默认创建objectId、createdAt、updatedAt、ACL四个字段，分别表示数据索引，创建时间，更新时间、权限。你可以添加你想要的字段，目前支持以下几种类型。 其中Object是map对象，GeoPoint是经纬度信息，Pointer是另外一张表的表名，做多表联合查询使用的。假设我们的表名是T_TODO，我们可以用以下代码来查询该表下面的数据。 12345678910new AV.Query(&#x27;T_TODO&#x27;) .descending(&#x27;createdAt&#x27;) // 排序 .limit(10) // 分页数量 .skip(10) // 跳过数量 .find() .then(function(results) &#123; that.setData(&#123;todo: results&#125;) &#125;) .catch(console.error); &#125; 在你的WXML中可以这样写来做数据绑定： 123456 &lt;!-- pages/todos/todos.wxml --&gt;&lt;block wx:for=&quot;&#123;&#123;todos&#125;&#125;&quot; wx:for-item=&quot;todo&quot; wx:key=&quot;objectId&quot;&gt; &lt;text data-id=&quot;&#123;&#123;todo.objectId&#125;&#125;&quot;&gt; &#123;&#123;todo.content&#125;&#125; &lt;/text&gt;&lt;/block&gt;是不是很方便。 多表查询如果需要多多表查询，先要在一张表中新建一个Pointer字段，新建时会让你选择指向的表名，如下图所示：然后在查询是使用include，就会返回关联表中的所有信息了，如下所示：1234567891011new AV.Query(&#x27;T_TODO&#x27;) .descending(&#x27;createdAt&#x27;) // 排序 .limit(10) // 分页数量 .skip(10) // 跳过数量 .include(&#x27;T_POINT_CLASS&#x27;) .find() .then(function(results) &#123; that.setData(&#123;todo: results&#125;) &#125;) .catch(console.error); &#125; 更新对象小程序中对表中字段做操作后，需要同步更新到服务端，可以使用以下代码来保存对象。123456// 第一个参数是 className，第二个参数是 objectIdvar todo = AV.Object.createWithoutData(&#x27;Todo&#x27;, &#x27;5745557f71cfe40068c6abe0&#x27;);// 修改属性todo.set(&#x27;content&#x27;, &#x27;每周工程师会议，本周改为周三下午3点半。&#x27;);// 保存到云端todo.save(); 其他更多的操作请查看文档，不过你找不到小程序对应的详细开发文档，只能找到数据存储开发指南 · JavaScript 广告时间三国图鉴是我业余时间开发的查询三国杀武将技能以及官方活动的小程序，后台服务就是由LeanCloud提供的，请大家多多关照。如果有其他问题，你可以关注我的公众号来联系我。 扫码体验小程序","categories":[{"name":"小程序","slug":"小程序","permalink":"https://kelvinqq.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://kelvinqq.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"LeanCloud","slug":"LeanCloud","permalink":"https://kelvinqq.github.io/tags/LeanCloud/"}]},{"title":"在小程序中集成赞赏","slug":"在小程序中集成赞赏","date":"2019-01-26T06:01:45.000Z","updated":"2021-08-27T13:34:42.827Z","comments":true,"path":"2019/01/26/在小程序中集成赞赏/","link":"","permalink":"https://kelvinqq.github.io/2019/01/26/%E5%9C%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E9%9B%86%E6%88%90%E8%B5%9E%E8%B5%8F/","excerpt":"阅读本文大概需要3分钟。 好吧，我承认我标题党了，如果你是进来找如何搭建小程序中的支付流程的，请你下车吧~ 这篇文章是介绍个人小程序如何集成赞赏功能的，利用微信小程序提供的支付接口必须具有公司资质才可以。或者你也可以集成有赞，不过会抽取一定的手续费。","text":"阅读本文大概需要3分钟。 好吧，我承认我标题党了，如果你是进来找如何搭建小程序中的支付流程的，请你下车吧~ 这篇文章是介绍个人小程序如何集成赞赏功能的，利用微信小程序提供的支付接口必须具有公司资质才可以。或者你也可以集成有赞，不过会抽取一定的手续费。 言归正传，让我们一步一步来集成赞赏吧，让那些喜欢你的用户也可以打赏你一下。 生成一个赞赏码。打开微信，点击右上角加号-&gt;收付款-&gt;赞赏码，这里你可以进行一些赞赏设置，然后点击保存赞赏码。这样你就拥有了你专属的赞赏码了。 获取一个图片地址 如果你有服务器或者其他的存储空间，你可以把你的赞赏码上传到你的存储空间，然后拿到图片的htts地址，后面会用到。 如果你没有，那么还可以利用小程序给我们提供的免费的云开发。下面先来说一下如何将图片上传到云存储中。 打开小程序开发工具，找到云开发后点击，如果你没有开通，则会提示你开通，需要在控制台中开通，路径是：开发-&gt;开发者设置-&gt;腾讯云。 开通后再点击云开发，打开控制台，找到存储管理-&gt;上传文件,上传上一步你的专属赞赏码图片。上传完成后，就能看到文件了，将fileid字段复制下来，后面会用到。 图片预览这一步需要根据实际情况分开来处理了，下面针对上一步说的两种形式一一讲解。 1. 使用其他云存储拿到图片的https链接后，在你的小程序wxml添加一个打赏的按钮，然后给按钮添加如下点击事件： 123wx.previewImage(&#123; urls: [&#x27;https://xxxxx/admire-qrcode.jpg&#x27;],&#125;); 写到这里相信大家应该就很清楚了，不错，我们就是利用微信的图片预览功能来加载网络图片。当加载出预览大图二维码后，用户就可以长按识别二维码，弹出微信的识别图中二维码功能，最终跳转到微信自带的赞赏页面，是不是很赞呢~ 2. 使用云开发存储使用云开发存储的思路是一致的，只不过需要在代码中初始化一些云开发环境。 初始化云开发在app.js中加入如下代码进行初始化：12345onLaunch: function() &#123; wx.cloud.init(&#123; traceUser: true &#125;);&#125; 添加按钮点击事件点击事件中传入的url就是第二步获取到的fileid。12345previewImage: function() &#123; wx.previewImage(&#123; urls: [&#x27;cloud://carutil-007.6361-carutil-007/admire-qrcode.jpg&#x27;], &#125;); &#125;, 大功告成，最终效果如下图所示。 你可以扫描下方的小程序码来体验该功能，在首页最底部有个打赏按钮~ 也可以扫码赞赏~","categories":[{"name":"小程序","slug":"小程序","permalink":"https://kelvinqq.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://kelvinqq.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"赞赏","slug":"赞赏","permalink":"https://kelvinqq.github.io/tags/%E8%B5%9E%E8%B5%8F/"}]},{"title":"从两道面试题说起","slug":"从两道面试题说起","date":"2019-01-26T05:58:34.000Z","updated":"2021-08-27T13:34:42.826Z","comments":true,"path":"2019/01/26/从两道面试题说起/","link":"","permalink":"https://kelvinqq.github.io/2019/01/26/%E4%BB%8E%E4%B8%A4%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%B4%E8%B5%B7/","excerpt":"iOS 中是否存在野指针的情况？野指针野指针指向一个已删除的对象或未申请访问受限内存区域的指针。特别要指出的是野指针不是空指针。 Block一提到 Block 大家肯定都知道要说的是循环引用。在 ARC 中，如果两个对象相互持有对方，就会造成循环引用，导致内存无法释放。在 Block 中，最常用的场景则是，self 持有 block ， block 中又持有了 self 。例如下方一段代码：","text":"iOS 中是否存在野指针的情况？野指针野指针指向一个已删除的对象或未申请访问受限内存区域的指针。特别要指出的是野指针不是空指针。 Block一提到 Block 大家肯定都知道要说的是循环引用。在 ARC 中，如果两个对象相互持有对方，就会造成循环引用，导致内存无法释放。在 Block 中，最常用的场景则是，self 持有 block ， block 中又持有了 self 。例如下方一段代码： 123456789@property (nonatmaic, copy) Block dataChanged;- (void)setUpModel&#123; XYModel *model = [XYModel new]; model.dataChanged = ^(NSString *title) &#123; self.titleLabel.text = title; &#125;; self.model = model;&#125; 上面的这段代码就会造成循环引用。那我们怎么破除呢？通常的做法都是使用 weakSelf 来处理，即： 12345678- (void)setUpModel &#123; XYModel *model = [XYModel new]; __weak typeof(self) weakSelf = self; model.dataChanged = ^(NSString *title) &#123; weakSelf.titleLabel.text = title; &#125;; self.model = model;&#125; 或许你还看到另外一种不是很一样的版本： 123456789- (void)setUpModel &#123; XYModel *model = [XYModel new]; __weak typeof(self) weakSelf = self; model.dataChanged = ^(NSString *title) &#123; __strong typeof(self) strongSelf = weakSelf; strongSelf.titleLabel.text = title; &#125;; self.model = model;&#125; 对比一下，多了一个 strongSelf 。那为什么又要多加一个 strongSelf 呢？ 考虑一下下面的代码， 12345__weak __typeof__(self) weakSelf = self;dispatch_group_async(_operationsGroup, _operationsQueue, ^&#123; [weakSelf doSomething]; [weakSelf doSomethingElse];&#125;); 在 doSomething 时， weakSelf 不会被释放，但是在 doSomethingElse 时，weakSelf 有可能被释放。 这个时候就遇到了野指针问题，回答了一开始的题目。 在这里就需要用到 strongSelf ，使用 __strong 确保在 Block 内， strongSelf 不会被释放。 小结 在使用 Block 时，如遇到循环引用问题，可以使用 __weak 来破除循环引用。 如果在 Block 内需要多次访问 __weak 变量，则需要使用 __strong 来保持变量不会被释放。 SDWebImage 中为什么要解码图片要说明这么问题我们需要先了解一下在 iOS 中，图片显示的流程。 概括来说，从磁盘中加载一张图片，并将它显示到屏幕上，中间的主要工作流如下： 假设我们使用 imageWithContentsOfFile: 方法从磁盘中加载一张图片，这个时候的图片并没有解压缩； 然后将生成的 UIImage 赋值给 UIImageView ； 接着一个隐式的 CATransaction 捕获到了 UIImageView 图层树的变化； 在主线程的下一个 run loop 到来时，Core Animation 提交了这个隐式的 transaction ，这个过程可能会对图片进行 copy 操作，而受图片是否字节对齐等因素的影响，这个 copy 操作可能会涉及以下部分或全部步骤： 分配内存缓冲区用于管理文件 IO 和解压缩操作； 将文件数据从磁盘读到内存中； 将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作； 最后 Core Animation 使用未压缩的位图数据渲染 UIImageView 的图层。 在上面的步骤中，我们提到了图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。那么当需要加载的图片比较多时，就会对我们应用的响应性造成严重的影响，尤其是在快速滑动的列表上，这个问题会表现得更加突出。 这里顺便提一下 imageNamed: 和 imageWithContentsOfFile: 的区别，这两个 API 都需要解码，并且工作流程都是一致的。不过imageNamed:会做缓存处理，在下一次用到相同的资源时，就会从缓存里面读取。而 imageWithContentsOfFile: 则不会。所以网上大多文章都会告诉你，多次使用的小图片使用 imageNamed: 加载，一次性使用的大图片使用 imageWithContentsOfFile: 加载。 对于上面引用的流程中最后提到，当有大量图片滑动时就会造成主线程的卡顿，原因就是解码图片在主线程中操作的。那有什么办法避免呢？我在查询关于这个问题的相关资料时，发现有些博客给出了2种方案： 我们不使用imageNamed:加载图片，使用其他的方法，比如imageWithContentsOfFile: 我们自己解码图片，可以把这个解码过程放到子线程 其实第一种方式没法避免卡顿。这就引出了为什么 SDWebImage中需要自己解码图片。 在我们使用 UIImage 的时候，创建的图片通常不会直接加载到内存，而是在渲染的时候再进行解压并加载到内存。这就会导致 UIImage 在渲染的时候效率上不是那么高效。为了提高效率通过 decodedImageWithImage 方法把图片提前解压加载到内存，这样这张新图片就不再需要重复解压了，提高了渲染效率。这是一种空间换时间的做法。 参考文章： 到底什么时候才需要在ObjC的Block中使用weakSelf/strongSelf 浮生猎趣 谈谈 iOS 中图片的解压缩 雷纯锋的技术博客 SDWebImage源码解析（三）——SDWebImage图片解码/压缩模块 SHY圆圆圈圈圆圆","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/tags/iOS/"},{"name":"面试","slug":"面试","permalink":"https://kelvinqq.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Flutter初体验","slug":"Flutter初体验","date":"2019-01-26T05:55:40.000Z","updated":"2021-08-27T13:34:42.820Z","comments":true,"path":"2019/01/26/Flutter初体验/","link":"","permalink":"https://kelvinqq.github.io/2019/01/26/Flutter%E5%88%9D%E4%BD%93%E9%AA%8C/","excerpt":"在我的iPhone 8上，列表滑动还是比较卡的。 用VS Code好像代码提示不够智能。 嵌套是真的醉了。 开发环境搭建 这里介绍的是Mac平台下的开发环境搭建，使用的IDE是VS Code。如果你使用的是Windows或Linux，可以查看Flutter中文网上的介绍。","text":"在我的iPhone 8上，列表滑动还是比较卡的。 用VS Code好像代码提示不够智能。 嵌套是真的醉了。 开发环境搭建 这里介绍的是Mac平台下的开发环境搭建，使用的IDE是VS Code。如果你使用的是Windows或Linux，可以查看Flutter中文网上的介绍。 安装Flutter1234git clone -b beta https://github.com/flutter/flutter.gitexport PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置export PATH=`pwd`/flutter/bin:$PATH 上面在命令行中设置的环境变量，只是针对当前的会话。所以我们需要将他们写道系统配置中。 open $HOME/.bash_profile 如果目录下不存在改文件，则手动创建一个。然后将下面的代码粘贴进去： 123export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置export PATH=PATH_TO_FLUTTER_GIT_DIRECTORY/flutter/bin:$PATH 其中PATH_TO_FLUTTER_GIT_DIRECTORY是你clone的flutter的目录，需要你自己替换掉。 运行source $HOME/.bash_profile。 注意: 如果你使用的是zsh，终端启动时 ~/.bash_profile 将不会被加载，解决办法就是修改 ~/.zshrc ，在其中添加：source ~/.bash_profile iOS设置1234brew updatebrew install --HEAD libimobiledevicebrew install ideviceinstaller ios-deploy cocoapodspod setup 如果你之前没有用过cocoapods，需要设置一下镜像。命令行中运行： 1gem sources -l 查看当前使用的RubyGems源。 1gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/ 后面的--remove附带的参数将上一步查看到的源写上，然后再查看一下RubyGems源是否正确，确保如下所示： 1234$ gem sources -l*** CURRENT SOURCES ***https://gems.ruby-china.com/ 如果还有其他关于RubyGems的问题，可以到 https://gems.ruby-china.com/ 获得帮助。 配置VS Code 安装VS Code 你可以去官网下载，然后安装。这里是传送门。 安装Flutter插件。 打开后，点击左边侧边栏的插件按钮，搜索Flutter插件。第一个就是Flutter，安装Flutter同时会安装Dart插件，等安装完毕后，再reload一下就可以了。 第一个Flutter工程打开你的VS Code，View-&gt;Command Palette，输入flutter并选择Flutter: New Project，输入一个工程名，就叫hello_flutter吧。 名称只能是小写字母和下划线，是不是很变态啊。 回车后选择一个目录，工程就创建好了。 在VS Code下方的输出区域，给我们提供了TERMINAL功能，连接你的手机，在TERMINAL中敲下flutter run，就会看到正在编译了。完成后，就能在手机上看到你的第一个flutter应用了。 这里需要先配置Xcode以及证书相关。 至此，你就可以开启你的flutter之旅了。你可以按照这篇文章来修改你的工程，创建一个列表来体验。 参考文章 Flutter中文网 Flutter不一样的跨平台解决方案","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://kelvinqq.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://kelvinqq.github.io/tags/Flutter/"}]},{"title":"小程序利用Canvas绘制图片和竖排文字","slug":"小程序利用Canvas绘制图片和竖排文字","date":"2018-05-14T13:53:44.000Z","updated":"2021-09-05T14:37:59.649Z","comments":true,"path":"2018/05/14/小程序利用Canvas绘制图片和竖排文字/","link":"","permalink":"https://kelvinqq.github.io/2018/05/14/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%88%A9%E7%94%A8Canvas%E7%BB%98%E5%88%B6%E5%9B%BE%E7%89%87%E5%92%8C%E7%AB%96%E6%8E%92%E6%96%87%E5%AD%97/","excerpt":"引言闲暇时间抽个空写了个三国杀武将手册的小程序，中间有个需求设计的是合成武将皮肤图、竖排的武将姓名、以及小程序码，然后提供保存图片到相册，最终让用户可以分享到朋友圈或其他平台。合成图片应该按照Canvas的文档来做都没什么问题，主要是有个竖排文字的需求，这里和大家分享一下。","text":"引言闲暇时间抽个空写了个三国杀武将手册的小程序，中间有个需求设计的是合成武将皮肤图、竖排的武将姓名、以及小程序码，然后提供保存图片到相册，最终让用户可以分享到朋友圈或其他平台。合成图片应该按照Canvas的文档来做都没什么问题，主要是有个竖排文字的需求，这里和大家分享一下。 广告宣传一下自己的小程序，有喜欢三国杀的可以关注一下，有什么问题也可以加我微信一起讨论。 扫码体验小程序 扫码添加好友，请备注：三国杀 正文首先放一张最终保存到相册的图片吧~ 自我感觉良好，至少达到了我自己的预期吧~~~ 下面让我们一步一步来看看如何实现的吧。 整个图片分为三个部分： 武将图片 小程序码 武将文字信息 先来看一下wxml里面的代码，主要是放了一个canvas标签，控制了一下高度和宽度属性。 123&lt;view&gt; &lt;canvas class=&#x27;share-canvas&#x27; style=&quot;width:100%;height:&#123;&#123;canvasHeight&#125;&#125;px&quot; canvas-id=&quot;share_canvas&quot;&gt;&lt;/canvas&gt;&lt;/view&gt; 武将图片12345678910111213141516171819202122232425262728293031323334353637383940drawHeroImage: function (path) &#123; var that = this; // 拿到canvas context let ctx = wx.createCanvasContext(&#x27;share_canvas&#x27;); // 为了保证图片比例以及绘制的位置，先要拿到图片的大小 wx.getImageInfo(&#123; src: path, success: function (res) &#123; // 计算图片占比信息 let maxWidth = Math.min(res.width, that.data.canvasWidth * 0.65); let radio = maxWidth / res.width; let offsetY = (that.data.canvasHeight - res.height * radio) / 2; console.log(&#x27;offsetY=&#x27; + offsetY); that.setData(&#123; imageWidth: res.width * radio, imageHeight: res.height * radio, offsetY: offsetY, &#125;); // 绘制canvas背景，不属于绘制图片部分 ctx.setFillStyle(&#x27;white&#x27;) ctx.fillRect(0, 0, that.data.canvasWidth, that.data.canvasHeight); // 绘制武将图片，path是本地路径，不可以传网络url，如果是网络图片需要先下载 ctx.drawImage(path, 10, offsetY, res.width * radio, res.height * radio) // 绘制小程序码 that.drawQrCodeImage(ctx); // 绘制势力汉字：吴 that.drawInfluence(ctx, that.data.hero.HERO.INFLUENCE); // 绘制武将姓名：陆逊 that.drawName(ctx, that.data.hero.HERO.NAME); // 绘制武将称号：江陵侯 that.drawHorner(ctx, that.data.hero.HERO.HORNER); // 最终调用draw函数，生成预览图 // 一个坑点：只能调用一次，否则后面的会覆盖前面的 ctx.draw(); &#125; &#125;); &#125; 小程序码小程序码和武将图片是一个类型，无非就是需要计算绘制的位置，这里就不再展示相关代码了。 武将文字信息从刚刚的代码可以看出，我分了3个部分来绘制，其实吴和陆逊应该是可以放到一起的，但是我在绘制的时候发现，空格在绘制的时候会引起异常，导致空格后面的文字无法绘制出来，所以我这里吴和陆逊中间的空白是靠位置偏移来做的。 这里就展示一下如何绘制武将称号的。 123456789101112131415// 绘制武将称号：江陵侯drawHorner: function (ctx, text) &#123; // 设置字号 ctx.setFontSize(26); // 设置字体颜色 ctx.setFillStyle(&quot;#000000&quot;); // 计算绘制起点 let x = this.data.offsetX + 35; let y = this.data.offsetY + 10; console.log(&#x27;drawHorner&#x27; + text); console.log(x); console.log(y); // 绘制竖排文字，这里是个Util函数，具体实现请继续看 Canvas.drawTextVertical(ctx, text, x, y); &#125; 绘制竖排文字从网上找了个开源的代码，需要看原理的请看这里 当然我这里为了适用小程序做了些改动，函数原型是这样子的： 1CanvasRenderingContext2D.prototype.letterSpacingText = function (text, x, y, letterSpacing) 原谅我不是很会js，完全不懂这是个什么语法，看了一会没弄懂，感觉像是给类添加新的属性，不管他。 不管白猫黑猫，能抓到耗子就是好猫 改造后的函数像下面的样子： canvas.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*** @author zhangxinxu(.com)* @licence MIT* @description http://www.zhangxinxu.com/wordpress/?p=7362*/function drawTextVertical(context, text, x, y) &#123; var arrText = text.split(&#x27;&#x27;); var arrWidth = arrText.map(function (letter) &#123; return 26; // 这里为了找到那个空格的 bug 做了许多努力，不过似乎是白费力了 // const metrics = context.measureText(letter); // console.log(metrics); // const width = metrics.width; // return width; &#125;); var align = context.textAlign; var baseline = context.textBaseline; if (align == &#x27;left&#x27;) &#123; x = x + Math.max.apply(null, arrWidth) / 2; &#125; else if (align == &#x27;right&#x27;) &#123; x = x - Math.max.apply(null, arrWidth) / 2; &#125; if (baseline == &#x27;bottom&#x27; || baseline == &#x27;alphabetic&#x27; || baseline == &#x27;ideographic&#x27;) &#123; y = y - arrWidth[0] / 2; &#125; else if (baseline == &#x27;top&#x27; || baseline == &#x27;hanging&#x27;) &#123; y = y + arrWidth[0] / 2; &#125; context.textAlign = &#x27;center&#x27;; context.textBaseline = &#x27;middle&#x27;; // 开始逐字绘制 arrText.forEach(function (letter, index) &#123; // 确定下一个字符的纵坐标位置 var letterWidth = arrWidth[index]; // 是否需要旋转判断 var code = letter.charCodeAt(0); if (code &lt;= 256) &#123; context.translate(x, y); // 英文字符，旋转90° context.rotate(90 * Math.PI / 180); context.translate(-x, -y); &#125; else if (index &gt; 0 &amp;&amp; text.charCodeAt(index - 1) &lt; 256) &#123; // y修正 y = y + arrWidth[index - 1] / 2; &#125; context.fillText(letter, x, y); // 旋转坐标系还原成初始态 context.setTransform(1, 0, 0, 1, 0, 0); // 确定下一个字符的纵坐标位置 var letterWidth = arrWidth[index]; y = y + letterWidth; &#125;); // 水平垂直对齐方式还原 context.textAlign = align; context.textBaseline = baseline;&#125;module.exports = &#123; drawTextVertical: drawTextVertical&#125; 绘制网络图片由于网络图片无法直接绘制，所以需要先下载到本地，然后再按住本地图片绘制的流程走一遍。 123456789101112131415downloadHeroImage: function () &#123; // 微信不支持非https的图片下载，这里了个替换 let url = this.data.hero.HERO.ICON.replace(/http/, &quot;https&quot;); var that = this; wx.downloadFile(&#123; url: url, success: function (res) &#123; // 下载成功后拿到图片的路径，然后开始绘制 var path = res.tempFilePath; that.drawHeroImage(path); &#125;, fail: function (res) &#123; console.log(res) &#125; &#125;); &#125; 保存图片说了这么多，自然少不了最终的一步，将绘制到canvas的图片保存到手机相册，这里需要用户授权，你需要自己处理。 用的是微信给我们提供的接口wx.canvasToTempFilePath。需要我们传入起点坐标(x, y)和画布大小(width, height)以及canvasId。 1234567891011121314151617181920212223242526272829303132333435saveShareImage: function () &#123; wx.showLoading(&#123; title: &#x27;正在保存图片..&#x27;, &#125;); let that = this; wx.canvasToTempFilePath(&#123; x: 0, y: 0, width: that.data.canvasWidth, height: that.data.canvasHeight, canvasId: &#x27;share_canvas&#x27;, success: function (res) &#123; wx.saveImageToPhotosAlbum(&#123; filePath: res.tempFilePath, success(res) &#123; console.log(res); wx.showToast(&#123; title: &#x27;保存到相册成功&#x27;, duration: 1500, &#125;) &#125;, fail(res) &#123; console.log(res) wx.showToast(&#123; title: &#x27;保存到相册失败&#x27;, icon: &#x27;fail&#x27; &#125;) &#125;, complete(res) &#123; console.log(res) &#125; &#125;) &#125; &#125;) &#125; 开源本着开源的精神，源码已经放在Github上，大家可以去上面查看具体代码。 https://github.com/HistoryZhang/SgsNoteBook 如果对你有帮助的话，麻烦给个Star吧~ 点击阅读原文可以查看更好的代码格式~","categories":[{"name":"小程序","slug":"小程序","permalink":"https://kelvinqq.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://kelvinqq.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Canvas","slug":"Canvas","permalink":"https://kelvinqq.github.io/tags/Canvas/"}]},{"title":"公众号推荐","slug":"公众号推荐","date":"2018-02-07T13:44:35.000Z","updated":"2021-09-05T14:37:12.941Z","comments":true,"path":"2018/02/07/公众号推荐/","link":"","permalink":"https://kelvinqq.github.io/2018/02/07/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E8%8D%90/","excerpt":"阿里技术公众号介绍 阿里巴巴官方技术号，关于阿里的技术创新均呈现于此。 如官方介绍所说，会推送一些阿里用到的技术。也整理出一系列的 pdf 出来给大家。","text":"阿里技术公众号介绍 阿里巴巴官方技术号，关于阿里的技术创新均呈现于此。 如官方介绍所说，会推送一些阿里用到的技术。也整理出一系列的 pdf 出来给大家。 美团点评技术团队公众号介绍 这里是美团点评强大技术团队的对外窗口，每周腿送一线实践技术文章、技术活动、技术招聘信息。 会覆盖前端、后端、算法等等，也会推送一些技术沙龙活动。该技术团队除了这个公众号另外还维护一个技术博客，https://tech.meituan.com/。 淘宝技术公众号介绍 淘宝技术官方账号。 后端、前端、机器学习，总之淘宝用到的技术，都有机会在这里领略到。 WeMobileDev公众号介绍 微信移动客户端开发团队官号，分享微信在Android、iOS、Mac、Winphone、Windows等平台的开发经验、前沿技术，以及一些鲜为人知的小故事。 因为WCDB关注的该公众号，介绍的皆是微信在开发过程中遇到的问题解决方案，还有开源框架介绍。 移动开发前线公众号介绍 专注于分享移动开发前沿和一线技术。 主要推送一些关于移动端和前端的一些精选文章，两端技术、RN等等。也会推送一些关于移动端的热点文章，Kotlin、Swift、小程序等等。 聊聊架构公众号介绍 以架构之“道”为基础，呈现更多务实落地的架构内容。 主要推送一些关于架构设计的文章，包括前端后端，文章质量还是蛮高的。 云栖社区公众号介绍 云栖社区是由阿里云负责运营、阿里巴巴技术协会和阿里巴巴集团各技术团队提供内容支持的开放式技术社区。 有时候会和几个阿里系的公众号发同样的文章，主要还是会发一些热点知识，人工智能、区块链、服务端架构等待。 InfoQ公众号介绍 有内容的技术社区媒体。 在这里除了技术干货，还能学到如何定位自身。作为一个技术，你不仅需要掌握技术，还需要扩充横向知识面，为你的人生铺路。 stromzhang公众号介绍 一名不羁的码农，我的世界不只有 Coding！ 最后推荐的是一个个人运营的公众号，刚开始是以为 Android 开发者，写一下关于 Android 开发的文章，后来会涉及一些管理的文章。现在已经没有限制了，包括广告，总的来说质量还可以吧。","categories":[{"name":"日记","slug":"日记","permalink":"https://kelvinqq.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"公众号","slug":"公众号","permalink":"https://kelvinqq.github.io/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"}]},{"title":"Swift关于!和?的Tip","slug":"Swift关于解包的Tip","date":"2018-02-06T13:45:07.000Z","updated":"2021-08-27T13:34:42.822Z","comments":true,"path":"2018/02/06/Swift关于解包的Tip/","link":"","permalink":"https://kelvinqq.github.io/2018/02/06/Swift%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%8C%85%E7%9A%84Tip/","excerpt":"前言 Q: 为什么我现在还在写这些入门级别的语法 Tip 呢？ A: 因为我现在才开始学习 Swift 呗~ Q: 为什么我现在才开始学习 Swift 呢？ A: 因为懒呗~","text":"前言 Q: 为什么我现在还在写这些入门级别的语法 Tip 呢？ A: 因为我现在才开始学习 Swift 呗~ Q: 为什么我现在才开始学习 Swift 呢？ A: 因为懒呗~ 哈哈分享一些自己看到的小 Tip 给大家，让那些也才入门 Swift 的童鞋也能多了解一些 关于 ! 和 ?今天这里不打算介绍为什么 Swift 里面会有 ! 和 ?，有什么不明白的可以看看这里：Swift中 ！和 ？的区别及使用 现在我们看一个平时用到的例子： 1234let width: Int? = 3var area: Int? area = width! * width! 为什么这里 let area = width! * width! 会有这么多的 ! 呢？因为机（愚）智（蠢）的 Xcode 建议我们这样写。最关键的是如果 width 真的就是 nil 会这么样呢？机智如你，会 Crash。 那保险一点的写法应该是这样子的： 123456789let width: Int? = 3var area: Int?if let tmp = width &#123; area = tmp * tmp&#125;else &#123; area = nil&#125; 完全不符合 Swift 作为一门优雅的语言的称号。 Optional Map面对上面的问题，有个很优雅的写法，那就是 Optional Map。让我们先看一下 Optional 中关于 map 的声明。 1234public enum Optional&lt;Wrapped&gt; : ExpressibleByNilLiteral &#123; public func map&lt;U&gt;(_ transform: (Wrapped) throws -&gt; U) rethrows -&gt; U?&#125; 该方法的作用是，如果输入有值，则进入 transform 的闭包进行变化，并返回一个 U? ;如果输入就是 nil 的话，则直接返回 nil 的 U?。 那么我们就有如下优雅的写法了： 1234let width: Int? = 3let area = width.map &#123; $0 * $0&#125; 更多我们还能在 Collection 中看到 map 的身影。 123456789101112131415161718192021extension Collection &#123; /// Returns an array containing the results of mapping the given closure /// over the sequence&#x27;s elements. /// /// In this example, `map` is used first to convert the names in the array /// to lowercase strings and then to count their characters. /// /// let cast = [&quot;Vivien&quot;, &quot;Marlon&quot;, &quot;Kim&quot;, &quot;Karl&quot;] /// let lowercaseNames = cast.map &#123; $0.lowercaseString &#125; /// // &#x27;lowercaseNames&#x27; == [&quot;vivien&quot;, &quot;marlon&quot;, &quot;kim&quot;, &quot;karl&quot;] /// let letterCounts = cast.map &#123; $0.count &#125; /// // &#x27;letterCounts&#x27; == [6, 6, 3, 4] /// /// - Parameter transform: A mapping closure. `transform` accepts an /// element of this sequence as its parameter and returns a transformed /// value of the same or of a different type. /// - Returns: An array containing the transformed elements of this /// sequence. public func map&lt;T&gt;(_ transform: (Self.Element) throws -&gt; T) rethrows -&gt; [T]&#125; 注释的很清楚了，就不多介绍了。值得注意的是 Collection 本身是一个 protocol，所以所有实现了 Collection 协议的都有这个方法。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://kelvinqq.github.io/tags/Swift/"}]},{"title":"Github源码索引","slug":"Github源码索引","date":"2018-01-27T06:12:05.000Z","updated":"2021-09-11T03:33:26.397Z","comments":true,"path":"2018/01/27/Github源码索引/","link":"","permalink":"https://kelvinqq.github.io/2018/01/27/Github%E6%BA%90%E7%A0%81%E7%B4%A2%E5%BC%95/","excerpt":"一、UI相关 NotificationBanner 通知栏提醒 DKImagePickerController","text":"一、UI相关 NotificationBanner 通知栏提醒 DKImagePickerController 系统相册 SwipeCellKit 系统邮箱手势的Cell JTCalendar 日历 CVCalendar 日历 XLForm 表单系统 Eureka 表单系统二、Extension SwifterSwift三、工具 SwiftyJSON JSON转Model四、其他 英语进阶指南 12306ForMac 12306 订票/捡票 助手 跳一跳辅助 答题App辅助","categories":[{"name":"源码推荐","slug":"源码推荐","permalink":"https://kelvinqq.github.io/categories/%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://kelvinqq.github.io/tags/Github/"}]},{"title":"Github源码推荐(1.22~1.28)","slug":"Github源码推荐(1.22-1.28)","date":"2018-01-27T04:39:11.000Z","updated":"2021-09-11T03:33:26.396Z","comments":true,"path":"2018/01/27/Github源码推荐(1.22-1.28)/","link":"","permalink":"https://kelvinqq.github.io/2018/01/27/Github%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90(1.22-1.28)/","excerpt":"除了推荐一些源码，如果遇到其他相关我也会推荐给大家，排名来自于心情。 一、英语进阶指南夫人最近也在学习英语，不知道这个对她是否有用呢？ 英语作为一门语言，学习起来应该是一件比较自然而然的事情，就像我们自然而然地学会汉语那样。","text":"除了推荐一些源码，如果遇到其他相关我也会推荐给大家，排名来自于心情。 一、英语进阶指南夫人最近也在学习英语，不知道这个对她是否有用呢？ 英语作为一门语言，学习起来应该是一件比较自然而然的事情，就像我们自然而然地学会汉语那样。 效果图 热度1Star: 7800+ Github主页https://github.com/byoungd/English-level-up-tips-for-Chinese 二、春节即将来临，是否有小伙伴再开始抢票了呢？如果你使用的是Mac系统，那就试试这个吧，专为Mac OS打造的12306 订票/捡票 助手。效果图 热度1Star: 2000+ Github主页https://github.com/fancymax/12306ForMac 三、习惯了OC下的YYModel等Dictionary转Model工具，在Swift下是否不适应呢？试试SwiftyJSON吧，一定会为你带来更好的体验。热度1Star: 16000+ CocoaPods1pod &#x27;SwiftyJSON&#x27; Carthage1github &quot;SwiftyJSON/SwiftyJSON&quot; Github主页https://github.com/SwiftyJSON/SwiftyJSON 四、是否厌倦了Toast一成不变的样式呢？你可以试试NotificationBanner，漂亮的动画样式，新颖的交互体验。效果图 热度1Star: 1700+ CocoaPods1pod &#x27;NotificationBannerSwift&#x27; Carthage1github &quot;Daltron/NotificationBanner&quot; &quot;master&quot; Github主页https://github.com/Daltron/NotificationBanner 好了，暂时就推荐这么多给大家，下周我们再见。 PS：本文中图片部分皆来自于作者Github主页，如有侵权，请告知。","categories":[{"name":"源码推荐","slug":"源码推荐","permalink":"https://kelvinqq.github.io/categories/%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://kelvinqq.github.io/tags/Github/"}]},{"title":"Github源码推荐(1.15~1.21)","slug":"Github源码推荐(1.15~1.21)","date":"2018-01-21T03:21:06.000Z","updated":"2021-09-11T03:33:26.396Z","comments":true,"path":"2018/01/21/Github源码推荐(1.15~1.21)/","link":"","permalink":"https://kelvinqq.github.io/2018/01/21/Github%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90(1.15~1.21)/","excerpt":"大家好，一周时间过得真快，本次主题依旧，推荐一些Github上的源码，排名不分先后。 一、答题App莫名的火了起来，随之而来的则是一系列的辅助软件，例如搜狗、百度，先后推出辅助答题助手。这档子事自然少不了广大程序员Show一把的场面，下面推荐的就是使用OCR做的辅助答题助手。 特点 使用手机模拟器，快速识别~ 浏览器自动搜索显示结果，搜索引擎可配置，结果一目了然~ 模拟器还能多开哦~全部答对奖金翻倍，遇到不会的可以多选乱蒙 万英雄/知识超人/冲顶大会都支持哦~","text":"大家好，一周时间过得真快，本次主题依旧，推荐一些Github上的源码，排名不分先后。 一、答题App莫名的火了起来，随之而来的则是一系列的辅助软件，例如搜狗、百度，先后推出辅助答题助手。这档子事自然少不了广大程序员Show一把的场面，下面推荐的就是使用OCR做的辅助答题助手。 特点 使用手机模拟器，快速识别~ 浏览器自动搜索显示结果，搜索引擎可配置，结果一目了然~ 模拟器还能多开哦~全部答对奖金翻倍，遇到不会的可以多选乱蒙 万英雄/知识超人/冲顶大会都支持哦~ 效果图 热度1Star: 800+ Github主页https://github.com/rrdssfgcs/wenda-helper 二、上一周给大家推荐了一个Objective-C的日历，这次给大家推荐一个Swift4的日历控件，作者写的非常好棒，支持Storyboard。效果图 热度1Star: 2800+ CocoaPods1pod &#x27;CVCalendar&#x27;, &#x27;~&gt; 1.6.0&#x27; Github主页https://github.com/CVCalendar/CVCalendar 三、使用Swift的时候是不是需要写好多的Extension呢？使用这个开源库后就再也不用劳心劳力的写很多的Extension了。 SwifterSwift is a collection of over 500 native Swift extensions, with handy methods, syntactic sugar, and performance improvements for wide range of primitive data types, UIKit and Cocoa classes –over 500 in 1– for iOS, macOS, tvOS and watchOS. 简直不要太强大，而且支持Swift4。 热度1Star: 4200+ CocoaPods1pod &#x27;SwifterSwift&#x27; 你也可以只集成部分Extension，例如 1pod &#x27;SwifterSwift/Foundation&#x27; 具体还是去作者主页看吧。 Carthage1github &quot;SwifterSwift/SwifterSwift&quot; ~&gt; 4.0 Github主页https://github.com/SwifterSwift/SwifterSwift 四、基本上所有的App都逃脱不了表单，设置、用户界面等待，都是一些枯燥无味的代码，却又要花费时间、精力去自定义每个Cell达到各式各样的效果，此次为大家推荐一个强大的表单开源库，最重要的是OC和Swift都有，各取所需。 OC版 效果图 热度1Star: 4800+ CocoaPods1pod &#x27;XLForm&#x27;, &#x27;~&gt; 4.0&#x27; Carthage1github &quot;xmartlabs/XLForm&quot; ~&gt; 4.0 Github主页https://github.com/xmartlabs/XLForm Swift版 效果图 热度1Star: 7500+ CocoaPods1pod &#x27;Eureka&#x27; Carthage1github &quot;xmartlabs/Eureka&quot; ~&gt; 4.0 Github主页https://github.com/xmartlabs/Eureka 关于使用方法这里就不再介绍了，项目主页上介绍的非常清楚，有需求的小伙伴就自己去查看吧~ 好了，暂时就推荐这么多给大家，下周我们再见。 PS：本文中图片部分皆来自于作者Github主页，如有侵权，请告知。","categories":[{"name":"源码推荐","slug":"源码推荐","permalink":"https://kelvinqq.github.io/categories/%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://kelvinqq.github.io/tags/Github/"}]},{"title":"Github源码推荐(1.8~1.14)","slug":"Github源码推荐(1.8~1.14)","date":"2018-01-14T14:22:30.000Z","updated":"2021-09-11T03:33:26.397Z","comments":true,"path":"2018/01/14/Github源码推荐(1.8~1.14)/","link":"","permalink":"https://kelvinqq.github.io/2018/01/14/Github%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90(1.8~1.14)/","excerpt":"本次给大家推荐一些Github上的源码，排名不分先后。 一、微信小游戏的推出，自然而然是火爆了一把。但是一切都阻止不了程序员，自然是要破解一番的，本次首推的就是利用Python开发的跳一跳辅助。原理说明(摘自作者原文) 将手机点击到《跳一跳》小程序界面 用 ADB 工具获取当前手机截图，并用 ADB 将截图 pull 上来 计算按压时间 手动版：用 Matplotlib 显示截图，用鼠标先点击起始点位置，然后点击目标位置，计算像素距离； 自动版：靠棋子的颜色来识别棋子，靠底色和方块的色差来识别棋盘； 用 ADB 工具点击屏幕蓄力一跳","text":"本次给大家推荐一些Github上的源码，排名不分先后。 一、微信小游戏的推出，自然而然是火爆了一把。但是一切都阻止不了程序员，自然是要破解一番的，本次首推的就是利用Python开发的跳一跳辅助。原理说明(摘自作者原文) 将手机点击到《跳一跳》小程序界面 用 ADB 工具获取当前手机截图，并用 ADB 将截图 pull 上来 计算按压时间 手动版：用 Matplotlib 显示截图，用鼠标先点击起始点位置，然后点击目标位置，计算像素距离； 自动版：靠棋子的颜色来识别棋子，靠底色和方块的色差来识别棋盘； 用 ADB 工具点击屏幕蓄力一跳 热度1Star: 11800+ Github主页https://github.com/wangshub/wechat_jump_game 二、是否觉得系统的相册太不方便，而自定义又太耗费时间，那就试试DKImagePickerController吧，作者完全使用Swift编写，支持CocoaPods。效果图 热度1Star: 890+ CocoaPods1pod &#x27;DKImagePickerController&#x27; Github主页https://github.com/zhangao0086/DKImagePickerController 三、系统邮箱中的交互让很多人大爱，尤其是列表的左右滑动手势，Github上有很多人都开源了自己的模仿源码，本次推荐的也是一个使用纯Swift编写的源码。效果图 热度1Star: 2700+ CocoaPods1pod &#x27;SwipeCellKit&#x27; Carthage1github &quot;SwipeCellKit/SwipeCellKit&quot; Github主页https://github.com/SwipeCellKit/SwipeCellKit 四、相信很多人都有编写日历的需求，在Todo，万年历等中，都需要日历，本次为大家推荐一个Objective-C编写的日历，支持横向和纵向滚动，支持切换月视图和周视图，支持Localization。效果图 热度1Star: 2400+ CocoaPods1pod &#x27;JTCalendar&#x27;, &#x27;~&gt; 2.0&#x27; Carthage1github &quot;jonathantribouharet/JTCalendar&quot; ~&gt; 2.2 Github主页https://github.com/jonathantribouharet/JTCalendar 好了，暂时就推荐这么多给大家，下周我们再见。 PS：本文中图片部分皆来自于作者Github主页，如有侵权，请告知。","categories":[{"name":"源码推荐","slug":"源码推荐","permalink":"https://kelvinqq.github.io/categories/%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://kelvinqq.github.io/tags/Github/"}]},{"title":"CocoaPods设置target支持的swift版本 ","slug":"CocoaPods设置target支持的swift版本","date":"2017-11-24T00:50:33.000Z","updated":"2021-08-27T13:34:42.819Z","comments":true,"path":"2017/11/24/CocoaPods设置target支持的swift版本/","link":"","permalink":"https://kelvinqq.github.io/2017/11/24/CocoaPods%E8%AE%BE%E7%BD%AEtarget%E6%94%AF%E6%8C%81%E7%9A%84swift%E7%89%88%E6%9C%AC/","excerpt":"上一篇文章说道在Swift4.0中如何引用3.0版本的第三方库，详见这篇文章。但是如果Pods中有很多第三方库都只支持3.0，一个一个修改恐怕是要累死。而且每次执行pod update之后之前设置的都会被重置，恐怕是想死的心都有了。","text":"上一篇文章说道在Swift4.0中如何引用3.0版本的第三方库，详见这篇文章。但是如果Pods中有很多第三方库都只支持3.0，一个一个修改恐怕是要累死。而且每次执行pod update之后之前设置的都会被重置，恐怕是想死的心都有了。 有一句是说：”懒惰”推动了人类的进步。所以程序猿总是有办法的。 Talk is cheap, Show me the code 1234567891011121314151617platform :ios, &#x27;10.0&#x27;use_frameworks!target &#x27;YourTarget&#x27; do pod &#x27;SnapKit&#x27;, &#x27;~&gt; 4.0.0&#x27; pod &#x27;Toast-Swift&#x27;, &#x27;~&gt; 2.0.0&#x27;endpost_install do |installer| installer.pods_project.targets.each do |target| if target.name == &#x27;Toast-Swift&#x27; target.build_configurations.each do |config| config.build_settings[&#x27;SWIFT_VERSION&#x27;] = &#x27;3.2&#x27; end end endend","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"Swift4","slug":"Swift4","permalink":"https://kelvinqq.github.io/tags/Swift4/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://kelvinqq.github.io/tags/CocoaPods/"}]},{"title":"Xcode9下自动化编译错误","slug":"Xcode9下自动化编译错误","date":"2017-11-09T14:03:20.000Z","updated":"2021-08-27T13:34:42.823Z","comments":true,"path":"2017/11/09/Xcode9下自动化编译错误/","link":"","permalink":"https://kelvinqq.github.io/2017/11/09/Xcode9%E4%B8%8B%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF/","excerpt":"最近在使用CI平台打包时突然失败了，查看日志后发现是在exportArchive时失败了。之前一直都是好好地，升级了Xcode之后突然就不行了，提示如下信息： 123error: exportArchive: &quot;AppName.app&quot; requires a provisioning profile with the Push Notifications and App Groups features.Error Domain=IDEProvisioningErrorDomain Code=9&quot;AppName.app&quot; requires a provisioning profile with the Push Notifications and App Groups features.&quot; UserInfo=&#123;NSLocalizedDescription=&quot;AppName.app&quot; requires a provisioning profile with the Push Notifications and App Groups features., NSLocalizedRecoverySuggestion=Add a profile to the &quot;provisioningProfiles&quot; dictionary in your Export Options property list.&#125;","text":"最近在使用CI平台打包时突然失败了，查看日志后发现是在exportArchive时失败了。之前一直都是好好地，升级了Xcode之后突然就不行了，提示如下信息： 123error: exportArchive: &quot;AppName.app&quot; requires a provisioning profile with the Push Notifications and App Groups features.Error Domain=IDEProvisioningErrorDomain Code=9&quot;AppName.app&quot; requires a provisioning profile with the Push Notifications and App Groups features.&quot; UserInfo=&#123;NSLocalizedDescription=&quot;AppName.app&quot; requires a provisioning profile with the Push Notifications and App Groups features., NSLocalizedRecoverySuggestion=Add a profile to the &quot;provisioningProfiles&quot; dictionary in your Export Options property list.&#125; 查阅资料后发现，在Xcode9下，xcodebuild需要配置更多的信息才能导出ipa，最主要的一个就是provisioningProfiles。具体的操作步骤如下。 使用Xcode Archive一个新的版本 在Organizer中找到刚刚Archive出来的版本，选择Export。 选择你要导出的ipa类型，如果你需要不同版本，可以重复该流程，就可以得到其他类型所需要的信息了。 导出ipa到目录 最终导出的目录下会有4个文件，除了ipa文件还有一个ExportOptions.plist文件，这个文件就是我们使用xcodebuild -exportArchive命令时，-exportOptionsPlist参数需要指定的plist文件。 我们用这个新的plist文件就可以了。如果你需要打其他类型的ipa，可以重复上述步骤，在第三步重新选择即可。你也可以按照刚才导出的plist自己修改。 新的plist中有如下一些选项，你也可以参照修改。 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;compileBitcode&lt;/key&gt; &lt;false/&gt; &lt;key&gt;method&lt;/key&gt; &lt;string&gt;ad-hoc&lt;/string&gt; &lt;key&gt;provisioningProfiles&lt;/key&gt; &lt;dict&gt; &lt;key&gt;com.tsing.calculate&lt;/key&gt; &lt;string&gt;calculate_adhoc&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;signingCertificate&lt;/key&gt; &lt;string&gt;iPhone Distribution&lt;/string&gt; &lt;key&gt;signingStyle&lt;/key&gt; &lt;string&gt;manual&lt;/string&gt; &lt;key&gt;stripSwiftSymbols&lt;/key&gt; &lt;true/&gt; &lt;key&gt;teamID&lt;/key&gt; &lt;string&gt;CL32FD34&lt;/string&gt; &lt;key&gt;thinning&lt;/key&gt; &lt;string&gt;&amp;lt;none&amp;gt;&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"自动打包","slug":"自动打包","permalink":"https://kelvinqq.github.io/tags/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/"},{"name":"xcodebuild","slug":"xcodebuild","permalink":"https://kelvinqq.github.io/tags/xcodebuild/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://kelvinqq.github.io/tags/Jenkins/"},{"name":"Xcode9","slug":"Xcode9","permalink":"https://kelvinqq.github.io/tags/Xcode9/"}]},{"title":"Swift4.0引用3.0第三方库","slug":"Swift4.0引用3.0第三方库","date":"2017-10-21T15:56:21.000Z","updated":"2021-08-27T13:34:42.822Z","comments":true,"path":"2017/10/21/Swift4.0引用3.0第三方库/","link":"","permalink":"https://kelvinqq.github.io/2017/10/21/Swift4.0%E5%BC%95%E7%94%A83.0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/","excerpt":"Swift已经发布了4.0版本，在Xcode9中新建项目后，默认是使用4.0语法的。项目中的引用的第三方库，虽然有很多已经发不了4.0版本，但是还是有一些未及时更新的，那在作者未更新之前我们是否有更好的办法来使用这些第三方库呢？答案当然是肯定的，Xcode9中是同时支持3.2和4.0语法的。具体的设置可以看下图。","text":"Swift已经发布了4.0版本，在Xcode9中新建项目后，默认是使用4.0语法的。项目中的引用的第三方库，虽然有很多已经发不了4.0版本，但是还是有一些未及时更新的，那在作者未更新之前我们是否有更好的办法来使用这些第三方库呢？答案当然是肯定的，Xcode9中是同时支持3.2和4.0语法的。具体的设置可以看下图。 那么下面就说说如何设置同时支持3.2和4.0。 项目中如果使用Cocoapods来管理第三方库时，可以找到不支持4.0语法的库所在target，然后找到Swift Language Version选项，改为3.2，然后就可以顺利编译通过了。 如果还有以源码集成进项目的，那就选择Edit &gt; Convert &gt; To Current Swift Syntax..吧","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"Swift4","slug":"Swift4","permalink":"https://kelvinqq.github.io/tags/Swift4/"},{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/tags/iOS/"}]},{"title":"iOS下更改系统音量","slug":"iOS下更改系统音量","date":"2017-09-30T13:29:38.000Z","updated":"2021-09-05T14:35:00.458Z","comments":true,"path":"2017/09/30/iOS下更改系统音量/","link":"","permalink":"https://kelvinqq.github.io/2017/09/30/iOS%E4%B8%8B%E6%9B%B4%E6%94%B9%E7%B3%BB%E7%BB%9F%E9%9F%B3%E9%87%8F/","excerpt":"iOS中，如果想更改系统音量，只有2个方法，一是使用私有方法；二是使用MPVolumeView。 私有方法不在我们的讨论范围之列，我们来讨论一下如何使用MPVolumeView。 用过一系列的音乐播放器都知道，添加一个MPVolumeView在View上，然后设置showsVolumeSlider = YES，就会有一个SliderView，用户滑动时，就能更改系统音量。 这样带来的问题就是，","text":"iOS中，如果想更改系统音量，只有2个方法，一是使用私有方法；二是使用MPVolumeView。 私有方法不在我们的讨论范围之列，我们来讨论一下如何使用MPVolumeView。 用过一系列的音乐播放器都知道，添加一个MPVolumeView在View上，然后设置showsVolumeSlider = YES，就会有一个SliderView，用户滑动时，就能更改系统音量。 这样带来的问题就是， 会显示一个MPVolumeView; 需要手动触发滑动事件; 对于第一个问题很简单，MPVolumeView的hidden属性设置为YES即可；所以主要解决如何模拟用户手动滑动事件即可。 不多说，有了思路后就变得很简单了，下面奉上实现代码。 1234567891011121314151617181920212223242526272829303132333435/* * 设置音量 */- (void)setVolume:(float)value &#123; UISlider *volumeSlider = [self volumeSlider]; self.volumeView.showsVolumeSlider = YES; // 需要设置 showsVolumeSlider 为 YES // 下面两句代码是关键 [volumeSlider setValue:value animated:NO]; [volumeSlider sendActionsForControlEvents:UIControlEventTouchUpInside]; [self.volumeView sizeToFit];&#125;- (MPVolumeView *)volumeView &#123; if (!_volumeView) &#123; _volumeView = [[MPVolumeView alloc] init]; _volumeView.hidden = YES; [self.window addSubview:_volumeView]; &#125; return _volumeView;&#125;/* * 遍历控件，拿到UISlider */- (UISlider *)volumeSlider &#123; UISlider* volumeSlider = nil; for (UIView *view in [self.volumeView subviews]) &#123; if ([view.class.description isEqualToString:@&quot;MPVolumeSlider&quot;])&#123; volumeSlider = (UISlider *)view; break; &#125; &#125; return volumeSlider;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"音量","slug":"音量","permalink":"https://kelvinqq.github.io/tags/%E9%9F%B3%E9%87%8F/"},{"name":"MPVolumeView","slug":"MPVolumeView","permalink":"https://kelvinqq.github.io/tags/MPVolumeView/"}]},{"title":"iOS拨打电话对话框问题解决","slug":"iOS拨打电话对话框问题解决","date":"2017-09-28T14:14:20.000Z","updated":"2021-09-05T14:35:11.490Z","comments":true,"path":"2017/09/28/iOS拨打电话对话框问题解决/","link":"","permalink":"https://kelvinqq.github.io/2017/09/28/iOS%E6%8B%A8%E6%89%93%E7%94%B5%E8%AF%9D%E5%AF%B9%E8%AF%9D%E6%A1%86%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","excerpt":"iOS中拨打电话大家应该都很清楚了，如果还有什么疑问的话可以参考这篇文章。但是iOS10的系统会先有个对话框确认，这与并不符合小飞鱼的需求。小飞鱼是由语音控制拨打电话，当用户查找到号码后，只需语音确认一次即可拨打电话，如果有系统的确认对话框，不仅多了一个步骤，而且还需要模拟点击对话框按钮事件，比较繁琐。","text":"iOS中拨打电话大家应该都很清楚了，如果还有什么疑问的话可以参考这篇文章。但是iOS10的系统会先有个对话框确认，这与并不符合小飞鱼的需求。小飞鱼是由语音控制拨打电话，当用户查找到号码后，只需语音确认一次即可拨打电话，如果有系统的确认对话框，不仅多了一个步骤，而且还需要模拟点击对话框按钮事件，比较繁琐。 由于小飞鱼中，App和设备之间是通过BLE和传统蓝牙来连接的，而用过蓝牙耳机的都应该知道，可以之间通过蓝牙耳机拨打电话。所以方案就有了：如上图，App端先通过BLE把号码发送给设备，然后设备通过传统蓝牙协议(PBAP中AT Command)，直接拨号即可，不会弹出确认框。 具体的指令如下：AT#CW13012341234\\r\\n；整个PBAP协议参见这篇文章","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"打电话","slug":"打电话","permalink":"https://kelvinqq.github.io/tags/%E6%89%93%E7%94%B5%E8%AF%9D/"},{"name":"蓝牙","slug":"蓝牙","permalink":"https://kelvinqq.github.io/tags/%E8%93%9D%E7%89%99/"},{"name":"PBAP","slug":"PBAP","permalink":"https://kelvinqq.github.io/tags/PBAP/"}]},{"title":"小飞鱼项目有感","slug":"小飞鱼项目有感","date":"2017-09-27T15:36:00.000Z","updated":"2021-09-05T14:38:11.933Z","comments":true,"path":"2017/09/27/小飞鱼项目有感/","link":"","permalink":"https://kelvinqq.github.io/2017/09/27/%E5%B0%8F%E9%A3%9E%E9%B1%BC%E9%A1%B9%E7%9B%AE%E6%9C%89%E6%84%9F/","excerpt":"小飞鱼是科大讯飞车载开发的一款智能行车助手，通过语音操作，让你在开车过程中解放双手，使你在开车过程中更加安全，体验更优。小飞鱼目前支持使用语音导航，打电话，听音乐、节目、电台，查询天气、股票，还支持对话闲聊，让你的旅途不再寂寞。 整个项目涉及蓝牙、BLE、电话、高德导航以及媒体播放，在项目过程中遇到很多坑，后续会逐步介绍项目中遇到的问题。","text":"小飞鱼是科大讯飞车载开发的一款智能行车助手，通过语音操作，让你在开车过程中解放双手，使你在开车过程中更加安全，体验更优。小飞鱼目前支持使用语音导航，打电话，听音乐、节目、电台，查询天气、股票，还支持对话闲聊，让你的旅途不再寂寞。 整个项目涉及蓝牙、BLE、电话、高德导航以及媒体播放，在项目过程中遇到很多坑，后续会逐步介绍项目中遇到的问题。 这里先在这里打个广告吧（微信文章直接长按识别二维码，或者可以点击底部阅读原文）。iOS App下载地址 设备购买地址 1. iOS拨打电话对话框问题解决","categories":[{"name":"日记","slug":"日记","permalink":"https://kelvinqq.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"电话","slug":"电话","permalink":"https://kelvinqq.github.io/tags/%E7%94%B5%E8%AF%9D/"},{"name":"小飞鱼","slug":"小飞鱼","permalink":"https://kelvinqq.github.io/tags/%E5%B0%8F%E9%A3%9E%E9%B1%BC/"}]},{"title":"iOS下日志记录","slug":"iOS下日志记录","date":"2017-09-24T00:22:30.000Z","updated":"2021-08-27T13:34:42.824Z","comments":true,"path":"2017/09/24/iOS下日志记录/","link":"","permalink":"https://kelvinqq.github.io/2017/09/24/iOS%E4%B8%8B%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/","excerpt":"iOS开发中，一般大家都会自定义一个DLog的宏来代替NSLog，用来控制Release下的Log输出。但是有以下几个弊端： 没有日志分级。做过Android的都知道，Android可以分为5级，Error、Warning、Info、Debug、Verbose。 日志没法记录到文件，Release版本无法通过Log日志定位问题。","text":"iOS开发中，一般大家都会自定义一个DLog的宏来代替NSLog，用来控制Release下的Log输出。但是有以下几个弊端： 没有日志分级。做过Android的都知道，Android可以分为5级，Error、Warning、Info、Debug、Verbose。 日志没法记录到文件，Release版本无法通过Log日志定位问题。 所以今天就推荐一个第三方库，CocoaLumberjack，完全满足以上需求，不但如此，还支持以下需求： 自定义Log文件的文件数、有效期、缓存大小123fileLogger.logFileManager.maximumNumberOfLogFiles = 20;fileLogger.maximumFileSize = 1024 * 1024 * 5;fileLogger.rollingFrequency = 60 * 60 * 24; 具体使用大家还是看看GitHub上的介绍。现在说一下集成中遇到的问题：1 . 可以自定义输出Log的格式，需要实现DDLogFormatter协议，下面提供一个示例：123456789101112131415161718192021222324- (NSString *)formatLogMessage:(DDLogMessage *)logMessage &#123; NSString *logLevel = nil; switch (logMessage.flag) &#123; case DDLogFlagError: logLevel = @&quot;[E]&quot;; break; case DDLogFlagWarning: logLevel = @&quot;[W]&quot;; break; case DDLogFlagInfo: logLevel = @&quot;[I]&quot;; break; case DDLogFlagDebug: logLevel = @&quot;[D]&quot;; break; default: logLevel = @&quot;[V]&quot;; break; &#125; NSString *formatString = [NSString stringWithFormat:@&quot;%@ %@ [@%zd] %@ %@&quot;, [logMessage.timestamp descriptionWithLocale:[NSLocale currentLocale]], logLevel, logMessage.line, logMessage.function, logMessage.message]; return formatString;&#125; 2 . 在单步调试时会发现，很多级别的日志不会立即显示到控制台中。在DDLogMacros.h中，我们可以看到以下几个宏定义： 12345#define DDLogError(frmt, ...) LOG_MAYBE(NO, LOG_LEVEL_DEF, DDLogFlagError, 0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)#define DDLogWarn(frmt, ...) LOG_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagWarning, 0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)#define DDLogInfo(frmt, ...) LOG_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagInfo, 0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)#define DDLogDebug(frmt, ...) LOG_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagDebug, 0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__)#define DDLogVerbose(frmt, ...) LOG_MAYBE(LOG_ASYNC_ENABLED, LOG_LEVEL_DEF, DDLogFlagVerbose, 0, nil, __PRETTY_FUNCTION__, frmt, ##__VA_ARGS__) 你会发现DDLogError和其他的宏定义的第一个参数不是很一样，然后找到LOG_ASYNC_ENABLED的定义，这样就很明白了，如果你需要立即显示，把LOG_ASYNC_ENABLED的定义改为如下即可。 123#ifndef LOG_ASYNC_ENABLED #define LOG_ASYNC_ENABLED NO#endif 3 . 说一下rollingFrequency这个属性，看了源码后发现，作者是根据文件的创建时间来处理的，所以就会导致这样的问题，1号15:00创建的文件，然后用到2号15:00就会重新创建一个文件，所以会导致2号的Log在15:00被分为2个文件。 如果需要更高度的自定义，可以去CocoaLumberjack主页上看一下README。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"Log","slug":"Log","permalink":"https://kelvinqq.github.io/tags/Log/"}]},{"title":"开源协议知多少","slug":"开源协议知多少","date":"2016-12-30T15:20:28.000Z","updated":"2021-09-05T14:38:18.005Z","comments":true,"path":"2016/12/30/开源协议知多少/","link":"","permalink":"https://kelvinqq.github.io/2016/12/30/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E7%9F%A5%E5%A4%9A%E5%B0%91/","excerpt":"越来越多的公司和个人在GitHub上开源他的代码，这是一种精神。为那些开源的公司和个人致敬、点赞。当你在GitHub上创建一个项目的时候，就会让你选择一个License，像MIT，BSD，GPL v2等等。但是这么多开源协议，你真的知道怎么选择吗？当你用到一个开源库的时候，你真的看清他的开源协议吗？或许，目前来说，你并没有注意到这些。但是，随着国内对知识产权的越来越重视（从音乐就可窥见一斑），说不定哪一天你就会收到一封邮件。好吧，说了这么多，我们还是用一张图来读懂那些开源协议吧。","text":"越来越多的公司和个人在GitHub上开源他的代码，这是一种精神。为那些开源的公司和个人致敬、点赞。当你在GitHub上创建一个项目的时候，就会让你选择一个License，像MIT，BSD，GPL v2等等。但是这么多开源协议，你真的知道怎么选择吗？当你用到一个开源库的时候，你真的看清他的开源协议吗？或许，目前来说，你并没有注意到这些。但是，随着国内对知识产权的越来越重视（从音乐就可窥见一斑），说不定哪一天你就会收到一封邮件。好吧，说了这么多，我们还是用一张图来读懂那些开源协议吧。 乌克兰程序员 Paul Bagwell 画了一张分析图（下图为阮一峰汉化版）。 图片来自文章别以为把你的代码上传到开源中国就算是开源了！先选择一个合适的 License 吧。","categories":[{"name":"日记","slug":"日记","permalink":"https://kelvinqq.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"开源协议","slug":"开源协议","permalink":"https://kelvinqq.github.io/tags/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"}]},{"title":"iOS 高性能异构滚动视图-LazyScrollView实现","slug":"iOS-高性能异构滚动视图-LazyScrollView实现","date":"2016-12-08T12:08:14.000Z","updated":"2021-08-27T13:34:42.824Z","comments":true,"path":"2016/12/08/iOS-高性能异构滚动视图-LazyScrollView实现/","link":"","permalink":"https://kelvinqq.github.io/2016/12/08/iOS-%E9%AB%98%E6%80%A7%E8%83%BD%E5%BC%82%E6%9E%84%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE-LazyScrollView%E5%AE%9E%E7%8E%B0/","excerpt":"LazyScrollView简介 LazyScrollView 继承自ScrollView，目标是解决异构（与TableView的同构对比）滚动视图的复用回收问题。它可以支持跨View层的复用，用易用方式来生成一个高性能的滚动视图。此方案最先在天猫iOS客户端的首页落地。 —-苹果核 - iOS 高性能异构滚动视图构建方案 —— LazyScrollView 在这篇文章中，博主详细介绍了LazyScrollView的使用和实现方案，但是并没有给出具体DEMO，这里只是站在巨人的肩膀上，给一个DEMO，同时也希望可以抛砖引玉。","text":"LazyScrollView简介 LazyScrollView 继承自ScrollView，目标是解决异构（与TableView的同构对比）滚动视图的复用回收问题。它可以支持跨View层的复用，用易用方式来生成一个高性能的滚动视图。此方案最先在天猫iOS客户端的首页落地。 —-苹果核 - iOS 高性能异构滚动视图构建方案 —— LazyScrollView 在这篇文章中，博主详细介绍了LazyScrollView的使用和实现方案，但是并没有给出具体DEMO，这里只是站在巨人的肩膀上，给一个DEMO，同时也希望可以抛砖引玉。 LazyScrollView使用暂时的实现比较简陋，目前只有一个id&lt;LazyScrollViewDataSource&gt; dataSource;，需要实现下面三个接口： 123456789@protocol LazyScrollViewDataSource &lt;NSObject&gt;@required// ScrollView一共展示多少个item- (NSUInteger)numberOfItemInScrollView:(LazyScrollView *)scrollView;// 要求根据index直接返回RectModel- (LSVRectModel *)scrollView:(LazyScrollView *)scrollView rectModelAtIndex:(NSUInteger)index;// 返回下标所对应的view- (UIView *)scrollView:(LazyScrollView *)scrollView itemByLsvId:(NSString *)lsvId;@end 其中LSVRectModel就是原文中的TMMuiRectModel： 1234567@interface LSVRectModel : NSObject// 转换后的绝对值rect@property (nonatomic, assign) CGRect absRect;// 业务下标@property (nonatomic, copy) NSString *lsvId;+ (instancetype)modelWithRect:(CGRect)rect lsvId:(NSString *)lsvId;@end 三个接口都很简单，和UITableView很类似，如果有不清楚，可以在底部查看DEMO或者原文。 另外，LazyScrollView提供了三个接口，也都是仿照UITableView来的，所以整个LazyScrollView的使用应该是很容易上手的： 123- (void)reloadData;- (UIView *)dequeueReusableItemWithIdentifier:(NSString *)identifier;- (void)registerClass:(Class)viewClass forViewReuseIdentifier:(NSString *)identifier; LazyScrollView实现最主要的思路就是复用，所以有两个View池： 12@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, NSMutableSet *&gt; *reuseViews;@property (nonatomic, strong) NSMutableSet&lt;__kindof UIView *&gt; *visibleViews; 由于每个View可能对应不同的identifier，所以reuseViews是一个NSMutableDictionary。当一个View滑出可见区域之后，会将它先从visibleViews中移除，然后添加到reuseViews中，并从LazyScrollView中 remove，即调用removeFromSuperview。这个地方在原文中作者的表述可能让大家误会了。 LazyScrollView中有一个Dictionary，key是reuseIdentifier,Value是对应reuseIdentifier被回收的View，当LazyScrollView得知这个View不该再出现了，会把View放在这里，并且把这个View hidden掉。 这里作者用的是hidden掉，但是我们知道，hidden只是控制显隐，View本身还是在那里，也无法去复用。 而当一个View滑到可见区域内时，需要先从reuseViews中复用，如果reuseViews没有，则重新创建一个。相关实现请看- (UIView *)dequeueReusableItemWithIdentifier:(NSString *)identifier;。 最后一个问题就是如何判断一个View是在可见区域内的。这里原文中说的很清晰，还有图片配合。建议大家还是移步原文。这里我简单说一下，找到顶边大于contentOffset.y - BUFFER_HEIGHT，底边小于contentOffset.y+CGRectGetHeight(self.bounds) + BUFFER_HEIGHT，然后两个集合取交集就是需要显示的View集合了。当然，这里有一些处理算法： 对 顶边 做升序处理得到一个集合，对 底边 降序处理得到一个集合。 采用二分法查找合适的位置，然后再对上一步得到的集合取子集即可。 好了，说了这么多，先放出DEMO地址吧，希望大家可以帮助完善，也希望可以给个Star。https://github.com/HistoryZhang/LazyScrollView。原文地址：苹果核 - iOS 高性能异构滚动视图构建方案 —— LazyScrollView（里面还有很多干货）。 最后说一下目前写的几个问题，希望大家可以一起来优化： 没有处理View点击事件，即没有写delegate回调。 二分法查找合适位置的时候算法待优化。 从旧的visibleViews中移除被滑出的View算法待优化。 贴一段第二个问题的代码： 1234567891011121314151617181920212223242526- (NSMutableSet *)findSetWithMinEdge:(CGFloat)minEdge &#123; NSArray *ascendingEdgeArray = [self.allRects sortedArrayUsingComparator:^NSComparisonResult(LSVRectModel *obj1, LSVRectModel *obj2) &#123; return CGRectGetMinY(obj1.absRect) &gt; CGRectGetMinY(obj2.absRect) ? NSOrderedDescending : NSOrderedAscending; &#125;]; // TOOD: 此处待优化 // 二分法 NSInteger minIndex = 0; NSInteger maxIndex = ascendingEdgeArray.count - 1; NSInteger midIndex = (minIndex + maxIndex) / 2; LSVRectModel *model = ascendingEdgeArray[midIndex]; while (minIndex &lt; maxIndex - 1) &#123; if (CGRectGetMinY(model.absRect) &gt; minEdge) &#123; maxIndex = midIndex; &#125; else &#123; minIndex = midIndex; &#125; midIndex = (minIndex + maxIndex) / 2; model = ascendingEdgeArray[midIndex]; &#125; midIndex = MAX(midIndex - 1, 0); NSArray *array = [ascendingEdgeArray subarrayWithRange:NSMakeRange(midIndex, ascendingEdgeArray.count - midIndex)]; return [NSMutableSet setWithArray:array];&#125; 再贴一段第三个问题的代码： 12345678910111213 NSMutableArray *newVisibleViews = [self visiableViewModels].mutableCopy; NSMutableArray *newVisibleLsvIds = [newVisibleViews valueForKey:@&quot;lsvId&quot;]; NSMutableArray *removeViews = [NSMutableArray array]; for (UIView *view in self.visibleViews) &#123; if (![newVisibleLsvIds containsObject:view.lsvId]) &#123; [removeViews addObject:view]; &#125; &#125; for (UIView *view in removeViews) &#123; [self.visibleViews removeObject:view]; [self enqueueReusableView:view]; [view removeFromSuperview]; &#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"LazyScrollView","slug":"LazyScrollView","permalink":"https://kelvinqq.github.io/tags/LazyScrollView/"},{"name":"高性能","slug":"高性能","permalink":"https://kelvinqq.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"}]},{"title":"iOS创建单例","slug":"iOS创建单例","date":"2016-11-01T12:01:31.000Z","updated":"2021-08-27T13:34:42.825Z","comments":true,"path":"2016/11/01/iOS创建单例/","link":"","permalink":"https://kelvinqq.github.io/2016/11/01/iOS%E5%88%9B%E5%BB%BA%E5%8D%95%E4%BE%8B/","excerpt":"在开发过程中经常会遇到需要单例的时候，然后很多时候大家写的单例其实并不符合要求。下面介绍一个标准的单例。 一般来说，我还是喜欢用GCD来创建单例，使用dispatch_once很方便。","text":"在开发过程中经常会遇到需要单例的时候，然后很多时候大家写的单例其实并不符合要求。下面介绍一个标准的单例。 一般来说，我还是喜欢用GCD来创建单例，使用dispatch_once很方便。 1234567891011static id _instance; + (instancetype)sharedInstance &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _instance = [[self alloc] init]; &#125;); return _instance; &#125; 上面说的并不符合要求就是这样创建出来的单例。很多人以为这样就可以了，dispatch_once保证了只运行一次。然而，如果一个不知情的人调用了你写的类，你无法保证他不去调用alloc，copy来生成实例。所以我们还要做一些其他的处理。 1234567891011121314151617+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; _instance = [super allocWithZone:zone]; &#125;); return _instance; &#125; - (id)copyWithZone:(NSZone *)zone &#123; return _instance; &#125; - (id)mutableCopyWithZone:(NSZone *)zone &#123; return _instance; &#125; 这样就可以了。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"单例","slug":"单例","permalink":"https://kelvinqq.github.io/tags/%E5%8D%95%E4%BE%8B/"}]},{"title":"iOS10下使用AutoLayout动画失效解决","slug":"iOS10下使用AutoLayout动画失效解决","date":"2016-11-01T11:57:31.000Z","updated":"2021-08-27T13:34:42.824Z","comments":true,"path":"2016/11/01/iOS10下使用AutoLayout动画失效解决/","link":"","permalink":"https://kelvinqq.github.io/2016/11/01/iOS10%E4%B8%8B%E4%BD%BF%E7%94%A8AutoLayout%E5%8A%A8%E7%94%BB%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3/","excerpt":"更新到 iOS10 后，原来使用 AutoLayout 自定义的控件做了一些简单的动画失效了，但是在 iOS10 以下还是正常的。于是 Google 了一番，终于又是在 http://stackoverflow.com 找到了解决办法。","text":"更新到 iOS10 后，原来使用 AutoLayout 自定义的控件做了一些简单的动画失效了，但是在 iOS10 以下还是正常的。于是 Google 了一番，终于又是在 http://stackoverflow.com 找到了解决办法。 123456789101112[UIView animateWithDuration:0.3 delay:0 options:UIViewAnimationOptionCurveEaseOut animations:^&#123; [self mas_updateConstraints:^(MASConstraintMaker *make) &#123; &#125;]; [self layoutIfNeeded]; &#125; completion:^(BOOL finished) &#123; &#125;]; 原来我们的代码应该是类似这样的，使用 layoutIfNeeded 强制刷新然后执行动画。iOS10 以后需要使用 [self.superview layoutIfNeeded]; 。这样消失的动画就又出来了。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"AutoLayout","slug":"AutoLayout","permalink":"https://kelvinqq.github.io/tags/AutoLayout/"},{"name":"iOS10","slug":"iOS10","permalink":"https://kelvinqq.github.io/tags/iOS10/"}]},{"title":"Xcode多Target设置","slug":"Xcode多Target设置","date":"2016-10-01T14:32:11.000Z","updated":"2021-08-27T13:34:42.823Z","comments":true,"path":"2016/10/01/Xcode多Target设置/","link":"","permalink":"https://kelvinqq.github.io/2016/10/01/Xcode%E5%A4%9ATarget%E8%AE%BE%E7%BD%AE/","excerpt":"有时候一个项目会分为多个版本，比如免费版、收费版，或者对于不同的客户定制不同版本。但是大体上功能都是差不多，只是部分页面稍有区别。如果每个版本都建一个工程又显得麻烦了，都放在一个 Target 又得写一堆的代码去区分甄别，而且在打包的时候很可能因为参数配置错误需要一而再、再而三的打包。 这个时候我们就可以用多 Target 来操作了。具体方法且听我一一道来。","text":"有时候一个项目会分为多个版本，比如免费版、收费版，或者对于不同的客户定制不同版本。但是大体上功能都是差不多，只是部分页面稍有区别。如果每个版本都建一个工程又显得麻烦了，都放在一个 Target 又得写一堆的代码去区分甄别，而且在打包的时候很可能因为参数配置错误需要一而再、再而三的打包。 这个时候我们就可以用多 Target 来操作了。具体方法且听我一一道来。 * 首先我们得有一个工程，这里我就新建一个基本的模板工程。工程的样子应该是这样。（我已经升级到 Xcode8 了，有什么不同之处请不要在意。） * 然后我们进入工程设置，右击中间的 TARGETS ，会有个选择让你 Duplicate 还是 Delete ，这里我们选择 Duplicate。 结果就是下面这个样子了，多个一个 Target 叫 MultiTarget copy ，还多了一个 plist 文件叫 MultiTarget copy-Info.plist。 * 接下来首先想到的应该是改名字，毕竟 XXX copy 不怎么友好。目前我所知道的方法只有一个一个的改。 囧。 如果你有好的方法，可以留言给我。 改完 plist 的名字后，需要在工程设置里面重新选择一下 Info.plist 。改完之后就像下图一样。我列了一下我改的几个地方。但是我记得早期版本的 Xcode 好像还需要修改 Build Settings 里面的一些东西。不过我的 Xcode8 好像不需要了。大家在做的时候注意一下。 PS：忘了修改Bundle Identifier了，大家记得改一下 * 最后一步就是做版本区分了。首先我们在 PRO 版本中定义一个宏 PRO_VERSION，写在 Build Settings 里面。一定记得先选择 PRO Target。这个作用就是告诉编译器，我们在编译该 Target 时会有个全局的宏叫做 PRO_VERSION。这个时候我们就可以利用这个宏来做一些代码区分了。 * 最后我们测试一下。我们在 ViewController 里面增加一个 UILabel ，方便起见，我就直接写 frame 了，在两个不同版本显示不同的文本。代码如下。 123456789 UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 50, CGRectGetWidth([UIScreen mainScreen].bounds), 80)]; label.textAlignment = NSTextAlignmentCenter; [self.view addSubview:label]; #ifdef PRO_VERSION label.text = @&quot;这是PRO版本&quot;;#else label.text = @&quot;这是NORMAL版本&quot;;#endif 当然，编译哪个版本需要选择对应的 Scheme。下面放两张截图。 * 还有个事情就是图标，其实也可以设置的。打开 Assets.xcassets，会发现已经有一个 AppIcon 了，我们再copy一份出来，然后改个名字，换一下图标，就是这样的效果。 当然并没有结束，因为我们只是添加了资源，并没有用到。还是在工程设置里面，有个 App Icons Source ，选择一下就可以了。当然，我们还可以配置启动画面等等，这里就不演示了。 最后放一张两个 App 的图标，注意修改 Bundle Identifier，不然你不会运行出两个 App 的。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"多Target","slug":"多Target","permalink":"https://kelvinqq.github.io/tags/%E5%A4%9ATarget/"},{"name":"多版本","slug":"多版本","permalink":"https://kelvinqq.github.io/tags/%E5%A4%9A%E7%89%88%E6%9C%AC/"}]},{"title":"FFmpeg解码流程","slug":"FFmpeg解码流程","date":"2016-09-30T12:11:56.000Z","updated":"2021-08-27T13:34:42.820Z","comments":true,"path":"2016/09/30/FFmpeg解码流程/","link":"","permalink":"https://kelvinqq.github.io/2016/09/30/FFmpeg%E8%A7%A3%E7%A0%81%E6%B5%81%E7%A8%8B/","excerpt":"以下系列文章基于FFmpeg 3.1.1和Xcode8。FFmpeg iOS库编译与集成FFmpeg解码流程 学习 FFmpeg ，就不得不提到一位大神，就是 雷霄骅，可惜天妒英才，在这里也先缅怀一下，同时也感谢他在视音频领域以及 FFmpeg 解析上做出的贡献。 我们先了解一下视频播放的流程，这里主要参考的是雷神的文章，[总结]视音频编解码技术零基础学习方法 。过程见下图（图片同样来自雷神的文章，红色框框是我注解的）。","text":"以下系列文章基于FFmpeg 3.1.1和Xcode8。FFmpeg iOS库编译与集成FFmpeg解码流程 学习 FFmpeg ，就不得不提到一位大神，就是 雷霄骅，可惜天妒英才，在这里也先缅怀一下，同时也感谢他在视音频领域以及 FFmpeg 解析上做出的贡献。 我们先了解一下视频播放的流程，这里主要参考的是雷神的文章，[总结]视音频编解码技术零基础学习方法 。过程见下图（图片同样来自雷神的文章，红色框框是我注解的）。 播放一个互联网上的视频文件，需要经过以下几个步骤：解协议，解封装，解码视音频，视音频同步。如果播放本地文件则不需要解协议，为以下几个步骤：解封装，解码视音频，视音频同步。 关于每个步骤的含义还是去雷神的文章去看，这里就不啰嗦了。 本文重点讨论的是解封装、解码视频。对于音频的处理先不管。 解码的作用，就是将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。 好了，说了这么多理论，说点实在的。 FFmpeg 解码流程所需要调用的 API 依次为： 123456789101112开始—-&gt;av_register_all();avformat_open_input()；av_find_stream_info();av_find_best_stream();avcodec_find_decoder();while(av_read_frame()) &#123; 获取到packet—-&gt; avcodec_send_packet(); avcodec_receive_frame(); 获取到frame&#125; 上面的流程参考 笔谈FFmpeg（一），其中有几个函数弃用了，所以我更新了一下。 简单的说一下更新的几个函数，其他的网上介绍的很多了，后面我也会推荐几篇文章。 av_find_best_stream()： 之前用的都是这样的方法： 穷举所有的流，查找其中种类为CODEC_TYPE_VIDEO 。所以看别人的文章会有个 while 的循环。 avcodec_send_packet();avcodec_receive_frame();： 之前用的是 avcodec_decode_video2() 。后来 FFmpeg 把函数拆分了。 还有个需要注意的，avcodec_find_decoder(); 步骤中所用到的也有所变动。下面是以前的用法： 12pCodecCtx = pFormatCtx-&gt;streams[videoindex]-&gt;codec; pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id); 下面是变动之后的用法： 123pCodecCtx = avcodec_alloc_context3(NULL);avcodec_parameters_to_context(pCodecCtx, pFormatCtx-&gt;streams[videoStream]-&gt;codecpar);pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id); 通过以上的步骤，获取到 frame 数据就是解码后的原始视频数据。后面我们的存储或者播放也都是基于这个数据的。 参考文章列表： 100行代码实现最简单的基于FFMPEG+SDL的视频播放器（SDL1.x） 作者：雷霄骅 笔谈FFmpeg（一） 作者：Minmin.Sun ffmpeg解码流程 作者：cyning4星运","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://kelvinqq.github.io/categories/FFmpeg/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://kelvinqq.github.io/tags/FFmpeg/"}]},{"title":"FFmpeg iOS库编译与集成","slug":"FFmpeg iOS库编译与集成","date":"2016-09-26T13:44:05.000Z","updated":"2021-08-27T13:34:42.820Z","comments":true,"path":"2016/09/26/FFmpeg iOS库编译与集成/","link":"","permalink":"https://kelvinqq.github.io/2016/09/26/FFmpeg%20iOS%E5%BA%93%E7%BC%96%E8%AF%91%E4%B8%8E%E9%9B%86%E6%88%90/","excerpt":"以下系列文章基于FFmpeg 3.1.1和Xcode8。FFmpeg iOS库编译与集成FFmpeg解码流程由于FFmpeg工程太大，很难一下子理解透彻，所以就边看边记一些笔记，理清一下思路，顺便也留给其他人一些意见。","text":"以下系列文章基于FFmpeg 3.1.1和Xcode8。FFmpeg iOS库编译与集成FFmpeg解码流程由于FFmpeg工程太大，很难一下子理解透彻，所以就边看边记一些笔记，理清一下思路，顺便也留给其他人一些意见。 1. 下载FFmpeg的源码编译iOS库。而编译FFmpeg还需要另外两项的支持 https://github.com/libav/gas-preprocessor yasm 这样就比较复杂，如果想自己一步一步的按照流程来做，可以参考这篇文章 iOS配置FFmpeg框架(原创) 。 所以 Github 上有个开源的脚本，https://github.com/kewlbear/FFmpeg-iOS-build-script ，下载之后，直接 ./build-ffmpeg.sh，脚本会自动帮你下载相关文件以及配置。 编译成功之后，就会在文件夹里面看到 FFmpeg-iOS 的文件夹，里面就是静态库，还有个 ffmpeg-3.1.1 的文件夹，就是源码。当然，如果你熟悉脚本语言可以看一下里面的脚本，可以修改一些配置，达到你想要的结果。这里暂时先不展开了。 2. 集成静态库至Xcode 新建工程。 新建一个 Single View Application ，然后将 FFmpeg-iOS 文件夹拖进工程。然后需要在 Build Setting 里面配置一下 Header Search Paths ，需要将 include 以及 include 下面的子文件夹都配置进去。 添加依赖库。 需要添加以下几个 framework 和 lib ： CoreMedia.framework ， VideoToolbox.framework ， AudioToolbox.framework ， libiconv.2.4.0.tbd ， libbz2.1.0.tbd ， libz.1.2.5.tbd。 编译 在 ViewController 里包含头文件 #import &quot;avcodec.h&quot;， 然后在 viewDidLoad 中调用 avcodec_register_all(); ，应该就可以编译通过了。 在我的 Xcode8 中会有一堆警告，提示 empty paragraph passed to @param command ，这里我们需要处理一下。在引用头文件的时候使用宏包含一下。 123456#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wdocumentation&quot;#import &quot;avcodec.h&quot;#pragma clang pop 至此，FFmpeg 就集成完毕了。","categories":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://kelvinqq.github.io/categories/FFmpeg/"}],"tags":[{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://kelvinqq.github.io/tags/FFmpeg/"}]},{"title":"Podfile引用第三方库设定版本","slug":"Podfile引用第三方库设定版本","date":"2015-09-25T00:11:54.000Z","updated":"2021-09-05T14:35:28.418Z","comments":true,"path":"2015/09/25/Podfile引用第三方库设定版本/","link":"","permalink":"https://kelvinqq.github.io/2015/09/25/Podfile%E5%BC%95%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E8%AE%BE%E5%AE%9A%E7%89%88%E6%9C%AC/","excerpt":"在使用cocoapods引用第三方库时，可以使用如下规则规定引用三方库的版本。","text":"在使用cocoapods引用第三方库时，可以使用如下规则规定引用三方库的版本。 123456789pod &#x27;AFNetworking’ // 不显式指定依赖库版本，表示每次都获取最新版本pod &#x27;AFNetworking’, &#x27;2.0’ //只使用2.0版本pod &#x27;AFNetworking’, &#x27;&gt;2.0&#x27; //使用高于2.0的版本pod &#x27;AFNetworking’, &#x27;&gt;=2.0&#x27; //使用大于或等于2.0的版本pod &#x27;AFNetworking’, &#x27;&lt;2.0&#x27; //使用小于2.0的版本pod &#x27;AFNetworking’, &#x27;&lt;=2.0&#x27; //使用小于或等于2.0的版本pod &#x27;AFNetworking’, &#x27;~&gt;0.1.2&#x27; //使用大于等于0.1.2但小于0.2的版本，相当于&gt;=0.1.2并且&lt;0.2.0pod &#x27;AFNetworking’, &#x27;~&gt;0.1&#x27; //使用大于等于0.1但小于1.0的版本pod &#x27;AFNetworking’, &#x27;~&gt;0&#x27; //高于0的版本，写这个限制和什么都不写是一个效果，都表示使用最新版本","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://kelvinqq.github.io/tags/CocoaPods/"}]},{"title":"GeoHash系列 —— 二、算法步骤","slug":"GeoHash系列 —— 二、算法步骤","date":"2015-08-27T08:37:58.000Z","updated":"2021-08-27T13:34:42.820Z","comments":true,"path":"2015/08/27/GeoHash系列 —— 二、算法步骤/","link":"","permalink":"https://kelvinqq.github.io/2015/08/27/GeoHash%E7%B3%BB%E5%88%97%20%E2%80%94%E2%80%94%20%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4/","excerpt":"系列文章 GeoHash系列 —— 一、基本介绍 GeoHash系列 —— 二、算法步骤 上集回顾上一篇文章我们简单了了解了一下GeoHash的思想，你可以通过这个链接来查看上一篇文章。 算法步骤以下以北海公园为例介绍GeoHash算法的计算步骤。 根据经纬度计算GeoHash二进制编码 地球纬度区间是[-90,90]， 北海公园的纬度是39.928167，可以通过下面算法对纬度39.928167进行逼近编码: 1）区间[-90,90]进行二分为[-90,0),[0,90]，称为左右区间，可以确定39.928167属于右区间[0,90]，给标记为1； 2）接着将区间[0,90]进行二分为 [0,45),[45,90]，可以确定39.928167属于左区间 [0,45)，给标记为0； 3）递归上述过程39.928167总是属于某个区间[a,b]。随着每次迭代区间[a,b]总在缩小，并越来越逼近39.928167； 4）如果给定的纬度x（39.928167）属于左区间，则记录0，如果属于右区间则记录1，这样随着算法的进行会产生一个序列1011100，序列的长度跟给定的区间划分次数有关。","text":"系列文章 GeoHash系列 —— 一、基本介绍 GeoHash系列 —— 二、算法步骤 上集回顾上一篇文章我们简单了了解了一下GeoHash的思想，你可以通过这个链接来查看上一篇文章。 算法步骤以下以北海公园为例介绍GeoHash算法的计算步骤。 根据经纬度计算GeoHash二进制编码 地球纬度区间是[-90,90]， 北海公园的纬度是39.928167，可以通过下面算法对纬度39.928167进行逼近编码: 1）区间[-90,90]进行二分为[-90,0),[0,90]，称为左右区间，可以确定39.928167属于右区间[0,90]，给标记为1； 2）接着将区间[0,90]进行二分为 [0,45),[45,90]，可以确定39.928167属于左区间 [0,45)，给标记为0； 3）递归上述过程39.928167总是属于某个区间[a,b]。随着每次迭代区间[a,b]总在缩小，并越来越逼近39.928167； 4）如果给定的纬度x（39.928167）属于左区间，则记录0，如果属于右区间则记录1，这样随着算法的进行会产生一个序列1011100，序列的长度跟给定的区间划分次数有关。 根据纬度算编码 bit min mid max 1 -90.000 0.000 90.000 0 0.000 45.000 90.000 1 0.000 22.500 45.000 1 22.500 33.750 45.000 1 33.7500 39.375 45.000 0 39.375 42.188 45.000 0 39.375 40.7815 42.188 0 39.375 40.07825 40.7815 1 39.375 39.726625 40.07825 1 39.726625 39.9024375 40.07825 同理，地球经度区间是[-180,180]，可以对经度116.389550进行编码。 bit min mid max 1 -180 0.000 180 1 0.000 90 180 0 90 135 180 1 90 112.5 135 0 112.5 123.75 135 0 112.5 118.125 123.75 1 112.5 115.3125 118.125 0 115.3125 116.71875 118.125 1 115.3125 116.015625 116.71875 1 116.015625 116.3671875 116.71875 组码 通过上述计算，纬度产生的编码为10111 00011，经度产生的编码为11010 01011。偶数位放经度，奇数位放纬度，把2串编码组合生成新串：11100 11101 00100 01111。 最后使用用0-9、b-z（去掉a, i, l, o）这32个字母进行base32编码，首先将11100 11101 00100 01111转成十进制，对应着28、29、4、15，十进制对应的编码就是wx4g。同理，将编码转换成经纬度的解码算法与之相反，具体不再赘述。 编码长度与精度下表摘自维基百科：http://en.wikipedia.org/wiki/Geohash 以看出，当geohash base32编码长度为8时，精度在19米左右，而当编码长度为9时，精度在2米左右，编码长度需要根据数据情况进行选择。 下集预告本篇主要说了一下将经纬度转化为字符串编码，下一节将解释一下上述做法的原理。","categories":[{"name":"Geohash系列","slug":"Geohash系列","permalink":"https://kelvinqq.github.io/categories/Geohash%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Geohash","slug":"Geohash","permalink":"https://kelvinqq.github.io/tags/Geohash/"}]},{"title":"GeoHash系列 —— 一、基本介绍","slug":"GeoHash系列 —— 一、基本介绍","date":"2015-08-26T01:47:41.000Z","updated":"2021-08-27T13:34:42.820Z","comments":true,"path":"2015/08/26/GeoHash系列 —— 一、基本介绍/","link":"","permalink":"https://kelvinqq.github.io/2015/08/26/GeoHash%E7%B3%BB%E5%88%97%20%E2%80%94%E2%80%94%20%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/","excerpt":"系列文章 GeoHash系列 —— 一、基本介绍 GeoHash系列 —— 二、算法步骤 引子目前很多的App都会使用到用户的地理位置信息，然后为用户提供相关服务，也就是我们所说的LBS。而LBS最基本的就是附近。所以就会有这样的一个问题： 什么样叫附近？ 简单来说，附件就是以我为圆心，radius为半径画一个圆，圆内的都叫附近。 然而事实并没有这么简单。比如我要在地图上找附近的餐馆，不可能说把所有的餐馆和我的距离都算一遍，然后和radius比较。 稍微有点编程基础的应该都不会用这个办法。 其实那么庞大的数据，只有一小部分是我们想要的，这样我们通过某种方法来过滤掉不要的餐馆，减少计算的量，就避免了上述方法的弊端。 这样我们可以使用索引技术。","text":"系列文章 GeoHash系列 —— 一、基本介绍 GeoHash系列 —— 二、算法步骤 引子目前很多的App都会使用到用户的地理位置信息，然后为用户提供相关服务，也就是我们所说的LBS。而LBS最基本的就是附近。所以就会有这样的一个问题： 什么样叫附近？ 简单来说，附件就是以我为圆心，radius为半径画一个圆，圆内的都叫附近。 然而事实并没有这么简单。比如我要在地图上找附近的餐馆，不可能说把所有的餐馆和我的距离都算一遍，然后和radius比较。 稍微有点编程基础的应该都不会用这个办法。 其实那么庞大的数据，只有一小部分是我们想要的，这样我们通过某种方法来过滤掉不要的餐馆，减少计算的量，就避免了上述方法的弊端。 这样我们可以使用索引技术。 一提到索引，大家脑子里马上浮现出B树索引，因为大量的数据库（如MySQL、oracle、PostgreSQL等）都在使用B树。B树索引本质上是对索引字段进行排序，然后通过类似二分查找的方法进行快速查找，即它要求索引的字段是可排序的，一般而言，可排序的是一维字段，比如时间、年龄、薪水等等。但是对于空间上的一个点（二维，包括经度和纬度），如何排序呢？又如何索引呢？解决的方法很多，下文介绍一种方法来解决这一问题。 思想：如果能通过某种方法将二维的点数据转换成一维的数据，那样不就可以继续使用B树索引了嘛。那这种方法真的存在嘛，答案是肯定的。目前很火的GeoHash算法就是运用了上述思想，下面我们就开始GeoHash之旅吧。 基本介绍 GeoHash将二维的经纬度转换成字符串，每个字符串代表某一矩形区域。这样，矩形内所有的点（经纬度）都共享相同的GeoHash字符串，这样就比较容易做缓存。例如下图展示了北京9个区域的GeoHash字符串。例如左上角这个区域内的用户不断发送位置信息请求餐馆数据，由于这些用户的GeoHash字符串都是WX4ER，所以可以把WX4ER当作key，把该区域的餐馆信息当作value来进行缓存，而如果不使用GeoHash的话，由于区域内的用户传来的经纬度是各不相同的，很难做缓存。 字符串越长，表示的范围越精确。5位的编码能表示10平方千米范围的矩形区域，而6位编码能表示更精细的区域（约0.34平方千米）。 字符串相似的表示距离相近（特殊情况后文阐述），这样可以利用字符串的前缀匹配来查询附近的POI信息。如下两个图所示，一个在城区，一个在郊区，城区的GeoHash字符串之间比较相似，郊区的字符串之间也比较相似，而城区和郊区的GeoHash字符串相似程度要低些。 通过上面的介绍我们知道了GeoHash就是一种将经纬度转换成字符串的方法，并且使得在大部分情况下，字符串前缀匹配越多的距离越近，回到我们的案例，根据所在位置查询来查询附近餐馆时，只需要将所在位置经纬度转换成GeoHash字符串，并与各个餐馆的GeoHash字符串进行前缀匹配，匹配越多的距离越近。 下集预告GeoHash算法的步骤","categories":[{"name":"Geohash系列","slug":"Geohash系列","permalink":"https://kelvinqq.github.io/categories/Geohash%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Geohash","slug":"Geohash","permalink":"https://kelvinqq.github.io/tags/Geohash/"}]},{"title":"UIScrollView点击StatusBar返回顶部失效的解决","slug":"UIScrollView点击StatusBar返回顶部失效的解决","date":"2015-08-21T00:47:45.000Z","updated":"2021-08-27T13:34:42.823Z","comments":true,"path":"2015/08/21/UIScrollView点击StatusBar返回顶部失效的解决/","link":"","permalink":"https://kelvinqq.github.io/2015/08/21/UIScrollView%E7%82%B9%E5%87%BBStatusBar%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8%E5%A4%B1%E6%95%88%E7%9A%84%E8%A7%A3%E5%86%B3/","excerpt":"前几天看到一篇文章，关于如何解决在一个Vieww中有多个UIScrollView或者UIScrollView子类时，点击StatusBar无法使UIScrollView返回到顶部的文章。总得思想是自定义一个View，然后覆盖在StatusBar上，给这个View添加点击事件。具体文章链接在这里。有兴趣的朋友可以看一下。","text":"前几天看到一篇文章，关于如何解决在一个Vieww中有多个UIScrollView或者UIScrollView子类时，点击StatusBar无法使UIScrollView返回到顶部的文章。总得思想是自定义一个View，然后覆盖在StatusBar上，给这个View添加点击事件。具体文章链接在这里。有兴趣的朋友可以看一下。 其实我们查看UIScrollView的头文件就可以找到这段注释： 123// When the user taps the status bar, the scroll view beneath the touch which is closest to the status bar will be scrolled to top, but only if its `scrollsToTop` property is YES, its delegate does not return NO from `shouldScrollViewScrollToTop`, and it is not already at the top.// On iPhone, we execute this gesture only if there&#x27;s one on-screen scroll view with `scrollsToTop` == YES. If more than one is found, none will be scrolled.@property(nonatomic) BOOL scrollsToTop; // default is YES. 这样我们就可以很清楚的了解到，scrollsToTop的默认值是YES，然而当有多个UIScrollView的时候，用户点击StatusBar，系统就不知道让哪一个UIScrollView来执行scrollsToTop这个动作了，所以就导致失效了。 这样一来，解决方法就很简单了，设置你想要执行scrollsToTop的UIScrollView的@property(nonatomic) BOOL scrollsToTop;属性值为YES，其他的UIScrollView都为NO即可。 注意：凡是UIScrollView以及UIScrollView的子类都要设置。如:UITableView，UIWebView，UICollectionView等。","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"ScrollView","slug":"ScrollView","permalink":"https://kelvinqq.github.io/tags/ScrollView/"}]},{"title":"房贷个税一个都不能少","slug":"房贷个税一个都不能少","date":"2015-06-12T07:14:31.000Z","updated":"2021-09-05T14:38:40.532Z","comments":true,"path":"2015/06/12/房贷个税一个都不能少/","link":"","permalink":"https://kelvinqq.github.io/2015/06/12/%E6%88%BF%E8%B4%B7%E4%B8%AA%E7%A8%8E%E4%B8%80%E4%B8%AA%E9%83%BD%E4%B8%8D%E8%83%BD%E5%B0%91/","excerpt":"打个广告最近趁着稍闲,做了个APP,计算房贷和个税的.也不知道起个啥名字,暂时就叫 综合计算器. 刚刚送上线.话说苹果审核真麻烦.又拖了我2个星期. 如果有需要的话可以支持一下哦~","text":"打个广告最近趁着稍闲,做了个APP,计算房贷和个税的.也不知道起个啥名字,暂时就叫 综合计算器. 刚刚送上线.话说苹果审核真麻烦.又拖了我2个星期. 如果有需要的话可以支持一下哦~ 当初做的时候也是处于懒得装两个APP,毕竟一个小功能,于是就有了这个综合版,顺便赚点外快. 再来个二维码 ps: 1.如果你有好的命名可以发邮件给我哦~ 2.如果你想做安卓版也可以发邮件给我哦~ 3.如果你有其他想法也可以发邮件给我哦~ 下面是我的邮箱: history_zq@163.com","categories":[{"name":"日记","slug":"日记","permalink":"https://kelvinqq.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"计算器","slug":"计算器","permalink":"https://kelvinqq.github.io/tags/%E8%AE%A1%E7%AE%97%E5%99%A8/"}]},{"title":"App内打开AppStore","slug":"App内打开AppStore","date":"2015-05-19T06:53:17.000Z","updated":"2021-08-27T13:34:42.819Z","comments":true,"path":"2015/05/19/App内打开AppStore/","link":"","permalink":"https://kelvinqq.github.io/2015/05/19/App%E5%86%85%E6%89%93%E5%BC%80AppStore/","excerpt":"iOS7以后可以在应用内打开AppStore展示另一个App.这样就可以直接下载了. 我们只要使用这段代码就可以了. 应用库文件 我们可以这样引用: @import StoreKit;","text":"iOS7以后可以在应用内打开AppStore展示另一个App.这样就可以直接下载了. 我们只要使用这段代码就可以了. 应用库文件 我们可以这样引用: @import StoreKit; 请求App 12345678910SKStoreProductViewController *storeProductVc = [[SKStoreProductViewController alloc] init]; storeProductVc.delegate = self; [storeProductVc loadProductWithParameters:@&#123; SKStoreProductParameterITunesItemIdentifier: @&quot;XXXXXXX&quot;, &#125; completionBlock:^(BOOL result, NSError *error) &#123; if (result) &#123; [self presentViewController:storeProductVc animated:YES completion:nil]; &#125; &#125;]; 实现delegate dismiss SKStoreProductViewController 1234- (void)productViewControllerDidFinish:(SKStoreProductViewController *)viewController&#123; [viewController dismissViewControllerAnimated:YES completion:nil];&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"AppStore","slug":"AppStore","permalink":"https://kelvinqq.github.io/tags/AppStore/"}]},{"title":"iOS8下TabBarController push后控件下移闪动","slug":"iOS8下TabBarController push后控件下移闪动","date":"2015-04-27T08:04:40.000Z","updated":"2021-09-05T14:34:41.611Z","comments":true,"path":"2015/04/27/iOS8下TabBarController push后控件下移闪动/","link":"","permalink":"https://kelvinqq.github.io/2015/04/27/iOS8%E4%B8%8BTabBarController%20push%E5%90%8E%E6%8E%A7%E4%BB%B6%E4%B8%8B%E7%A7%BB%E9%97%AA%E5%8A%A8/","excerpt":"使用TabBarController后,如果push下一个页面需要隐藏TabBar,而下一个页面中有个控件设置AutoLayout的时候设置了和页面底部的距离,那么会有个闪烁动画,控件会以动画的形式下移44px.该现象只在iOS8中有,iOS7未发现.","text":"使用TabBarController后,如果push下一个页面需要隐藏TabBar,而下一个页面中有个控件设置AutoLayout的时候设置了和页面底部的距离,那么会有个闪烁动画,控件会以动画的形式下移44px.该现象只在iOS8中有,iOS7未发现. 我们需要在设置AutoLayout的时候如下图修改一下即可修复这个动画.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"AutoLayout","slug":"AutoLayout","permalink":"https://kelvinqq.github.io/tags/AutoLayout/"}]},{"title":"iOS汉字转拼音","slug":"iOS汉字转拼音","date":"2014-12-12T08:58:02.000Z","updated":"2021-08-27T13:34:42.825Z","comments":true,"path":"2014/12/12/iOS汉字转拼音/","link":"","permalink":"https://kelvinqq.github.io/2014/12/12/iOS%E6%B1%89%E5%AD%97%E8%BD%AC%E6%8B%BC%E9%9F%B3/","excerpt":"汉字转拼音之前有很多人用的都是一个拼音库,pinyin.h和pinyin.m.用着还算方便吧. 后来发现苹果的framework提供了方法.于是在这里记录下来.","text":"汉字转拼音之前有很多人用的都是一个拼音库,pinyin.h和pinyin.m.用着还算方便吧. 后来发现苹果的framework提供了方法.于是在这里记录下来. 主要是用到这个方法:CFStringTransform.具体大家可以去头文件看看.这里就贴出代码了. - (NSString *)spelling &#123; if (self.length) &#123; NSMutableString *copy = [self mutableCopy]; CFStringTransform((__bridge CFMutableStringRef)copy, NULL, kCFStringTransformMandarinLatin, NO); // 得到带音调的拼音 CFStringTransform((__bridge CFMutableStringRef)copy, NULL, kCFStringTransformStripDiacritics, NO); // 过滤掉音调 每个汉字之间会用空格分开 [copy replaceOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot; options:NSCaseInsensitiveSearch range:NSMakeRange(0, copy.length)]; // 过滤掉空格 return copy; &#125; else &#123; return nil; &#125; &#125; 偷偷告诉大家一个神奇的事情,就是这个方法可以准确识别出重庆和重量.其他待测试.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"拼音","slug":"拼音","permalink":"https://kelvinqq.github.io/tags/%E6%8B%BC%E9%9F%B3/"}]},{"title":"UITableView多余分割线","slug":"UITableView多余分割线","date":"2014-12-04T06:35:20.000Z","updated":"2021-08-27T13:34:42.823Z","comments":true,"path":"2014/12/04/UITableView多余分割线/","link":"","permalink":"https://kelvinqq.github.io/2014/12/04/UITableView%E5%A4%9A%E4%BD%99%E5%88%86%E5%89%B2%E7%BA%BF/","excerpt":"UITableView会有多余的分割线,不论是否有内容都会显示出来,看着很心塞.于是这样: 设置UITableView的style为Group 实现以下DataSource","text":"UITableView会有多余的分割线,不论是否有内容都会显示出来,看着很心塞.于是这样: 设置UITableView的style为Group 实现以下DataSource 123456789- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section&#123; return 0.01f;&#125; - (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123; return 0.01f;&#125; 整个世界安静了.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"UITableView","slug":"UITableView","permalink":"https://kelvinqq.github.io/tags/UITableView/"}]},{"title":"iOS拨打电话","slug":"iOS拨打电话","date":"2014-09-05T13:53:07.000Z","updated":"2021-08-27T13:34:42.825Z","comments":true,"path":"2014/09/05/iOS拨打电话/","link":"","permalink":"https://kelvinqq.github.io/2014/09/05/iOS%E6%8B%A8%E6%89%93%E7%94%B5%E8%AF%9D/","excerpt":"iOS拨打电话公开的方法有两种,其他的是调用私有方法,是会被苹果拒绝的.下面记录一下. 第一种方法拨打完之后会停留在拨号盘,不会返回应用。","text":"iOS拨打电话公开的方法有两种,其他的是调用私有方法,是会被苹果拒绝的.下面记录一下. 第一种方法拨打完之后会停留在拨号盘,不会返回应用。 12[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;tel://123456789&quot;]]; 第二种方法拨打玩电话后会返回应用，但是拨打之前会有一个UIAlertView提示是否拨打。 1234UIWebView *callWebview =[[UIWebView alloc] init]; // 如果无效,则将callWebView置为成员变量NSURL *telURL =[NSURL URLWithString:@&quot;tel:10086&quot;];[callWebview loadRequest:[NSURLRequest requestWithURL:telURL]];[self.view addSubview:callWebview];","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"电话","slug":"电话","permalink":"https://kelvinqq.github.io/tags/%E7%94%B5%E8%AF%9D/"}]},{"title":"Runtime在Storyboard中的应用","slug":"Runtime在Storyboard中的应用","date":"2014-09-01T13:11:19.000Z","updated":"2021-08-27T13:34:42.822Z","comments":true,"path":"2014/09/01/Runtime在Storyboard中的应用/","link":"","permalink":"https://kelvinqq.github.io/2014/09/01/Runtime%E5%9C%A8Storyboard%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"正文Runtime真是无处不在啊,打开Storyboard后,我们添加一个View到界面中,选中View,切换属性卡到第三个,有一项是 User Defined Runtime Attributes,我们添加如下图两个Key Path并设置值.","text":"正文Runtime真是无处不在啊,打开Storyboard后,我们添加一个View到界面中,选中View,切换属性卡到第三个,有一项是 User Defined Runtime Attributes,我们添加如下图两个Key Path并设置值. 然后运行,果然可以看到我们设置的属性生效了.顿感强大.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"Runtime","slug":"Runtime","permalink":"https://kelvinqq.github.io/tags/Runtime/"}]},{"title":"Xcode自动打包ipa脚本","slug":"XCode自动打包ipa脚本","date":"2014-08-11T12:37:31.000Z","updated":"2021-08-27T13:34:42.823Z","comments":true,"path":"2014/08/11/XCode自动打包ipa脚本/","link":"","permalink":"https://kelvinqq.github.io/2014/08/11/XCode%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85ipa%E8%84%9A%E6%9C%AC/","excerpt":"首先申明转载:http://webfrogs.me/2012/09/19/buildipa/. iOS打包我们可以借助shell脚本来自动完成这项功能.具体做法如下:","text":"首先申明转载:http://webfrogs.me/2012/09/19/buildipa/. iOS打包我们可以借助shell脚本来自动完成这项功能.具体做法如下: 复制下面代码到文本中并保存为ipa_build.sh. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/bin/bash#--------------------------------------------# 功能：为Xcode工程打ipa包# 作者：ccf# E-mail:ccf.developer@gmail.com# 创建日期：2012/09/24#--------------------------------------------#参数判断if [ $# != 2 ] &amp;&amp; [ $# != 1 ];then echo &quot;Number of params error! Need one or two params!&quot; echo &quot;1.path of project(necessary) 2.name of ipa file(optional)&quot; exit elif [ ! -d $1 ];then echo &quot;Params Error!! The first param must be a dictionary.&quot; exit fi#工程绝对路径cd $1project_path=$(pwd)#build文件夹路径build_path=$&#123;project_path&#125;/build#工程配置文件路径project_name=$(ls | grep xcodeproj | awk -F.xcodeproj &#x27;&#123;print $1&#125;&#x27;)project_infoplist_path=$&#123;project_path&#125;/$&#123;project_name&#125;/$&#123;project_name&#125;-Info.plist#取版本号bundleShortVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; $&#123;project_infoplist_path&#125;)#取build值bundleVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleVersion&quot; $&#123;project_infoplist_path&#125;)#取bundle Identifier前缀#bundlePrefix=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleIdentifier&quot; `find . -name &quot;*-Info.plist&quot;` | awk -F$ &#x27;&#123;print $1&#125;&#x27;)#IPA名称if [ $# = 2 ];thenipa_name=$2fi#编译工程cd $project_pathxcodebuild || exit#打包cd $build_pathtarget_name=$(basename ./Release-iphoneos/*.app | awk -F. &#x27;&#123;print $1&#125;&#x27;)if [ $# = 1 ];thenipa_name=&quot;$&#123;target_name&#125;_$&#123;bundleShortVersion&#125;_build$&#123;bundleVersion&#125;_$(date +&quot;%Y%m%d&quot;)&quot;fiif [ -d ./ipa-build ];then rm -rf ipa-buildfimkdir -p ipa-build/Payloadcp -r ./Release-iphoneos/*.app ./ipa-build/Payload/cd ipa-buildzip -r $&#123;ipa_name&#125;.ipa *rm -rf Payload 为文件添加可执行权限,命令如下: 1chmod +x ipa_build.sh 使用如下命令开始打包. 1./ipa_build ....../ProjectDir Project 其中的两个参数分别为:项目路径和最终打包的ipa名. 执行完命令后会在ProjectDir文件夹下生成build文件夹,ipa文件就在build下的ipa-build文件夹中.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://kelvinqq.github.io/tags/shell/"},{"name":"自动打包","slug":"自动打包","permalink":"https://kelvinqq.github.io/tags/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/"}]},{"title":"cocos2d v3.x mac 安装","slug":"cocos2d v3.x mac 安装","date":"2014-08-08T12:46:28.000Z","updated":"2021-08-27T13:34:42.823Z","comments":true,"path":"2014/08/08/cocos2d v3.x mac 安装/","link":"","permalink":"https://kelvinqq.github.io/2014/08/08/cocos2d%20v3.x%20mac%20%E5%AE%89%E8%A3%85/","excerpt":"cocos2d v3.x 版本出来后,从配置安装到创建项目都是命令行,下面简单说一下. 官网下载最新版本Cocos2d-x,地址是 http://cn.cocos2d-x.org/download/. 解压后,在命令行中cp到文件夹,然后执行./setup.py,回车. 期间会有几次询问,是设置安卓SDK路径的,不设置安卓直接Enter跳过即可 123-&gt;Please enter the path of NDK_ROOT (or press Enter to skip):-&gt;Please enter the path of ANDROID_SDK_ROOT (or press Enter to skip):-&gt;Please enter the path of ANT_ROOT (or press Enter to skip): 之后就OK了,会有提示: 1Please execute command: &quot;source /Users/history/.bash_profile&quot; to make added system variables take effect","text":"cocos2d v3.x 版本出来后,从配置安装到创建项目都是命令行,下面简单说一下. 官网下载最新版本Cocos2d-x,地址是 http://cn.cocos2d-x.org/download/. 解压后,在命令行中cp到文件夹,然后执行./setup.py,回车. 期间会有几次询问,是设置安卓SDK路径的,不设置安卓直接Enter跳过即可 123-&gt;Please enter the path of NDK_ROOT (or press Enter to skip):-&gt;Please enter the path of ANDROID_SDK_ROOT (or press Enter to skip):-&gt;Please enter the path of ANT_ROOT (or press Enter to skip): 之后就OK了,会有提示: 1Please execute command: &quot;source /Users/history/.bash_profile&quot; to make added system variables take effect 根据提示敲击source /Users/history/.bash_profile后Enter,这样就算设置好了. 最后就是创建工程.继续命令行.cd tools/cocos2d-console/bin,接着使用下面命令即可:cocos new 工程名 -p 包名 -l 语言 -d 目标文件夹,例如./cocos new HelloWorld -p com.history.HelloWorld -l cpp -d ~/Wrok/Projects/Privates/.执行后就有如下提示: 123456Running command: new&gt; Copy template into /Users/history/Wrok/Projects/Privates/HelloWorld&gt; Copying cocos2d-x files...&gt; Rename project name from &#x27;HelloCpp&#x27; to &#x27;HelloWorld&#x27;&gt; Replace the project name from &#x27;HelloCpp&#x27; to &#x27;HelloWorld&#x27;&gt; Replace the project package name from &#x27;org.cocos2dx.hellocpp&#x27; to &#x27;com.history.HelloWorld&#x27; 这样就大功告成了.","categories":[{"name":"cocos2d-x","slug":"cocos2d-x","permalink":"https://kelvinqq.github.io/categories/cocos2d-x/"}],"tags":[{"name":"cocos2d","slug":"cocos2d","permalink":"https://kelvinqq.github.io/tags/cocos2d/"}]},{"title":"博客分页和阅读更多功能","slug":"博客分页和阅读更多功能","date":"2014-08-06T15:21:01.000Z","updated":"2021-09-05T14:37:20.926Z","comments":true,"path":"2014/08/06/博客分页和阅读更多功能/","link":"","permalink":"https://kelvinqq.github.io/2014/08/06/%E5%8D%9A%E5%AE%A2%E5%88%86%E9%A1%B5%E5%92%8C%E9%98%85%E8%AF%BB%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD/","excerpt":"博客也写了几篇了,一页显示有点长,于是就着手分页功能.顺便设置一下”继续阅读”的功能. 分页 找到source/index.html文件,找到这段代码:","text":"博客也写了几篇了,一页显示有点长,于是就着手分页功能.顺便设置一下”继续阅读”的功能. 分页 找到source/index.html文件,找到这段代码: 修改为: 继续阅读 打开_config.yml文件,找到excerpt_link字段,你可以修改为自己想要显示的文字,”继续阅读”或者”Read More”等.注意到excerpt_separator这个字段,内容是&lt;!--more--&gt;,这个就是告诉你在写文章的时候,在你想要显示为”继续阅读”的地方添加上&lt;!--more--&gt;即可.","categories":[{"name":"日记","slug":"日记","permalink":"https://kelvinqq.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://kelvinqq.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"iOS配置gitignore文件","slug":"iOS配置gitignore文件","date":"2014-08-04T14:25:49.000Z","updated":"2021-08-27T13:34:42.826Z","comments":true,"path":"2014/08/04/iOS配置gitignore文件/","link":"","permalink":"https://kelvinqq.github.io/2014/08/04/iOS%E9%85%8D%E7%BD%AEgitignore%E6%96%87%E4%BB%B6/","excerpt":"iOS开发中如果使用Git来管理源代码,很多文件是不需要上传到服务器的,这时候我们就需要配置.gitignore文件.具体做法是:","text":"iOS开发中如果使用Git来管理源代码,很多文件是不需要上传到服务器的,这时候我们就需要配置.gitignore文件.具体做法是: 123456789101112131415161718192021# Xcode.DS_Store*/build/**.pbxuser!default.pbxuser*.mode1v3!default.mode1v3*.mode2v3!default.mode2v3*.perspectivev3!default.perspectivev3xcuserdataprofile*.moved-asideDerivedData.idea/*.hmap*.orig# CocoaPodsPods 拷贝上述代码到记事本中,然后保存到你的项目根目录下,文件名为.gitignore.注意,不要有.txt等后缀.该文件是隐藏的,如果需要显示Mac隐藏文件,如下命令即可: 1defaults write com.apple.finder AppleShowAllFiles -bool true 输完单击Enter键，退出终端，重新启动Finder就可以了 重启Finder：按住option,鼠标左击dock上的Finder图标不松,直到出现菜单后点击重新开启即可. 顺便附上隐藏Mac隐藏文件命令: 1defaults write com.apple.finder AppleShowAllFiles -bool false","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://kelvinqq.github.io/tags/Git/"}]},{"title":"iOS提交AppStore时描述翻译","slug":"iOS提交AppStore时描述翻译","date":"2014-08-04T12:03:45.000Z","updated":"2021-08-27T13:34:42.825Z","comments":true,"path":"2014/08/04/iOS提交AppStore时描述翻译/","link":"","permalink":"https://kelvinqq.github.io/2014/08/04/iOS%E6%8F%90%E4%BA%A4AppStore%E6%97%B6%E6%8F%8F%E8%BF%B0%E7%BF%BB%E8%AF%91/","excerpt":"提交AppStore时有很多选项,不过都是英文的.这里收集一下,以备查阅. AppleContent Descriptions None Infrequent/Mild 苹果内容描述 不存在 频繁或强烈的","text":"提交AppStore时有很多选项,不过都是英文的.这里收集一下,以备查阅. AppleContent Descriptions None Infrequent/Mild 苹果内容描述 不存在 频繁或强烈的 选项 | 翻译:—|:—|:—Cartoon or Fantasy Violence | 卡通或幻想暴力Realistic Violence | 现实暴力Sexual Content or Nudity | 性爱或裸体内容Profanity or Crude Humor | 亵渎或低俗笑话Alcohol, Tobacco, or Drug Use or References | 研究或毒品相关内容Mature/Suggestive Themes | 成人或性暗示主题Simulated Gambling | 模拟赌博Horror/Fear Themes | 恐怖/惊悚题材Prolonged graphic or sadistic realistic violence | 持久直白或虐待狂现实暴力Graphic sexual content and nudity | 直白的色情和裸色内容 ps:以上内容转自 唯高的博客 中发布iOS有用到苹果商店时选择应用分级的中文翻译.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"AppStore","slug":"AppStore","permalink":"https://kelvinqq.github.io/tags/AppStore/"},{"name":"翻译","slug":"翻译","permalink":"https://kelvinqq.github.io/tags/%E7%BF%BB%E8%AF%91/"}]},{"title":"iOS合并真机和模拟器静态库","slug":"iOS合并真机和模拟器静态库","date":"2014-08-03T02:48:38.000Z","updated":"2021-08-27T13:34:42.825Z","comments":true,"path":"2014/08/03/iOS合并真机和模拟器静态库/","link":"","permalink":"https://kelvinqq.github.io/2014/08/03/iOS%E5%90%88%E5%B9%B6%E7%9C%9F%E6%9C%BA%E5%92%8C%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%9D%99%E6%80%81%E5%BA%93/","excerpt":"前言有时候会在真机和模拟器间切换,总是来回替换库到是很不方便.这样可以在开发的时候将真机和模拟器库何必为一个文件,等到发布的时候再替换为真机库即可.","text":"前言有时候会在真机和模拟器间切换,总是来回替换库到是很不方便.这样可以在开发的时候将真机和模拟器库何必为一个文件,等到发布的时候再替换为真机库即可. 正文使用下面的命令即可合并两个静态库. 1lipo -create /libXXSimulator.a /libXXOs.a -output /libXX.a 使用的时候记得注意文件的路径.其中-create后的两个参数是真机和模拟器静态库的路径,-output后面的参数是合并后的静态库路径.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"静态库","slug":"静态库","permalink":"https://kelvinqq.github.io/tags/%E9%9D%99%E6%80%81%E5%BA%93/"}]},{"title":"hidesBottomBarWhenPushed用法","slug":"hidesBottomBarWhenPushed用法","date":"2014-08-02T02:12:57.000Z","updated":"2021-08-27T13:34:42.824Z","comments":true,"path":"2014/08/02/hidesBottomBarWhenPushed用法/","link":"","permalink":"https://kelvinqq.github.io/2014/08/02/hidesBottomBarWhenPushed%E7%94%A8%E6%B3%95/","excerpt":"前言前两天看论坛又看到有人在问hidesBottomBarWhenPushed到底怎么用,为什么他用总是不对.所以在这里还是总结下,希望可以帮助更多的人.","text":"前言前两天看论坛又看到有人在问hidesBottomBarWhenPushed到底怎么用,为什么他用总是不对.所以在这里还是总结下,希望可以帮助更多的人. 正文在使用TabBar的时候,需要在push到下个页面的时候隐藏TabBar,再pop回来的时候显示TabBar.以前有很多博客是说使用hidden参数,不过总是有黑边,遂又有一堆博客解决如何去掉黑边,甚至有人自定义了TabBar. 其实看看API就会发现有hidesBottomBarWhenPushed这个属性可以使用.不过很多人用了发现有点问题,比如有A-&gt;B-&gt;C这个push流程,其中A中有TabBar,B和C中需要隐藏,很多人从A push到 B是可以隐藏TabBar,可是B push到 C又冒出来了.或者从C pop到 B又冒出来了.反正就是不对. 说到底,还是用法有误.Apple不会给一个错误的API的.其实你可以在B和C的init函数中使用self.hidesBottomBarWhenPushed = YES,这样就可以达到你想要的效果了.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"TabBar","slug":"TabBar","permalink":"https://kelvinqq.github.io/tags/TabBar/"}]},{"title":"GitHub博客访问超慢解决","slug":"GitHub博客访问超慢解决","date":"2014-08-01T15:57:58.000Z","updated":"2021-08-27T13:34:42.821Z","comments":true,"path":"2014/08/01/GitHub博客访问超慢解决/","link":"","permalink":"https://kelvinqq.github.io/2014/08/01/GitHub%E5%8D%9A%E5%AE%A2%E8%AE%BF%E9%97%AE%E8%B6%85%E6%85%A2%E8%A7%A3%E5%86%B3/","excerpt":"越来越发现博客访问速度超慢了,看了几篇博客说是google的问题,就把所有关于google的东西都删了,还是很慢.也参照过唐巧的技术博客象写程序一样写博客：搭建基于github的博客中: 主要是修改文件：_config.yml ，这个配置文件都有相应的注释。主要就是改一些博客头，作者名之类的东西。 注意最好把里面的twitter相关的信息全部删掉，否则由于GFW的原因，将会造成页面load很慢。 修改定制文件/source/_includes/custom/head.html 把google的自定义字体去掉，原因同上。","text":"越来越发现博客访问速度超慢了,看了几篇博客说是google的问题,就把所有关于google的东西都删了,还是很慢.也参照过唐巧的技术博客象写程序一样写博客：搭建基于github的博客中: 主要是修改文件：_config.yml ，这个配置文件都有相应的注释。主要就是改一些博客头，作者名之类的东西。 注意最好把里面的twitter相关的信息全部删掉，否则由于GFW的原因，将会造成页面load很慢。 修改定制文件/source/_includes/custom/head.html 把google的自定义字体去掉，原因同上。 可是发现还是很慢.最终测试发现每次加载其实是由于在加载汉字时很慢,加载英文,图片和数字倒是很快,再参考网上所说还是觉得使用了google的字体.所以决定还是找个博客看一下他们的字体是怎么设置的. 于是进入了码农人生的GitHub主页,然后进入source分支,找到msching.github.io / source / _includes / head.html这个文件,打开后和我的文件对比,发现他主要修改了这里: &lt;!--[good job! gfw]&gt;&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;!--&gt; &lt;script src=&quot;http://cdn.staticfile.org/jquery/1.9.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;link href=&quot;/stylesheets/google-fonts.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt; 还写上了注释,于是无耻的偷了过来,不过要注意,第三行中的.css文件是本地的引用,在/stylesheets/google-fonts.css中,于是来到msching.github.io / source / stylesheets / google-fonts.css这里,拷贝下文件内容新建并保存到同样的目录下. 大功告成,上传后试了下,果然速度大幅度提升.","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://kelvinqq.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://kelvinqq.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"圆形头像","slug":"圆形头像","date":"2014-07-29T15:12:01.000Z","updated":"2021-08-27T13:34:42.827Z","comments":true,"path":"2014/07/29/圆形头像/","link":"","permalink":"https://kelvinqq.github.io/2014/07/29/%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8F/","excerpt":"看过很多圆形头像的APP了.比如最近QQ又更新了,头像都变成圆形的了.其实在iOS实现这个很简单,几句代码即可.下面还是贴出来以便查阅.","text":"看过很多圆形头像的APP了.比如最近QQ又更新了,头像都变成圆形的了.其实在iOS实现这个很简单,几句代码即可.下面还是贴出来以便查阅. 12345[imageView.layer setCornerRadius:CGRectGetHeight(imageView.bounds) / 2];imageView.layer.masksToBounds = YES;// 下面两句是设置圆周的线条颜色,可以根据实际情况选择imageView.layer.borderWidth = 3.f;imageView.layer.borderColor = [[UIColor whiteColor] CGColor]; 最后上一张图吧.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"圆形头像","slug":"圆形头像","permalink":"https://kelvinqq.github.io/tags/%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8F/"}]},{"title":"引入三方库编译错误解决","slug":"引入三方库编译错误解决","date":"2014-07-27T06:10:28.000Z","updated":"2021-08-27T13:34:42.828Z","comments":true,"path":"2014/07/27/引入三方库编译错误解决/","link":"","permalink":"https://kelvinqq.github.io/2014/07/27/%E5%BC%95%E5%85%A5%E4%B8%89%E6%96%B9%E5%BA%93%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/","excerpt":"前言Coding中不免要引入三方库,有时候会出现很多编译错误,在此收集一下. 正文1.如下错误可在Other Link Flags添加-licucore解决","text":"前言Coding中不免要引入三方库,有时候会出现很多编译错误,在此收集一下. 正文1.如下错误可在Other Link Flags添加-licucore解决 12345678910111213141516171819202122232425262728293031323334353637Undefined symbols for architecture i386: &quot;_u_errorName&quot;, referenced from: _cm_rkl_NSExceptionForRegex in AGCommon _cm_rkl_userInfoDictionary in AGCommon &quot;_u_strlen&quot;, referenced from: _cm_rkl_userInfoDictionary in AGCommon &quot;_uregex_appendReplacement&quot;, referenced from: _cm_rkl_replaceAll in AGCommon &quot;_uregex_appendTail&quot;, referenced from: _cm_rkl_replaceAll in AGCommon &quot;_uregex_clone&quot;, referenced from: -[CMRKLBlockEnumerationHelper initWithRegex:options:string:range:error:] in AGCommon &quot;_uregex_close&quot;, referenced from: _cm_rkl_clearCachedRegex in AGCommon &quot;_uregex_end&quot;, referenced from: _cm_rkl_performRegexOp in AGCommon _cm_rkl_findRanges in AGCommon _cm_rkl_search in AGCommon &quot;_uregex_find&quot;, referenced from: _cm_rkl_search in AGCommon &quot;_uregex_findNext&quot;, referenced from: _cm_rkl_search in AGCommon _cm_rkl_replaceAll in AGCommon &quot;_uregex_groupCount&quot;, referenced from: _cm_rkl_getCachedRegex in AGCommon &quot;_uregex_open&quot;, referenced from: _cm_rkl_getCachedRegex in AGCommon &quot;_uregex_reset&quot;, referenced from: _cm_rkl_replaceAll in AGCommon &quot;_uregex_setText&quot;, referenced from: -[CMRKLBlockEnumerationHelper initWithRegex:options:string:range:error:] in AGCommon _cm_rkl_performRegexOp in AGCommon _cm_rkl_clearCachedRegexSetTo in AGCommon &quot;_uregex_start&quot;, referenced from: _cm_rkl_performRegexOp in AGCommon _cm_rkl_findRanges in AGCommon _cm_rkl_search in AGCommon","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"编译","slug":"编译","permalink":"https://kelvinqq.github.io/tags/%E7%BC%96%E8%AF%91/"}]},{"title":"NSArray对所有元素操作","slug":"NSArray对所有元素操作","date":"2014-07-23T12:45:17.000Z","updated":"2021-08-27T13:34:42.822Z","comments":true,"path":"2014/07/23/NSArray对所有元素操作/","link":"","permalink":"https://kelvinqq.github.io/2014/07/23/NSArray%E5%AF%B9%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C/","excerpt":"看别人的源码无意中看到一个方法,是NSArray的实例方法: 12- (void)makeObjectsPerformSelector:(SEL)aSelector;- (void)makeObjectsPerformSelector:(SEL)aSelector withObject:(id)argument;","text":"看别人的源码无意中看到一个方法,是NSArray的实例方法: 12- (void)makeObjectsPerformSelector:(SEL)aSelector;- (void)makeObjectsPerformSelector:(SEL)aSelector withObject:(id)argument; 用处是让NSArray中的每一个元素都执行aSelector方法,还可以带参数argument.体验如下: 1[[self.view subviews] makeObjectsPerformSelector:@selector(removeFromSuperview)]; 再也不用for循环去删除每一个子view了.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"NSArray","slug":"NSArray","permalink":"https://kelvinqq.github.io/tags/NSArray/"}]},{"title":"AutoLayout的使用","slug":"AutoLayout的使用","date":"2014-07-20T03:01:35.000Z","updated":"2021-08-27T13:34:42.819Z","comments":true,"path":"2014/07/20/AutoLayout的使用/","link":"","permalink":"https://kelvinqq.github.io/2014/07/20/AutoLayout%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"前言iOS8快要发正式版了,iPhone6也要出新的尺寸了,如果你还没有用Storyboard和AutoLayout那将是一种痛苦. 正文自从iPhone出了不同分辨率的屏幕后,iOS开发者也渐渐开始有了android开发者的痛苦了.当然Apple也提供了新的技术来尽量让开发者没有那么费劲.所以就推出了AutoLayout的技术.由于只能支持到IOS6,所以还是有部分的APP没有使用.不过相信还是大势所趋的.如果你的App都是使用storyboard或者xib来构建的,直接使用可视化操作就可以很轻松的完成了.但是对于复杂的UI免不了使用coding.这时候你就需要手动的去写那么autolayout代码.虽然autolayout的代码也是比较易理解,但是还是不那么的方便.这里推荐大家一个开源库,封装的还可以.是UIView的一个Category.GitHub上的主页在这里.","text":"前言iOS8快要发正式版了,iPhone6也要出新的尺寸了,如果你还没有用Storyboard和AutoLayout那将是一种痛苦. 正文自从iPhone出了不同分辨率的屏幕后,iOS开发者也渐渐开始有了android开发者的痛苦了.当然Apple也提供了新的技术来尽量让开发者没有那么费劲.所以就推出了AutoLayout的技术.由于只能支持到IOS6,所以还是有部分的APP没有使用.不过相信还是大势所趋的.如果你的App都是使用storyboard或者xib来构建的,直接使用可视化操作就可以很轻松的完成了.但是对于复杂的UI免不了使用coding.这时候你就需要手动的去写那么autolayout代码.虽然autolayout的代码也是比较易理解,但是还是不那么的方便.这里推荐大家一个开源库,封装的还可以.是UIView的一个Category.GitHub上的主页在这里. 平时用的多的API也就是设置宽高,设置和父窗口的相对位置以及设置和兄弟窗口的相对位置.如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** Centers the view in its superview. */- (NSArray *)autoCenterInSuperview;/** Aligns the view to the same axis of its superview. */- (NSLayoutConstraint *)autoAlignAxisToSuperviewAxis:(ALAxis)axis;# pragma mark Pin Edges to Superview/** Pins the given edge of the view to the same edge of the superview with an inset. */- (NSLayoutConstraint *)autoPinEdgeToSuperviewEdge:(ALEdge)edge withInset:(CGFloat)inset;/** Pins the edges of the view to the edges of its superview with the given edge insets. */- (NSArray *)autoPinEdgesToSuperviewEdgesWithInsets:(ALEdgeInsets)insets;/** Pins 3 of the 4 edges of the view to the edges of its superview with the given edge insets, excluding one edge. */- (NSArray *)autoPinEdgesToSuperviewEdgesWithInsets:(ALEdgeInsets)insets excludingEdge:(ALEdge)edge;# pragma mark Pin Edges/** Pins an edge of the view to a given edge of another view. */- (NSLayoutConstraint *)autoPinEdge:(ALEdge)edge toEdge:(ALEdge)toEdge ofView:(ALView *)peerView;/** Pins an edge of the view to a given edge of another view with an offset. */- (NSLayoutConstraint *)autoPinEdge:(ALEdge)edge toEdge:(ALEdge)toEdge ofView:(ALView *)peerView withOffset:(CGFloat)offset; # pragma mark Align Axes/** Aligns an axis of the view to the same axis of another view. */- (NSLayoutConstraint *)autoAlignAxis:(ALAxis)axis toSameAxisOfView:(ALView *)peerView;/** Aligns an axis of the view to the same axis of another view with an offset. */- (NSLayoutConstraint *)autoAlignAxis:(ALAxis)axis toSameAxisOfView:(ALView *)peerView withOffset:(CGFloat)offset;# pragma mark Match Dimensions/** Matches a dimension of the view to a given dimension of another view. */- (NSLayoutConstraint *)autoMatchDimension:(ALDimension)dimension toDimension:(ALDimension)toDimension ofView:(ALView *)peerView;/** Matches a dimension of the view to a given dimension of another view with an offset. */- (NSLayoutConstraint *)autoMatchDimension:(ALDimension)dimension toDimension:(ALDimension)toDimension ofView:(ALView *)peerView withOffset:(CGFloat)offset; # pragma mark Set Dimensions/** Sets the view to a specific size. */- (NSArray *)autoSetDimensionsToSize:(CGSize)size;/** Sets the given dimension of the view to a specific size. */- (NSLayoutConstraint *)autoSetDimension:(ALDimension)dimension toSize:(CGFloat)size; 还有其他如设置relationship的API,大家可自行查看GitHub上的主页.","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"iOS8","slug":"iOS8","permalink":"https://kelvinqq.github.io/tags/iOS8/"},{"name":"AutoLayout","slug":"AutoLayout","permalink":"https://kelvinqq.github.io/tags/AutoLayout/"}]},{"title":"iOS唯一标志","slug":"iOS唯一标志","date":"2014-07-19T13:33:48.000Z","updated":"2021-08-27T13:34:42.825Z","comments":true,"path":"2014/07/19/iOS唯一标志/","link":"","permalink":"https://kelvinqq.github.io/2014/07/19/iOS%E5%94%AF%E4%B8%80%E6%A0%87%E5%BF%97/","excerpt":"背景由于iOS对于用户隐私的保护,使得在iOS下面想要拿到一个唯一的设备号是不怎么方便的.当然在IOS5,6中还是可以有那么一丝希望的,UUID,MAC地址等.可是后来,苹果彻底把所有的路都堵死了.瞬间大家都觉得没戏了. 新方案既然我写这个博客,说明还是有方法的.大家都知道在Mac OSX上有Keychain,可以保存用户的所有密码.其实在iOS上也有这个Keychain的,只不过没有像Mac OSX上面那样的App来管理罢了.所以,我们就可以借用这个Keychain来构造设备的唯一标志.至于iOS底层的库我就不多说了,直接推荐一个三方开源库,SSKeychain,大家可以去GitHub下载,也可以使用CocosPods来管理.","text":"背景由于iOS对于用户隐私的保护,使得在iOS下面想要拿到一个唯一的设备号是不怎么方便的.当然在IOS5,6中还是可以有那么一丝希望的,UUID,MAC地址等.可是后来,苹果彻底把所有的路都堵死了.瞬间大家都觉得没戏了. 新方案既然我写这个博客,说明还是有方法的.大家都知道在Mac OSX上有Keychain,可以保存用户的所有密码.其实在iOS上也有这个Keychain的,只不过没有像Mac OSX上面那样的App来管理罢了.所以,我们就可以借用这个Keychain来构造设备的唯一标志.至于iOS底层的库我就不多说了,直接推荐一个三方开源库,SSKeychain,大家可以去GitHub下载,也可以使用CocosPods来管理. API我们主要使用SSKeychain中的几个API. a.获取密码12+ (NSString *)passwordForService:(NSString *)serviceName account:(NSString *)account;+ (NSString *)passwordForService:(NSString *)serviceName account:(NSString *)account error:(NSError **)error; b.删除密码12+ (BOOL)deletePasswordForService:(NSString *)serviceName account:(NSString *)account;+ (BOOL)deletePasswordForService:(NSString *)serviceName account:(NSString *)account error:(NSError **)error; c.设置密码12+ (BOOL)setPassword:(NSString *)password forService:(NSString *)serviceName account:(NSString *)account;+ (BOOL)setPassword:(NSString *)password forService:(NSString *)serviceName account:(NSString *)account error:(NSError **)error; 当然,我们是需要一个唯一标志,所以就需要生成一个UUID,这样就可以用SSKeychain来设置密码为生成的UUID,具体操作如下: 1.创建一个NSString的Category生成UUID123456789@implementation NSString (Extension)+ (NSString *)stringForUUID&#123; CFUUIDRef uuidObj = CFUUIDCreate(nil); NSString *uuidString = (NSString *)CFBridgingRelease(CFUUIDCreateString(nil, uuidObj)); CFRelease(uuidObj); return uuidString;&#125;@end 2.创建一个HZKeychainManager1234567891011121314@implementation HZKeychainManager+ (NSString *)appUUID&#123; NSError *error = nil; NSString *uuid = [SSKeychain passwordForService:@&quot;com.company.app.service&quot; account:@&quot;com.company.app.account&quot; error:&amp;error]; // 获取 密码 if (!uuid.length) &#123; // 如果获取不到 则新保存一个 uuid = [NSString stringForUUID]; BOOL res = [SSKeychain setPassword:uuid forService:kDBServiceKey account:kDBAccountKey error:&amp;error]; if (!res) &#123; &#125; &#125; return uuid;&#125;@end","categories":[{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"}],"tags":[{"name":"UDID","slug":"UDID","permalink":"https://kelvinqq.github.io/tags/UDID/"},{"name":"唯一标志","slug":"唯一标志","permalink":"https://kelvinqq.github.io/tags/%E5%94%AF%E4%B8%80%E6%A0%87%E5%BF%97/"}]},{"title":"安家GitHub","slug":"安家GitHub","date":"2014-07-19T07:03:58.000Z","updated":"2021-09-05T14:37:36.861Z","comments":true,"path":"2014/07/19/安家GitHub/","link":"","permalink":"https://kelvinqq.github.io/2014/07/19/%E5%AE%89%E5%AE%B6GitHub/","excerpt":"前言终于在GitHub安家博客了,看了很多博客,对*.github.io特感兴趣,GitHub找了一圈也没发现人家开博客服务.正好前段时间又忙,没空理会,所以搁浅了.正好这段时间稍闲,简单看了一下,不明觉厉.仔细研究了下,原来还是代码托管.索性我也弄一个试一下.顺便也给自己的码农生活记录一下.","text":"前言终于在GitHub安家博客了,看了很多博客,对*.github.io特感兴趣,GitHub找了一圈也没发现人家开博客服务.正好前段时间又忙,没空理会,所以搁浅了.正好这段时间稍闲,简单看了一下,不明觉厉.仔细研究了下,原来还是代码托管.索性我也弄一个试一下.顺便也给自己的码农生活记录一下. 总结其实利用GitHub和Octopress搭建博客已经有很多人的博客都记录了.这里我就不重复了,还是把我参考的一些博客贴出来,也让大家少走一些弯路. 首先是码农人生的博客基于Github和Octopress搭建属于自己的博客,大体上都是参考他的.其次是唐巧的技术博客象写程序一样写博客：搭建基于github的博客和将博客从GitHub迁移到GitCafe.最后是markdown标记的使用,本人小菜,所以借助了其他软件Mou,用了一下,感觉还可以. 尾声好了,就这么多了.愿自己坚持下去.","categories":[{"name":"日记","slug":"日记","permalink":"https://kelvinqq.github.io/categories/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://kelvinqq.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"日记","slug":"日记","permalink":"https://kelvinqq.github.io/categories/%E6%97%A5%E8%AE%B0/"},{"name":"Flutter","slug":"Flutter","permalink":"https://kelvinqq.github.io/categories/Flutter/"},{"name":"Android","slug":"Android","permalink":"https://kelvinqq.github.io/categories/Android/"},{"name":"源码推荐","slug":"源码推荐","permalink":"https://kelvinqq.github.io/categories/%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90/"},{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/categories/iOS/"},{"name":"小程序","slug":"小程序","permalink":"https://kelvinqq.github.io/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://kelvinqq.github.io/categories/FFmpeg/"},{"name":"Geohash系列","slug":"Geohash系列","permalink":"https://kelvinqq.github.io/categories/Geohash%E7%B3%BB%E5%88%97/"},{"name":"cocos2d-x","slug":"cocos2d-x","permalink":"https://kelvinqq.github.io/categories/cocos2d-x/"},{"name":"杂谈","slug":"杂谈","permalink":"https://kelvinqq.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"体检","slug":"体检","permalink":"https://kelvinqq.github.io/tags/%E4%BD%93%E6%A3%80/"},{"name":"组件化","slug":"组件化","permalink":"https://kelvinqq.github.io/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"},{"name":"工程化","slug":"工程化","permalink":"https://kelvinqq.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"上线","slug":"上线","permalink":"https://kelvinqq.github.io/tags/%E4%B8%8A%E7%BA%BF/"},{"name":"日记","slug":"日记","permalink":"https://kelvinqq.github.io/tags/%E6%97%A5%E8%AE%B0/"},{"name":"吃瓜","slug":"吃瓜","permalink":"https://kelvinqq.github.io/tags/%E5%90%83%E7%93%9C/"},{"name":"冲突","slug":"冲突","permalink":"https://kelvinqq.github.io/tags/%E5%86%B2%E7%AA%81/"},{"name":"Tinker","slug":"Tinker","permalink":"https://kelvinqq.github.io/tags/Tinker/"},{"name":"小程序","slug":"小程序","permalink":"https://kelvinqq.github.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"古诗","slug":"古诗","permalink":"https://kelvinqq.github.io/tags/%E5%8F%A4%E8%AF%97/"},{"name":"Github","slug":"Github","permalink":"https://kelvinqq.github.io/tags/Github/"},{"name":"定位","slug":"定位","permalink":"https://kelvinqq.github.io/tags/%E5%AE%9A%E4%BD%8D/"},{"name":"疯言疯语","slug":"疯言疯语","permalink":"https://kelvinqq.github.io/tags/%E7%96%AF%E8%A8%80%E7%96%AF%E8%AF%AD/"},{"name":"LeanCloud","slug":"LeanCloud","permalink":"https://kelvinqq.github.io/tags/LeanCloud/"},{"name":"赞赏","slug":"赞赏","permalink":"https://kelvinqq.github.io/tags/%E8%B5%9E%E8%B5%8F/"},{"name":"iOS","slug":"iOS","permalink":"https://kelvinqq.github.io/tags/iOS/"},{"name":"面试","slug":"面试","permalink":"https://kelvinqq.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Flutter","slug":"Flutter","permalink":"https://kelvinqq.github.io/tags/Flutter/"},{"name":"Canvas","slug":"Canvas","permalink":"https://kelvinqq.github.io/tags/Canvas/"},{"name":"公众号","slug":"公众号","permalink":"https://kelvinqq.github.io/tags/%E5%85%AC%E4%BC%97%E5%8F%B7/"},{"name":"Swift","slug":"Swift","permalink":"https://kelvinqq.github.io/tags/Swift/"},{"name":"Swift4","slug":"Swift4","permalink":"https://kelvinqq.github.io/tags/Swift4/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://kelvinqq.github.io/tags/CocoaPods/"},{"name":"自动打包","slug":"自动打包","permalink":"https://kelvinqq.github.io/tags/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/"},{"name":"xcodebuild","slug":"xcodebuild","permalink":"https://kelvinqq.github.io/tags/xcodebuild/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://kelvinqq.github.io/tags/Jenkins/"},{"name":"Xcode9","slug":"Xcode9","permalink":"https://kelvinqq.github.io/tags/Xcode9/"},{"name":"音量","slug":"音量","permalink":"https://kelvinqq.github.io/tags/%E9%9F%B3%E9%87%8F/"},{"name":"MPVolumeView","slug":"MPVolumeView","permalink":"https://kelvinqq.github.io/tags/MPVolumeView/"},{"name":"打电话","slug":"打电话","permalink":"https://kelvinqq.github.io/tags/%E6%89%93%E7%94%B5%E8%AF%9D/"},{"name":"蓝牙","slug":"蓝牙","permalink":"https://kelvinqq.github.io/tags/%E8%93%9D%E7%89%99/"},{"name":"PBAP","slug":"PBAP","permalink":"https://kelvinqq.github.io/tags/PBAP/"},{"name":"电话","slug":"电话","permalink":"https://kelvinqq.github.io/tags/%E7%94%B5%E8%AF%9D/"},{"name":"小飞鱼","slug":"小飞鱼","permalink":"https://kelvinqq.github.io/tags/%E5%B0%8F%E9%A3%9E%E9%B1%BC/"},{"name":"Log","slug":"Log","permalink":"https://kelvinqq.github.io/tags/Log/"},{"name":"开源协议","slug":"开源协议","permalink":"https://kelvinqq.github.io/tags/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"},{"name":"LazyScrollView","slug":"LazyScrollView","permalink":"https://kelvinqq.github.io/tags/LazyScrollView/"},{"name":"高性能","slug":"高性能","permalink":"https://kelvinqq.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"},{"name":"单例","slug":"单例","permalink":"https://kelvinqq.github.io/tags/%E5%8D%95%E4%BE%8B/"},{"name":"AutoLayout","slug":"AutoLayout","permalink":"https://kelvinqq.github.io/tags/AutoLayout/"},{"name":"iOS10","slug":"iOS10","permalink":"https://kelvinqq.github.io/tags/iOS10/"},{"name":"多Target","slug":"多Target","permalink":"https://kelvinqq.github.io/tags/%E5%A4%9ATarget/"},{"name":"多版本","slug":"多版本","permalink":"https://kelvinqq.github.io/tags/%E5%A4%9A%E7%89%88%E6%9C%AC/"},{"name":"FFmpeg","slug":"FFmpeg","permalink":"https://kelvinqq.github.io/tags/FFmpeg/"},{"name":"Geohash","slug":"Geohash","permalink":"https://kelvinqq.github.io/tags/Geohash/"},{"name":"ScrollView","slug":"ScrollView","permalink":"https://kelvinqq.github.io/tags/ScrollView/"},{"name":"计算器","slug":"计算器","permalink":"https://kelvinqq.github.io/tags/%E8%AE%A1%E7%AE%97%E5%99%A8/"},{"name":"AppStore","slug":"AppStore","permalink":"https://kelvinqq.github.io/tags/AppStore/"},{"name":"拼音","slug":"拼音","permalink":"https://kelvinqq.github.io/tags/%E6%8B%BC%E9%9F%B3/"},{"name":"UITableView","slug":"UITableView","permalink":"https://kelvinqq.github.io/tags/UITableView/"},{"name":"Runtime","slug":"Runtime","permalink":"https://kelvinqq.github.io/tags/Runtime/"},{"name":"shell","slug":"shell","permalink":"https://kelvinqq.github.io/tags/shell/"},{"name":"cocos2d","slug":"cocos2d","permalink":"https://kelvinqq.github.io/tags/cocos2d/"},{"name":"博客","slug":"博客","permalink":"https://kelvinqq.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Git","slug":"Git","permalink":"https://kelvinqq.github.io/tags/Git/"},{"name":"翻译","slug":"翻译","permalink":"https://kelvinqq.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"静态库","slug":"静态库","permalink":"https://kelvinqq.github.io/tags/%E9%9D%99%E6%80%81%E5%BA%93/"},{"name":"TabBar","slug":"TabBar","permalink":"https://kelvinqq.github.io/tags/TabBar/"},{"name":"圆形头像","slug":"圆形头像","permalink":"https://kelvinqq.github.io/tags/%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8F/"},{"name":"编译","slug":"编译","permalink":"https://kelvinqq.github.io/tags/%E7%BC%96%E8%AF%91/"},{"name":"NSArray","slug":"NSArray","permalink":"https://kelvinqq.github.io/tags/NSArray/"},{"name":"iOS8","slug":"iOS8","permalink":"https://kelvinqq.github.io/tags/iOS8/"},{"name":"UDID","slug":"UDID","permalink":"https://kelvinqq.github.io/tags/UDID/"},{"name":"唯一标志","slug":"唯一标志","permalink":"https://kelvinqq.github.io/tags/%E5%94%AF%E4%B8%80%E6%A0%87%E5%BF%97/"}]}