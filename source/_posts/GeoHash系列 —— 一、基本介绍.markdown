---
title: "GeoHash系列 —— 一、基本介绍"
date: 2015-08-26 09:47:41 +0800
tags: 
	- Geohash
categories:
	- Geohash系列
---

系列文章

[`GeoHash`系列 —— 一、基本介绍](http://historyzhang.github.io/2015/08/26/2015-08-26-geohash-xi-lie-zhi-yi-ji-ben-jie-shao/)

[`GeoHash`系列 —— 二、算法步骤](http://historyzhang.github.io/2015/08/27/2015-08-27-geohash-xi-lie-er-suan-fa-bu-zou/)

# 引子

目前很多的App都会使用到用户的地理位置信息，然后为用户提供相关服务，也就是我们所说的`LBS`。而`LBS`最基本的就是`附近`。所以就会有这样的一个问题：

`什么样叫附近？`

简单来说，附件就是以我为圆心，`radius`为半径画一个圆，圆内的都叫`附近`。

然而事实并没有这么简单。比如我要在地图上找附近的餐馆，不可能说把所有的餐馆和我的距离都算一遍，然后和`radius`比较。

稍微有点编程基础的应该都不会用这个办法。

其实那么庞大的数据，只有一小部分是我们想要的，这样我们通过某种方法来过滤掉不要的餐馆，减少计算的量，就避免了上述方法的弊端。

这样我们可以使用索引技术。

<!--more-->
一提到索引，大家脑子里马上浮现出B树索引，因为大量的数据库（如MySQL、oracle、PostgreSQL等）都在使用B树。B树索引本质上是对索引字段进行排序，然后通过类似二分查找的方法进行快速查找，即它要求索引的字段是可排序的，一般而言，可排序的是一维字段，比如时间、年龄、薪水等等。但是对于空间上的一个点（二维，包括经度和纬度），如何排序呢？又如何索引呢？解决的方法很多，下文介绍一种方法来解决这一问题。

>思想：如果能通过某种方法将二维的点数据转换成一维的数据，那样不就可以继续使用B树索引了嘛。那这种方法真的存在嘛，答案是肯定的。目前很火的GeoHash算法就是运用了上述思想，下面我们就开始GeoHash之旅吧。

# 基本介绍
* `GeoHash`将二维的经纬度转换成字符串，每个字符串代表某一矩形区域。这样，矩形内所有的点（经纬度）都共享相同的`GeoHash`字符串，这样就比较容易做缓存。例如下图展示了北京9个区域的`GeoHash`字符串。例如左上角这个区域内的用户不断发送位置信息请求餐馆数据，由于这些用户的GeoHash字符串都是WX4ER，所以可以把`WX4ER`当作`key`，把该区域的餐馆信息当作`value`来进行缓存，而如果不使用`GeoHash`的话，由于区域内的用户传来的经纬度是各不相同的，很难做缓存。

{% img /images/blog/geohash_1.jpg %}

* 字符串越长，表示的范围越精确。5位的编码能表示10平方千米范围的矩形区域，而6位编码能表示更精细的区域（约0.34平方千米）。

* 字符串相似的表示距离相近（特殊情况后文阐述），这样可以利用字符串的前缀匹配来查询附近的POI信息。如下两个图所示，一个在城区，一个在郊区，城区的`GeoHash`字符串之间比较相似，郊区的字符串之间也比较相似，而城区和郊区的`GeoHash`字符串相似程度要低些。

{% img /images/blog/geohash_2.jpg %}

通过上面的介绍我们知道了`GeoHash`就是一种将经纬度转换成字符串的方法，并且使得在大部分情况下，字符串前缀匹配越多的距离越近，回到我们的案例，根据所在位置查询来查询附近餐馆时，只需要将所在位置经纬度转换成`GeoHash`字符串，并与各个餐馆的`GeoHash`字符串进行前缀匹配，匹配越多的距离越近。

# 下集预告

`GeoHash`算法的步骤

